<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Shubidumdu&#x27;s Rust Book</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item affix "><a href="index.html">Introduction</a></li><li class="chapter-item "><a href="hello/index.html"><strong aria-hidden="true">1.</strong> Hello World</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/comment.html"><strong aria-hidden="true">1.1.</strong> Comments</a></li><li class="chapter-item "><a href="hello/print/index.html"><strong aria-hidden="true">1.2.</strong> Formatted Print</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/debug.html"><strong aria-hidden="true">1.2.1.</strong> Debug</a></li><li class="chapter-item "><a href="hello/print/display/index.html"><strong aria-hidden="true">1.2.2.</strong> Display</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hello/print/display/list.html"><strong aria-hidden="true">1.2.2.1.</strong> Testcase: List</a></li></ol></li><li class="chapter-item "><a href="hello/print/formatting.html"><strong aria-hidden="true">1.2.3.</strong> Formatting</a></li></ol></li></ol></li><li class="chapter-item "><a href="primitives/index.html"><strong aria-hidden="true">2.</strong> Primitives</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="primitives/literals.html"><strong aria-hidden="true">2.1.</strong> Literals and operators</a></li><li class="chapter-item "><a href="primitives/tuple.html"><strong aria-hidden="true">2.2.</strong> Tuples</a></li><li class="chapter-item "><a href="primitives/array.html"><strong aria-hidden="true">2.3.</strong> Arrays and Slices</a></li></ol></li><li class="chapter-item "><a href="custom_types/index.html"><strong aria-hidden="true">3.</strong> Custom Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/structs.html"><strong aria-hidden="true">3.1.</strong> Structures</a></li><li class="chapter-item "><a href="custom_types/enums/index.html"><strong aria-hidden="true">3.2.</strong> Enums</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="custom_types/enums/use.html"><strong aria-hidden="true">3.2.1.</strong> use</a></li><li class="chapter-item "><a href="custom_types/enums/c-like.html"><strong aria-hidden="true">3.2.2.</strong> C-like</a></li><li class="chapter-item "><a href="custom_types/enums/testcase_linked_list.html"><strong aria-hidden="true">3.2.3.</strong> Testcase: linked-list</a></li></ol></li><li class="chapter-item "><a href="custom_types/constants.html"><strong aria-hidden="true">3.3.</strong> constants</a></li></ol></li><li class="chapter-item "><a href="variable_bindings/index.html"><strong aria-hidden="true">4.</strong> Variable Bindings</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="variable_bindings/mut.html"><strong aria-hidden="true">4.1.</strong> Mutability</a></li><li class="chapter-item "><a href="variable_bindings/scope.html"><strong aria-hidden="true">4.2.</strong> Scope and Shadowing</a></li><li class="chapter-item "><a href="variable_bindings/declare.html"><strong aria-hidden="true">4.3.</strong> Declare first</a></li><li class="chapter-item "><a href="variable_bindings/feezing.html"><strong aria-hidden="true">4.4.</strong> Freezing</a></li></ol></li><li class="chapter-item "><a href="types/index.html"><strong aria-hidden="true">5.</strong> Types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="types/casting.html"><strong aria-hidden="true">5.1.</strong> Casting</a></li><li class="chapter-item "><a href="types/literals.html"><strong aria-hidden="true">5.2.</strong> Literals</a></li><li class="chapter-item "><a href="types/inference.html"><strong aria-hidden="true">5.3.</strong> Inference</a></li><li class="chapter-item "><a href="types/aliasing.html"><strong aria-hidden="true">5.4.</strong> Aliasing</a></li></ol></li><li class="chapter-item "><a href="conversion/index.html"><strong aria-hidden="true">6.</strong> Conversion</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="conversion/from_into.html"><strong aria-hidden="true">6.1.</strong> From and Into</a></li><li class="chapter-item "><a href="conversion/try_from_try_into.html"><strong aria-hidden="true">6.2.</strong> TryFrom and TryInto</a></li><li class="chapter-item "><a href="conversion/string.html"><strong aria-hidden="true">6.3.</strong> To and from Strings</a></li></ol></li><li class="chapter-item "><a href="expressions/index.html"><strong aria-hidden="true">7.</strong> Expressions</a></li><li class="chapter-item "><a href="flow_control/index.html"><strong aria-hidden="true">8.</strong> Flow of Control</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/if_else.html"><strong aria-hidden="true">8.1.</strong> if/else</a></li><li class="chapter-item "><a href="flow_control/loop/index.html"><strong aria-hidden="true">8.2.</strong> Loop</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/loop/nested.html"><strong aria-hidden="true">8.2.1.</strong> Nesting and labels</a></li><li class="chapter-item "><a href="flow_control/loop/return.html"><strong aria-hidden="true">8.2.2.</strong> Returning from loops</a></li></ol></li><li class="chapter-item "><a href="flow_control/while.html"><strong aria-hidden="true">8.3.</strong> while</a></li><li class="chapter-item "><a href="flow_control/for.html"><strong aria-hidden="true">8.4.</strong> for and range</a></li><li class="chapter-item "><a href="flow_control/match/index.html"><strong aria-hidden="true">8.5.</strong> match</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring/index.html"><strong aria-hidden="true">8.5.1.</strong> Destructuring</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="flow_control/match/destructuring/tuples.html"><strong aria-hidden="true">8.5.1.1.</strong> tuples</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/enums.html"><strong aria-hidden="true">8.5.1.2.</strong> enums</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/pointers.html"><strong aria-hidden="true">8.5.1.3.</strong> pointers</a></li><li class="chapter-item "><a href="flow_control/match/destructuring/structs.html"><strong aria-hidden="true">8.5.1.4.</strong> structs</a></li></ol></li><li class="chapter-item "><a href="flow_control/match/guards.html"><strong aria-hidden="true">8.5.2.</strong> Guards</a></li><li class="chapter-item "><a href="flow_control/match/binding.html"><strong aria-hidden="true">8.5.3.</strong> Binding</a></li></ol></li><li class="chapter-item "><a href="flow_control/if_let.html"><strong aria-hidden="true">8.6.</strong> if let</a></li><li class="chapter-item "><a href="flow_control/while_let.html"><strong aria-hidden="true">8.7.</strong> while let</a></li></ol></li><li class="chapter-item "><a href="functions/index.html"><strong aria-hidden="true">9.</strong> Functions</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functions/methods.html"><strong aria-hidden="true">9.1.</strong> Methods</a></li><li class="chapter-item "><a href="functions/closures/index.html"><strong aria-hidden="true">9.2.</strong> Closures</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functions/closures/capturing.html"><strong aria-hidden="true">9.2.1.</strong> Capturing</a></li><li class="chapter-item "><a href="functions/closures/input_parameter.html"><strong aria-hidden="true">9.2.2.</strong> As input parameters</a></li><li class="chapter-item "><a href="functions/closures/anonymity.html"><strong aria-hidden="true">9.2.3.</strong> Type anonymity</a></li><li class="chapter-item "><a href="functions/closures/input_functions.html"><strong aria-hidden="true">9.2.4.</strong> Input functions</a></li><li class="chapter-item "><a href="functions/closures/output_parameters.html"><strong aria-hidden="true">9.2.5.</strong> As output parameters</a></li><li class="chapter-item "><a href="functions/closures/closure_examples/index.html"><strong aria-hidden="true">9.2.6.</strong> Examples in std</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functions/closures/closure_examples/iterator.html"><strong aria-hidden="true">9.2.6.1.</strong> Iterator::any</a></li><li class="chapter-item "><a href="functions/closures/closure_examples/searching.html"><strong aria-hidden="true">9.2.6.2.</strong> Searching through iterators</a></li></ol></li></ol></li><li class="chapter-item "><a href="functions/closures/hof.html"><strong aria-hidden="true">9.3.</strong> Higher Order Functions</a></li><li class="chapter-item "><a href="functions/diverging.html"><strong aria-hidden="true">9.4.</strong> Diverging functions</a></li></ol></li><li class="chapter-item "><a href="modules/index.html"><strong aria-hidden="true">10.</strong> Modules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="modules/visibility.html"><strong aria-hidden="true">10.1.</strong> Visibility</a></li><li class="chapter-item "><a href="modules/struct_visibility.html"><strong aria-hidden="true">10.2.</strong> Struct visibility</a></li><li class="chapter-item "><a href="modules/use.html"><strong aria-hidden="true">10.3.</strong> The use declaration</a></li><li class="chapter-item "><a href="modules/super.html"><strong aria-hidden="true">10.4.</strong> super and self</a></li><li class="chapter-item "><a href="modules/split.html"><strong aria-hidden="true">10.5.</strong> File hierarchy</a></li></ol></li><li class="chapter-item "><a href="crates/index.html"><strong aria-hidden="true">11.</strong> Crates</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crates/create_library.html"><strong aria-hidden="true">11.1.</strong> Creating a Library</a></li><li class="chapter-item "><a href="crates/using_library.html"><strong aria-hidden="true">11.2.</strong> Using a Library</a></li></ol></li><li class="chapter-item "><a href="cargo/index.html"><strong aria-hidden="true">12.</strong> Cargo</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="cargo/dependencies.html"><strong aria-hidden="true">12.1.</strong> Dependencies</a></li><li class="chapter-item "><a href="cargo/conventions.html"><strong aria-hidden="true">12.2.</strong> Conventions</a></li><li class="chapter-item "><a href="cargo/tests.html"><strong aria-hidden="true">12.3.</strong> Tests</a></li><li class="chapter-item "><a href="cargo/scripts.html"><strong aria-hidden="true">12.4.</strong> Build Scripts</a></li></ol></li><li class="chapter-item "><a href="attributes/index.html"><strong aria-hidden="true">13.</strong> Attributes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attributes/dead_code.html"><strong aria-hidden="true">13.1.</strong> dead_code</a></li><li class="chapter-item "><a href="attributes/crate.html"><strong aria-hidden="true">13.2.</strong> Crate</a></li><li class="chapter-item "><a href="attributes/cfg/index.html"><strong aria-hidden="true">13.3.</strong> cfg</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="attributes/cfg/custom.html"><strong aria-hidden="true">13.3.1.</strong> Custom</a></li></ol></li></ol></li><li class="chapter-item "><a href="generics/index.html"><strong aria-hidden="true">14.</strong> Generics</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/functions.html"><strong aria-hidden="true">14.1.</strong> Functions</a></li><li class="chapter-item "><a href="generics/implementation.html"><strong aria-hidden="true">14.2.</strong> implementation</a></li><li class="chapter-item "><a href="generics/trait.html"><strong aria-hidden="true">14.3.</strong> Traits</a></li><li class="chapter-item "><a href="generics/bounds/index.html"><strong aria-hidden="true">14.4.</strong> Bounds</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/bounds/empty_bounds.html"><strong aria-hidden="true">14.4.1.</strong> Testcase: empty bounds</a></li></ol></li><li class="chapter-item "><a href="generics/multi_bounds.html"><strong aria-hidden="true">14.5.</strong> Multiple bounds</a></li><li class="chapter-item "><a href="generics/where.html"><strong aria-hidden="true">14.6.</strong> Where clauses</a></li><li class="chapter-item "><a href="generics/new_types.html"><strong aria-hidden="true">14.7.</strong> New Type Idiom</a></li><li class="chapter-item "><a href="generics/assoc_items/index.html"><strong aria-hidden="true">14.8.</strong> Associated items</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/assoc_items/the_problem.html"><strong aria-hidden="true">14.8.1.</strong> The Problem</a></li><li class="chapter-item "><a href="generics/assoc_items/types.html"><strong aria-hidden="true">14.8.2.</strong> Associated types</a></li></ol></li><li class="chapter-item "><a href="generics/phantom/index.html"><strong aria-hidden="true">14.9.</strong> Phantom type parameters</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics/phantom/testcase_units.html"><strong aria-hidden="true">14.9.1.</strong> Testcase: unit clarification</a></li></ol></li></ol></li><li class="chapter-item "><a href="scope/index.html"><strong aria-hidden="true">15.</strong> Scoping rules</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/raii.html"><strong aria-hidden="true">15.1.</strong> RAII</a></li><li class="chapter-item "><a href="scope/move/index.html"><strong aria-hidden="true">15.2.</strong> Ownership and moves</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/move/mutability.html"><strong aria-hidden="true">15.2.1.</strong> Mutability</a></li><li class="chapter-item "><a href="scope/move/partial_moves.html"><strong aria-hidden="true">15.2.2.</strong> Partial moves</a></li></ol></li><li class="chapter-item "><a href="scope/borrow/index.html"><strong aria-hidden="true">15.3.</strong> Borrowing</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/borrow/mutability.html"><strong aria-hidden="true">15.3.1.</strong> Mutability</a></li><li class="chapter-item "><a href="scope/borrow/aliasing.html"><strong aria-hidden="true">15.3.2.</strong> Aliasing</a></li><li class="chapter-item "><a href="scope/borrow/ref.html"><strong aria-hidden="true">15.3.3.</strong> The ref pattern</a></li></ol></li><li class="chapter-item "><a href="scope/lifetime/index.html"><strong aria-hidden="true">15.4.</strong> Lifetimes</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="scope/lifetime/explicit.html"><strong aria-hidden="true">15.4.1.</strong> Explicit annotation</a></li><li class="chapter-item "><a href="scope/lifetime/fn.html"><strong aria-hidden="true">15.4.2.</strong> Functions</a></li><li class="chapter-item "><a href="scope/lifetime/methods.html"><strong aria-hidden="true">15.4.3.</strong> Methods</a></li><li class="chapter-item "><a href="scope/lifetime/struct.html"><strong aria-hidden="true">15.4.4.</strong> Structs</a></li><li class="chapter-item "><a href="scope/lifetime/trait.html"><strong aria-hidden="true">15.4.5.</strong> Traits</a></li><li class="chapter-item "><a href="scope/lifetime/bounds.html"><strong aria-hidden="true">15.4.6.</strong> Bounds</a></li><li class="chapter-item "><a href="scope/lifetime/coercion.html"><strong aria-hidden="true">15.4.7.</strong> Coercion</a></li><li class="chapter-item "><a href="scope/lifetime/static.html"><strong aria-hidden="true">15.4.8.</strong> Static</a></li><li class="chapter-item "><a href="scope/lifetime/elision.html"><strong aria-hidden="true">15.4.9.</strong> Elision</a></li></ol></li></ol></li><li class="chapter-item "><a href="trait/index.html"><strong aria-hidden="true">16.</strong> Traits</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="trait/derive.html"><strong aria-hidden="true">16.1.</strong> Derive</a></li><li class="chapter-item "><a href="trait/dyn.html"><strong aria-hidden="true">16.2.</strong> Returning Traits with dyn</a></li><li class="chapter-item "><a href="trait/ops.html"><strong aria-hidden="true">16.3.</strong> Operator Overloading</a></li><li class="chapter-item "><a href="trait/drop.html"><strong aria-hidden="true">16.4.</strong> Drop</a></li><li class="chapter-item "><a href="trait/iter.html"><strong aria-hidden="true">16.5.</strong> Iterators</a></li><li class="chapter-item "><a href="trait/impl_trait.html"><strong aria-hidden="true">16.6.</strong> impl Trait</a></li><li class="chapter-item "><a href="trait/clone.html"><strong aria-hidden="true">16.7.</strong> Clone</a></li><li class="chapter-item "><a href="trait/supertraits.html"><strong aria-hidden="true">16.8.</strong> Supertraits</a></li><li class="chapter-item "><a href="trait/disambiguating.html"><strong aria-hidden="true">16.9.</strong> Disambiguating overlapping traits</a></li></ol></li><li class="chapter-item "><a href="macros/index.html"><strong aria-hidden="true">17.</strong> macro_rules!</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax/index.html"><strong aria-hidden="true">17.1.</strong> Syntax</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="macros/syntax/designators.html"><strong aria-hidden="true">17.1.1.</strong> Designators</a></li><li class="chapter-item "><a href="macros/syntax/overload.html"><strong aria-hidden="true">17.1.2.</strong> Overload</a></li><li class="chapter-item "><a href="macros/syntax/repeat.html"><strong aria-hidden="true">17.1.3.</strong> Repeat</a></li></ol></li><li class="chapter-item "><a href="macros/dry.html"><strong aria-hidden="true">17.2.</strong> DRY (Don't Repeat Yourself)</a></li><li class="chapter-item "><a href="macros/dsl.html"><strong aria-hidden="true">17.3.</strong> DSL (Domain Specific Languages)</a></li><li class="chapter-item "><a href="macros/variadics.html"><strong aria-hidden="true">17.4.</strong> Variadic Interface</a></li></ol></li><li class="chapter-item "><a href="error/index.html"><strong aria-hidden="true">18.</strong> Error handling</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/panic.html"><strong aria-hidden="true">18.1.</strong> panic</a></li><li class="chapter-item "><a href="error/option_unwrap/index.html"><strong aria-hidden="true">18.2.</strong> Option &amp; unwrap</a></li><li class="chapter-item "><a href="error/option_unwrap/question_mark.html"><strong aria-hidden="true">18.3.</strong> Unpacking options with ?</a></li><li class="chapter-item "><a href="error/option_unwrap/map.html"><strong aria-hidden="true">18.4.</strong> Combinators: map</a></li><li class="chapter-item "><a href="error/option_unwrap/and_then.html"><strong aria-hidden="true">18.5.</strong> Combinators: and_then</a></li><li class="chapter-item "><a href="error/result/index.html"><strong aria-hidden="true">18.6.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/result/result_map.html"><strong aria-hidden="true">18.6.1.</strong> map for Result</a></li><li class="chapter-item "><a href="error/result/result_alias.html"><strong aria-hidden="true">18.6.2.</strong> aliases for Result</a></li><li class="chapter-item "><a href="error/result/early_returns.html"><strong aria-hidden="true">18.6.3.</strong> Early returns</a></li><li class="chapter-item "><a href="error/result/enter_question_mark.html"><strong aria-hidden="true">18.6.4.</strong> Introducing ?</a></li></ol></li><li class="chapter-item "><a href="error/multiple_error_types/index.html"><strong aria-hidden="true">18.7.</strong> Multiple error types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="error/multiple_error_types/option_result.html"><strong aria-hidden="true">18.7.1.</strong> Pulling Results out of Options</a></li><li class="chapter-item "><a href="error/multiple_error_types/define_error_type.html"><strong aria-hidden="true">18.7.2.</strong> Defining an error type</a></li><li class="chapter-item "><a href="error/multiple_error_types/boxing_errors.html"><strong aria-hidden="true">18.7.3.</strong> Boxing errors</a></li><li class="chapter-item "><a href="error/multiple_error_types/reenter_question_mark.html"><strong aria-hidden="true">18.7.4.</strong> Other uses of ?</a></li><li class="chapter-item "><a href="error/multiple_error_types/wrapping_errors.html"><strong aria-hidden="true">18.7.5.</strong> Wrapping errors</a></li></ol></li><li class="chapter-item "><a href="error/iter_result.html"><strong aria-hidden="true">18.8.</strong> Iterating over Results</a></li></ol></li><li class="chapter-item "><a href="std/index.html"><strong aria-hidden="true">19.</strong> Std library types</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/box.html"><strong aria-hidden="true">19.1.</strong> Box, stack, and heap</a></li><li class="chapter-item "><a href="std/vec.html"><strong aria-hidden="true">19.2.</strong> Vectors</a></li><li class="chapter-item "><a href="std/string.html"><strong aria-hidden="true">19.3.</strong> Strings</a></li><li class="chapter-item "><a href="std/option.html"><strong aria-hidden="true">19.4.</strong> Option</a></li><li class="chapter-item "><a href="std/result/index.html"><strong aria-hidden="true">19.5.</strong> Result</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/result/question_mark.html"><strong aria-hidden="true">19.5.1.</strong> ?</a></li></ol></li><li class="chapter-item "><a href="std/panic.html"><strong aria-hidden="true">19.6.</strong> panic!</a></li><li class="chapter-item "><a href="std/hash/index.html"><strong aria-hidden="true">19.7.</strong> HashMap</a><a class="toggle"><div>❱</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/hash/alt_key_types.html"><strong aria-hidden="true">19.7.1.</strong> Alternate/custom key types</a></li><li class="chapter-item "><a href="std/hash/hashset.html"><strong aria-hidden="true">19.7.2.</strong> HashSet</a></li></ol></li><li class="chapter-item "><a href="std/rc.html"><strong aria-hidden="true">19.8.</strong> Rc</a></li><li class="chapter-item "><a href="std/arc.html"><strong aria-hidden="true">19.9.</strong> Arc</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Shubidumdu&#x27;s Rust Book</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="내가-보려고-만든-rust-book"><a class="header" href="#내가-보려고-만든-rust-book">내가 보려고 만든 Rust Book</a></h1>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/index.html">Rust By Example</a>을 보면서 <strong>개인적으로</strong> 개념을 익혀가기 위한 프로젝트입니다.</p>
<p>번역 작업 그 자체에 중점을 둔 것이 아닌, 오직 스스로의 학습을 위한 프로젝트이기 때문에 다소 불친절하게 번역되거나, 작성자가 임의로 내용을 변경할 수 있음을 알려드립니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello, World!</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `//` 혹은 `/* ... */`을 통해 주석을 작성할 수 있습니다.

/*
  이는 컴파일링 단계에서 무시됩니다.
*/

fn main() {
  println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>Rust는 다음 명령을 통해 파일을 바이너리로 컴파일링합니다.</p>
<pre><code class="language-bash">$ rustc &lt;path&gt;
</code></pre>
<p>컴파일 이후, 컴파일된 파일(확장자가 없음)을 실행하여 프로그램을 확인할 수 있습니다.</p>
<pre><code class="language-bash">$ ./hello
Hello World!
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p><code>//</code> 혹은 <code>/* ... */</code>을 통해 코멘트를 작성할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 한줄 주석
/*
  여러 줄 주석
*/
<span class="boring">}
</span></code></pre></pre>
<p>이는 컴파일러에 의해 무시됩니다.</p>
<p>Rust에서는 Expression 한 가운데에 주석이 껴있어도 문제가 없습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018"> fn main() {
    let x = 5 + /* 90 + */ 5;
    println!(&quot;Is `x` 10 or 100? x = {}&quot;, x);
 }
</code></pre></pre>
<p><code>///</code>와 <code>//!</code>는 Doc Comment라고 하며, 이에 대해선 추후에 다루겠습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="formatted-print"><a class="header" href="#formatted-print">Formatted Print</a></h1>
<p><code>std::fmt</code>에 의해 정의된 매크로들에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li><code>format!</code>: String 타입으로 포맷 텍스트를 작성합니다.</li>
<li><code>print!</code> : <code>format!</code>과 동일하되, 콘솔에 이를 출력합니다. (<code>io::stdout</code>)</li>
<li><code>println!</code> : <code>print!</code>와 동일하되, 줄이 변경됩니다.</li>
<li><code>eprint!</code> : <code>format!</code>과 동일하되, standard error로 이를 출력합니다. (<code>io::stderr</code>)</li>
<li><code>eprintln!</code> : <code>eprint!</code>와 동일하되, 줄이 변경됩니다.</li>
</ul>
<p>위의 매크로 모두 같은 방식으로 구문을 분석하며, 컴파일 시점에 포맷이 적합한지 체크됩니다.</p>
<p>여러 개의 인수를 가져와서 사용할 수도 있습니다. 별도로 0, 1과 같이 인덱싱을 하지 않더라도, 인수의 순서대로 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(&quot;{0}, this is {1}. {1}, this is {0}&quot;, &quot;Tom&quot;, &quot;Jack&quot;);
}
</code></pre></pre>
<p>인수에 이름을 붙일 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(
    &quot;{subject} {verb} {object}&quot;,
    object = &quot;the lazy dog&quot;,
    subject = &quot;the quick brown fox&quot;,
    verb = &quot;jumps over&quot;
  );
}
</code></pre></pre>
<p><code>:&lt;trait&gt;</code>를 붙여 특정 형태로 포맷을 적용하여 사용할 수 있습니다.
아래에서는 <code>:b</code>가 사용됐는데, 이는 이진법을 적용하여 변환한다는 뜻입니다.
따라서 아래는 인수 2를 받아 10으로 출력합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(
    &quot;{} of {:b} people know binary, the other half doesn't&quot;,
    1, 2
  );
}
</code></pre></pre>
<p>특정 width에 만족한 상태에서 우측 정렬으로 출력할 수도 있습니다.
아래는 <code>      1</code>으로, 좌측에 5개의 여백이 생깁니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(&quot;{number:&gt;width$}&quot;, number = 1, width = 6);
}
</code></pre></pre>
<p>특정 width를 만족하도록 특정 값으로 padding을 채워넣을 수도 있습니다.
아래는 <code>000001</code>로 출력됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(&quot;{number:&gt;0width$}&quot;, number = 1, width = 6);
}
</code></pre></pre>
<p>std::fmt은 텍스트 표시를 제어하는 여러 트레이트들을 포함하며, 아래 두 가지가 중요한 기본 형태입니다.</p>
<ul>
<li><code>fmt::Debug</code> - <code>{:?}</code> 마커를 사용하며, 디버깅 목적으로 텍스트를 포맷합니다.</li>
<li><code>fmt::Display</code> - <code>{}</code> 마커를 사용하며, 좀더 유연하고 이용자 친화적인 형태로 텍스트를 포맷합니다.</li>
</ul>
<p>위의 예시에서는 <code>fmt::Display</code>를 사용했는데, std 라이브러리는 해당 유형들에 대한 구현을 제공하기 때문입니다.
fmt::Display 트레이트의 실행은 자동으로 <code>ToString</code> trait를 실행시켜 타입을 String으로 변환합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>트페이트를 포매팅하는 <code>std::fmt</code>를 사용하고자 하는 모든 타입들은 <strong>출력 가능해야</strong> 합니다. <code>std</code> 라이브러리에서와 같은 타입들에 대해서만 이 부분이 자동적으로 구현되어 있습니다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
  println!(&quot;{:?} months in a year.&quot;, 12);
  println!(&quot;{1:?} {0:?} is the {actor:?} name.&quot;,
            &quot;Slater&quot;,
            &quot;Christian&quot;,
            actor=&quot;actor's&quot;);
}
</code></pre></pre>
<p>그 외의 다른 타입들은 <strong>반드시</strong> 수동으로 이를 수행해주어야 합니다.</p>
<p><code>fmt::Debug</code> 트레이트는 이 과정을 상당히 직관적으로 만들어줍니다. 모든 타입들이 <code>fmt::Debug</code> 구현을 <code>derive</code> (자동 생성) 할 수 있습니다. 이는 반드시 수동적으로 구현해주어야 하는 <code>fmt::Display</code>에 대해서는 적용되지 않습니다.</p>
<p>아래의 <code>structure</code>는 현재로선 출력에 대해 구현하지 않았기 때문에 <code>fmt::Display</code> 혹은 <code>fmt::Debug</code>로 출력할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct UnPrintable(i32);

fn main() {
  println!(&quot;{:?} would not print!&quot;, Structure(3));
}
</code></pre></pre>
<p><code>derive</code> 어트리뷰트를 사용하면 <code>fmt::Debug</code>로 해당 <code>struct</code>를 출력가능하도록 자동으로 구현할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#[derive(Debug)]
struct DebugPrintable(i32);

fn main() {
  println!(&quot;Now {:?} will printed!&quot;, DebugPrintable(3));
}
</code></pre></pre>
<p>여러 스트럭쳐들을 겹쳐 사용하는 경우에도 가능합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#[derive(Debug)]
struct Structure(i32);

#[derive(Debug)]
struct Deep(Structure);

fn main() {
  println!(&quot;Now {:?} will print!&quot;, Deep(Structure(7)));
}
</code></pre></pre>
<p>위에서 본 것처럼, <code>fmt::Debug</code>는 분명 스트럭처를 인쇄 가능하도록 만들어주긴 하지만 썩 보기 좋은 형태는 아닙니다. 따라서 Rust는 <code>{:#?}</code>을 통해 &quot;이쁘게 출력&quot;하는 기능을 제공합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#[derive(Debug)]
struct Person&lt;'a&gt; {
    name: &amp;'a str,
    age: u8
}

fn main() {
    let name = &quot;Peter&quot;;
    let age = 27;
    let peter = Person { name, age };

    // Pretty print
    println!(&quot;{:#?}&quot;, peter);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="display"><a class="header" href="#display">Display</a></h1>
<p><code>fmt::Debug</code>는 간결하고 깔끔한 것과는 거리가 멉니다. 따라서 일반적으로는 직접 출력의 형태를 커스터마이징 해주는 것이 좋습니다. 이는 <code>fmt::Display</code>를 통해서 직접 구현될 수 있습니다. <code>{}</code> 마커에 대한 출력을 구현하고자 하는 경우, 아래와 같이 작성될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `use`를 통해 `fmt` 모듈을 가져옵니다.
use std::fmt;

// `fmt::Display`가 구현될 스트럭처를 정의합니다.
// 이는 `i32` 타입을 갖는 `Structure` 라는 이름의 튜플입니다.
struct Structure(i32);

// `{}` 마커를 사용하려면, 타입에 대한 
// `fmt::Display` 트레이트가 수동으로 구현되어야 합니다.

impl fmt::Display for Structure {
  // 아래 트레이트를 사용하려면 `fmt` 모듈이 필요합니다.
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    // 첫번째 인자가 되는 `f`는 output stream입니다.
    // 반환 결과는 `fmt::Result`로 작업이 수행되었는지 아닌지를 나타냅니다.
    // `write!` 매크로는 `println!`의 사용과 매우 유사합니다!
    write!(f, &quot;{}&quot;, self.0)
  }
}
<span class="boring">}
</span></code></pre></pre>
<p><code>fmt::Display</code>는 <code>fmt::Debug</code>보다 깔끔한 출력이 가능합니다. 하지만 <code>std</code> 라이브러리와 관련해서 몇가지 문제가 있습니다. 만약 &quot;애매한&quot; 타입들에 대한 출력을 처리하려면 어떻게 해야할까요? 예를 들어, <code>std</code> 라이브러리가 <code>Vec&lt;T&gt;</code>를 통한 단일 스타일로 타입 출력을 전부 처리한다면, 아래 중에 하나의 형태로 출력되는걸까요?</p>
<ul>
<li><code>Vec&lt;path&gt;</code> : <code>/:/etc:/home/username:/bin</code></li>
<li><code>Vec&lt;number&gt;</code> : <code>1,2,3</code></li>
</ul>
<p>결론을 말하자면, 제네릭을 사용해 여러 타입에 대한 출력을 한꺼번에 처리하는 것은 불가능합니다. 모든 타입에 대한 만능 열쇠는 없으며, <code>fmt::Display</code>는 <code>Vec&lt;T&gt;</code> 혹은 다른 제네릭 컨테이너에 대해 구현되지 않습니다. 이러한 케이스에 대해서는 반드시 <code>fmt::Debug</code>만이 쓰여야 합니다.</p>
<p>사실, 제네릭이 아닌 새 컨테이너 타입의 경우에는 <code>fmt::Display</code>를 사용할 수 있기 때문에 문제가 되지 않습니다.</p>
<p><code>i64</code> 타입의 값을 두개 갖는 <code>MinMax</code> 구조에 대한 출력을 구현해봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

// Debug와 Display 간의 출력 형태 차이를
// 확인하기 위해 derive 합니다.
#[derive(Debug)]
struct MinMax(i64, i64);

// MinMax에 대한 Display를 구현합니다.
impl fmt::Display for MinMax {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    write!(f, &quot;({}, {})&quot;, self.0, self.1)
  }
}

fn main() {
  println!(&quot;Debug: {:?}&quot;, MinMax(20, 40));
  println!(&quot;Display: {}&quot;, MinMax(20, 40));
}
</code></pre></pre>
<p>이번엔 필드 이름을 지정할 수 있는 형태의 <code>Point2D</code> 구조에 대한 출력을 구현해봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

#[derive(Debug)]
struct Point2D {
  x: f64,
  y: f64,
}

impl fmt::Display for Point2D {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    write!(f, &quot;x: {}, y: {}&quot;, self.x, self.y)
  }
}

fn main() {
  let point = Point2D { x: 3.14, y: 1.59 };
  println!(&quot;Debug: {:?}&quot;, point);
  // 이렇게도 출력할 수 있음을 상기시키기 위해 사족을 붙여봤습니다.
  println!(&quot;Display: {point}&quot;, point = point);
}
</code></pre></pre>
<p>위에서, <code>fmt::Display</code>는 구현되었으나 <code>fmt::Binary</code>는 구현되지 않았기 때문에 사용할 수 없습니다. <code>std::fmt</code>는 이러한 유형의 많은 <a href="https://doc.rust-lang.org/stable/rust-by-example/trait.html">트레이트들</a>을 가지고 있으며, 각각의 트레이트들이 자기 자신에 대한 구현을 요구합니다. 자세한 사항에 대해서는 <a href="https://doc.rust-lang.org/std/fmt/">여기</a>를 살펴봅시다.</p>
<p>추가적으로, 아래는 복소수 구조를 만들고, 이에 대한 출력을 처리한 내용입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

#[derive(Debug)]
struct Complex {
    real: f64,
    imag: f64,
}

impl fmt::Display for Complex {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    write!(f, &quot;{} + {}i&quot;, self.real, self.imag)
  }
}

fn main() {
  let complex = Complex { real: 3.3, imag: 7.2 };

  println!(&quot;Display: {}&quot;, complex);
  println!(&quot;Debug: {:?}&quot;, complex);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-list"><a class="header" href="#testcase-list">Testcase: List</a></h1>
<p>각각의 요소들이 다루어져야 하는 구조에 있어서 <code>fmt::Display</code>를 구현하는 것은 까다롭습니다. <code>write!</code> 매크로는 기본적으로 <code>fmt::Result</code>를 만들어내기 때문에, 모든 결과들을 한번에 처리하여 반환해야 한다는 문제가 있습니다. Rust는 이런 경우를 위해 <code>?</code> 연산자를 제공합니다.</p>
<p>아래와 같은 형태로 <code>?</code> 연산자를 사용할 수 있습니다. 아래의 코드는 <code>write!</code>를 시도하고, 에러가 발생한다면 에러를 반환하고, 그렇지 않다면 계속 진행한다는 것을 의미합니다.</p>
<pre><code class="language-rust ignore">write!(f, &quot;{}&quot;, value)?;
</code></pre>
<p>이것을 사용하면, <code>Vec</code> 구조에 대한 <code>fmt::Display</code>도 직관적으로 구현할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

// Vec를 갖는 List란 이름의 구조를 정의
struct List(Vec&lt;i32&gt;);

impl fmt::Display for List {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    // 튜플 인덱싱을 통해 값을 가져옵니다.
    // 이후 `vec`이라는 이름으로 참조를 만듭니다.
    let vec = &amp;self.0;

    write!(f, &quot;[&quot;)?;

    // `vec` 의 요소들에 대해 인덱스(`index`)와 값(`v`)을 순회합니다.
    for (index, v) in vec.iter().enumerate() {
      // 첫번째 요소가 아닌 경우(`index != 0`) `,`를 제외합니다.
      // `?` 연산자를 통해 계속 진행합니다.
      if index != 0 { write!(f, &quot;, &quot;)?; }
      write!(f, &quot;{}&quot;, v)?;
    }

    // 열려있던 괄호를 닫고 `fmt::Result` 값을 반환합니다.
    write!(f, &quot;]&quot;)
  }
}

fn main() {
  let v = List(vec![1, 2, 3]);
  println!(&quot;{}&quot;, v);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="formatting"><a class="header" href="#formatting">Formatting</a></h1>
<p>앞서 포맷팅이 <strong>포맷 스트링</strong>을 통해서 형태가 정해짐을 확인할 수 있었습니다.</p>
<ul>
<li><code>format!(&quot;{}&quot;, foo)</code> -&gt; <code>&quot;3735928559&quot;</code></li>
<li><code>format!(&quot;0x{:X}&quot;, foo)</code> -&gt; <code>&quot;0xDEADBEEF&quot;</code></li>
<li><code>format!(&quot;0o{:o}&quot;, foo)</code> -&gt; &quot;0o33653337357&quot;</li>
</ul>
<p>동일한 값인 <code>foo</code>에 대해서도 어떤 매개변수 타입이 사용되느냐에 따라 다르게 포맷팅됩니다.</p>
<p>이러한 포맷팅 기능은 트레이트를 통해서 구현될 수 있으며, 각각의 매개변수 타입에 대해 하나의 트레이트가 사용됩니다.. 가장 일반적인 포맷팅 프레이트는 <code>Display</code>로, 이는 매개변수 타입이 구체화되지 않은 경우에 다루어집니다. (<code>{}</code>)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt::{self, Formatter, Display};

struct City {
  name: &amp;'static str,
  lat: f32,
  lon: f32,
}

impl Display for City {
  // `f`는 버퍼로, `fmt` 메서드는 여기에 포맷 스트링을 작성해주어야 합니다.
  fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
    let lat_c = if self.lat &gt;= 0.0 { 'N' } else { 'S' };
    let lon_c = if self.lon &gt;= 0.0 { 'E' } else { 'W' };

      // `write!`는 `format!`과 유사하지만
      // 포맷스트링을 `f` 버퍼에 작성합니다.
      //
      // 아래의 `:.3`은 소수 3번째 자리까지 반올림을 수행합니다.
      write!(f, &quot;{}: {:.3}°{} {:.3}°{}&quot;,
        self.name, 
        self.lat.abs(), 
        lat_c, 
        self.lon.abs(), 
        lon_c)
  }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

// RGB 형태의 `Color` 구조에 Hex출력을 추가해보겠습니다.
impl Display for Color {
    fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {
        // `{:02X}`의 경우,
        // `:02`는 width(`2`) 만큼 0을 padding으로 넣습니다.
        // `:X`는 Upper Hex(16진수)로 변환시킵니다.
        write!(f, &quot;RGB ({0}, {1}, {2}) 0x{0:02X}{1:02X}{2:02X}&quot;, 
            self.red, 
            self.green, 
            self.blue)
    }
}

fn main() {
    for city in [
        City { name: &quot;Dublin&quot;, lat: 53.347778, lon: -6.259722 },
        City { name: &quot;Oslo&quot;, lat: 59.95, lon: 10.75 },
        City { name: &quot;Vancouver&quot;, lat: 49.25, lon: -123.1 },
    ].iter() {
        println!(&quot;{}&quot;, *city);
    }
    for color in [
        Color { red: 128, green: 255, blue: 90 },
        Color { red: 0, green: 3, blue: 254 },
        Color { red: 0, green: 0, blue: 0 },
    ].iter() {
        println!(&quot;{}&quot;, *color);
    }
}
</code></pre></pre>
<p>원하는 형태로 포매팅을 하기 위한 매개변수의 종류들에 대해서는 <a href="https://doc.rust-lang.org/std/fmt/">여기</a>에서 자세히 찾아볼 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="primitives"><a class="header" href="#primitives">Primitives</a></h1>
<p>Rust는 다양한 형태의 <code>primitives</code>를 제공합니다.</p>
<h3 id="스칼라-타입-scalar-types"><a class="header" href="#스칼라-타입-scalar-types">스칼라 타입 (Scalar Types)</a></h3>
<ul>
<li>signed integers : <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code> (포인터 사이즈)</li>
<li>unsigned integers : <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code> (포인터 사이즈)</li>
<li>floating point : <code>f32</code>, <code>f64</code></li>
<li><code>char</code> : 유니코드 스칼라값, 각각 4byte (<code>a</code>, <code>α</code>, <code>∞</code> 등)</li>
<li><code>bool</code> : <code>true</code> 혹은 <code>false</code></li>
<li><code>()</code> : 유닛타입. 빈 튜플.</li>
</ul>
<p><code>()</code>은 튜플임에도 불구하고, 아무 값도 포함하지 않기 때문에 컴파운드(복합) 타입으로 고려되지 않습니다.</p>
<h3 id="컴파운드-타입-compound-types"><a class="header" href="#컴파운드-타입-compound-types">컴파운드 타입 (Compound Types)</a></h3>
<ul>
<li>arrays : <code>[1, 2, 3]</code></li>
<li>tuples : <code>(1, true)</code></li>
</ul>
<p>변수들은 항상 타입이 지정됩니다. 숫자 타입들은 <em>suffix</em>를 통해 직접 타입을 지정하거나, 기본적으로 지정됩니다. (<code>int</code>는 <code>i32</code>로, <code>float</code>는 <code>f64</code>로) 또한 Rust는 컨텍스트를 통해 타입을 추측하기도 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 변수는 타입이 지정될 수 있습니다.
    let logical: bool = true;

    // 일반적인 타입 지정
    let a_float: f64 = 1.0;
    // suffix 타입 지정 -&gt; `i32` 타입의 `5`
    let an_integer   = 5i32; // Suffix annotation

    // 기본 타입 지정
    let default_float   = 3.0; // `f64`
    let default_integer = 7;   // `i32`
    
    // Context에 따라 타입이 지정될 수도 있습니다. 
    let mut inferred_type = 12; 
    // 아래에서의 i64로 타입이 지정됩니다.
    inferred_type = 4294967296i64;
    
    // `mut`을 통해 `mutable`로 지정한 변수는 변경될 수 있습니다.
    let mut mutable = 12; // Mutable `i32`
    mutable = 21;
    
    // 단, 타입을 유지해야 합니다.
    // 아래는 에러가 출력됩니다.
    mutable = true;
    
    // 섀도잉(shadowing)을 통해 덮어쓸수도 있습니다.
    let mutable = true;
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="literals-and-operators"><a class="header" href="#literals-and-operators">Literals and operators</a></h1>
<p>앞서 말한 스칼라 타입의 값에 해당하는 값들은 리터럴(literal)을 통해 표현할 수 있습니다.</p>
<p>정수는 16진수(<code>0x</code>), 8진수(<code>0o</code>), 2진수(<code>0b</code>)로 표현될 수 있습니다.</p>
<p>밑줄(<code>_</code>)은 숫자 리터럴에 있어 가독성을 향상시켜주기 위해 사용합니다. (ex. <code>1_000 == 1000</code>, <code>0.000_001 == 0.000001</code>)</p>
<p>리터럴을 사용하려면 컴파일러에게 어떤 타입의 리터럴을 사용하는지에 대해 알려주어야 합니다. 지금부터는 unsigned 32-bit integer를 나타내기 위해 <code>u32</code> suffix를 사용하겠습니다.</p>
<p>Rust에서 사용할 수 있는 연산자와 이들 간의 우선순위는 다른 C형 언어들과 유사합니다. (<a href="https://doc.rust-lang.org/reference/expressions.html#expression-precedence">참조</a>)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 정수 덧셈
    println!(&quot;1 + 2 = {}&quot;, 1u32 + 2);

    // 정수 뺄셈
    println!(&quot;1 - 2 = {}&quot;, 1i32 - 2);

    // Boolean 로직에 대한 Short-circuiting 
    println!(&quot;true AND false is {}&quot;, true &amp;&amp; false);
    println!(&quot;true OR false is {}&quot;, true || false);
    println!(&quot;NOT true is {}&quot;, !true);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);

    // 가독성 향상을 위해 밑줄을 사용
    println!(&quot;One million is written as {}&quot;, 1_000_000u32);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>튜플은 여러 값들의 컬렉션입니다. 튜플은 <code>()</code> 괄호를 통해 생성되며, 튜플의 각 값들은 타입 시그니처의 값(<code>(T1, T2, ...)</code>)입니다. 튜플은 여러 값들을 보유할 수 있기 때문에, 함수에서 여러 값들을 반환하기 위해 튜플을 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

// 튜플은 함수의 인수 혹은 반환값으로 사용될 수 있습니다.
// 아래는 두 타입의 값으로 구성된 튜플의 index를 서로 바꾸는 함수입니다.
fn reverse(pair: (i32, bool)) -&gt; (bool, i32) {
  // `let`은 튜플의 각 구성원을 변수에 바인딩하는데 사용할 수 있습니다.
  let (integer, boolean) = pair;
  (boolean, integer)
}

#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

// 이전에 배웠던 fmt::Display 포맷을 Matrix 구조에 구현해봅시다.
impl fmt::Display for Matrix {
  fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
    write!(f, &quot;( {} {} )\n&quot;, &amp;self.0, &amp;self.1)?;
    write!(f, &quot;( {} {} )&quot;, &amp;self.2, &amp;self.3)
  }
}

//
fn transpose(matrix: Matrix) -&gt; (matrix) {
  let (first, second, third, fourth) = matrix;
  (first, third, second, fourth)
}

fn main() {
  // 여러 타입의 값들을 담고 있는 튜플
  let long_tuple = (1u8, 2u16, 3u32, 4u64,
                    -1i8, -2i16, -3i32, -4i64,
                    0.1f32, 0.2f64,
                    'a', true);

  // 튜플의 각 값은 인덱싱을 통해 추출될 수 있습니다.
  println!(&quot;long tuple first value: {}&quot;, long_tuple.0);
  println!(&quot;long tuple second value: {}&quot;, long_tuple.1);

  // 튜플 역시도 다른 튜플의 값이 될 수 있습니다.
  let tuple_of_tuples = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);

  // 튜플은 출력 가능(printable)합니다.
  println!(&quot;tuple of tuples: {:?}&quot;, tuple_of_tuples);
  
  // 허나 너무 긴 튜플은 출력할 수 없습니다.
  // 아래 코드는 컴파일 에러를 발생시킵니다.
  let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
  println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);

  let pair = (1, true);
  println!(&quot;pair is {:?}&quot;, pair);
  println!(&quot;the reversed pair is {:?}&quot;, reverse(pair));

  // 하나의 요소만 갖는 튜플의 경우 `,`이 요구됩니다.
  println!(&quot;one element tuple: {:?}&quot;, (5u32,));
  println!(&quot;just an integer: {:?}&quot;, (5u32));

  // 튜플은 바인딩 생성을 위해 쪼개질 수 있습니다.
  let tuple = (1, &quot;hello&quot;, 4.5, true);

  let (a, b, c, d) = tuple;
  println!(&quot;{:?}, {:?}, {:?}, {:?}&quot;, a, b, c, d);

  // 
  let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
  println!(&quot;Matrix:\n{}&quot;, matrix);
  println!(&quot;Transpose:\n{}&quot;, transpose(matrix));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="arrays-and-slices"><a class="header" href="#arrays-and-slices">Arrays and Slices</a></h1>
<p>Array는 동일한 타입의 값들이 모인 컬렉션입니다. 메모리에 연속적으로 저장됩니다. Array는 <code>[]</code> 괄호를 통해 생성되며, 그 길이는 <code>[T; length]</code>와 같은 형태로 작성하여 컴파일링 시점에 알려주어야 합니다.</p>
<p>Slices는 Array와 유사하지만, 컴파일링 차원에서 그 길이를 파악하지 않습니다. 대신, 슬라이스는 two-word 객체로, 첫번째는 데이터의 포인터를 가리키고, 두번째는 슬라이스의 길이를 나타냅니다. word의 크기는 x86-64의 프로세서 아키텍처(ex. 64bit)에 의해 결정되는 usize와 동일합니다. Slice는 한 Array의 일부를 가져오기 위해 <code>&amp;[T]</code> 형식 선언으로 사용합니다.</p>
<pre><code class="language-rs editable">use std::mem;

// 아래 함수는 Array로부터 Slice를 가져옵니다.
fn analyze_slice(slice: &amp;[i32]) {
  println!(&quot;first element of the slice: {}&quot;, slice[0]);
  println!(&quot;the slice has {} elements&quot;, slice.len());
}

fn main() {
  // 고정 사이즈 Array
  // 별도로 타입 선언이 없어도 됩니다.
  let xs: [i32; 5] = [1, 2, 3, 4, 5];

  // 모든 요소가 동일한 값(여기서는 `0`)으로 초기화할 수 있습니다.
  let ys: [i32; 500] = [0; 500];

  // 인덱싱은 `0`에서 시작합니다.
  println!(&quot;first element of the array: {}&quot;, xs[0]);
  println!(&quot;second element of the array: {}&quot;, xs[1]);

  // `len`은 Array의 요소 갯수를 반환합니다.
  println!(&quot;number of elements in array: {}&quot;, xs.len());

  // Array는 스택에 할당됩니다.
  println!(&quot;array occupies {} bytes&quot;, mem::size_of_val(&amp;xs));

  // 기본적으로 모든 Array는
  // Slice로 제공될 수 있습니다.
  println!(&quot;borrow the whole array as a slice&quot;);
  analyze_slice(&amp;xs);

  // Slice는 한 Array의 일부를 가리킬 수 있습니다.
  // [start_index .. end_index] 형태로 작성합니다.
  // start_index는 슬라이스가 시작될 지점이고,
  // end_index는 (슬라이스가 끝나는 지점 + 1)에 해당합니다.
  println!(&quot;borrow a section of the array as a slice&quot;);
  analyze_slice(&amp;ys[1 .. 4]);

  // Array의 길이를 벗어나서 인덱싱을 하게되면 컴파일 에러가 발생합니다.
  println!(&quot;{}&quot;, xs[5]);
}
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h1>
<p>Rust의 커스텀 데이터 타입은 다음의 두 키워드로 주로 구성됩니다.</p>
<ul>
<li><code>struct</code> : 스트럭처를 정의합니다.</li>
<li><code>enum</code> : 순회를 정의합니다.</li>
</ul>
<p>상수(Constants)들은 <code>const</code>와 <code>static</code> 키워드를 통해 생성될 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="structures"><a class="header" href="#structures">Structures</a></h1>
<p><code>struct</code> 키워드를 통해 만들 수 있는 세가지 타입의 스트럭처가 있습니다.</p>
<ul>
<li>튜플, 기본적이고, 이름이 존재하는 튜플(named tuples)</li>
<li>클래식 C 스트럭처 </li>
<li>유닛 스트럭처, 필드가 없어 제네릭에 유용함</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">#[derive(Debug)]
struct Person {
    name: String,
    age: u8,
}

// 유닛 스트럭처
struct Unit;

// 튜플 스트럭처
struct Pair(i32, f32);

// 두 개의 필드를 갖는 스트럭처 (클래식 C 스트럭처)
#[derive(Debug)]
struct Point {
    x: f32,
    y: f32,
}

// 스트럭처는 다른 스트럭처의 필드로 쓰일 수 있습니다.
#[derive(Debug)]
struct Rectangle {
// 사각형은 좌상단과 우하단의 좌표만 있으면 구성할 수 있습니다.
    top_left: Point,
    bottom_right: Point,
}

// 사각형의 넓이를 구하는 함수를 구현해봅시다.
fn rect_area(rect: Rectangle) -&gt; f32 {
    let Rectangle { 
        top_left : Point {
            x: x1,
            y: y1,
        }, 
        bottom_right : Point {
            x: x2,
            y: y2,
        }
    } = rect;
    (x2 - x1).abs() * (y2 - y1).abs()
}

// 우측 하단의 점과 길이를 받아 
// Rectangle 스트럭처를 생성하는 함수
fn square(bottom_left: Point, length: f32) -&gt; Rectangle {
    Rectangle {
        top_left : Point {
            x: bottom_left.x,
            y: bottom_left.y - length,
        },
        bottom_right : Point {
            x: bottom_left.x + length,
            y: bottom_left.y
        }
    }
}

fn main() {
    // 짧은 형태로 struct를 만들 수 있습니다.
    let name = String::from(&quot;Peter&quot;);
    let age = 27;
    let peter = Person { name, age };

    // 스트럭처에 대한 디버그 출력을 합니다.
    println!(&quot;{:?}&quot;, peter);


    // Point 기반의 인스턴스를 생성합니다.
    let point: Point = Point { x: 10.3, y: 0.4 };

    // 포인트 인스턴스의 각 필드는 `.field` 형태로 접근할 수 있습니다.
    println!(&quot;point coordinates: ({}, {})&quot;, point.x, point.y);

    // 기존 인스턴스의 필드값을 기반으로 새 인스턴스를 만들 수 있습니다.
    let bottom_right = Point { x: 5.2, ..point };

    // bottom_right.y는 point.y와 동일합니다.
    println!(&quot;second point: ({}, {})&quot;, bottom_right.x, bottom_right.y);

    // `let` 바인딩을 통해 포인트의 구조를 분해할 수 있습니다.
    let Point { x: top_edge, y: left_edge } = point;

    // struct를 기반으로 인스턴스를 만드는 것 역시 Expression 입니다.
    let _rectangle = Rectangle {
        top_left: Point { x: left_edge, y: top_edge },
        bottom_right: bottom_right,
    };

    // 사전에 구현했던 함수를 통해 사각형 넓이를 구합니다.
    println!(&quot;rectangle's area : {}&quot;, rect_area(_rectangle));

    // 사전에 구현했던 함수를 통해 새로운 사각형을 만듭니다.
    println!(&quot;new Rectangle with square(...) : {:?}&quot;, 
        square(Point { x : 3.0, y: 3.0}, 2.0));

    // 유닛 스트럭처의 인스턴스를 생성합니다.
    let _unit = Unit;

    // 튜플 스트럭처의 인스턴스를 생성합니다.
    let pair = Pair(1, 0.1);

    // 튜플 구조의 필드들에 접근합니다.
    println!(&quot;pair contains {:?} and {:?}&quot;, pair.0, pair.1);

    // 튜플 구조도 `let` 바인딩으로 분해될 수 있습니다.
    let Pair(integer, decimal) = pair;
    println!(&quot;pair contains {:?} and {:?}&quot;, integer, decimal);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="enums"><a class="header" href="#enums">Enums</a></h1>
<p><code>enum</code> 키워드는 여러 형태 중 하나일 수 있는 타입을 생성하도록 해줍니다. <code>struct</code>로서 유효한 변형 형태라면 <code>enum</code>에서도 유효합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 웹 이벤트를 분류하는 `enum`을 만듭니다.
// 이벤트 이름과 타입 정보가 변형 형태를 명시합니다.
// 각각의 변형은 구분되며, 독립적입니다.
enum WebEvent {
    // enum은 `unit` 형태의 구조 일수도 있고,
    PageLoad,
    PageUnload,
    // 튜플 구조일 수도 있으며,
    KeyPress(char),
    Paste(String),
    // c-like 구조일 수도 있습니다.
    Click { x: i64, y: i64 },
}

// 아래 함수는 `WebEvent` enum을 받은 뒤 아무 것도 반환하지 않습니다.
fn inspect(event: WebEvent) {
    // `match`는 C의 `switch`와 유사합니다.
    match event {
        WebEvent::PageLoad =&gt; println!(&quot;page loaded&quot;),
        WebEvent::PageUnload =&gt; println!(&quot;page unloaded&quot;),
        WebEvent::KeyPress(c) =&gt; println!(&quot;pressed '{}'.&quot;, c),
        WebEvent::Paste(s) =&gt; println!(&quot;pasted \&quot;{}\&quot;.&quot;, s),
        WebEvent::Click { x, y } =&gt; {
            println!(&quot;clicked at x={}, y={}.&quot;, x, y);
        },
    }
}

fn main() {
    let pressed = WebEvent::KeyPress('x');
    // `to_owned()` 메서드는 스트링 슬라이스에서
    // 스스로의 `String`을 생성해냅니다.
    let pasted  = WebEvent::Paste(&quot;my text&quot;.to_owned());
    let click   = WebEvent::Click { x: 20, y: 80 };
    let load    = WebEvent::PageLoad;
    let unload  = WebEvent::PageUnload;

    inspect(pressed);
    inspect(pasted);
    inspect(click);
    inspect(load);
    inspect(unload);
}
</code></pre></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h2>
<p>Type aliases(타입 별칭)을 사용한다면, 각각의 enum을 별칭으로 다룰 수 있습니다. enum의 이름이 너무 길거나, 너무 일반적이라서 새로 이름을 짓고자 할때 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

// Type alias를 생성합니다.
type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;

fn main() {
    // 각 변형을 alias를 통해 참조할 수 있습니다.
    let x = Operations::Add;
}
</code></pre></pre>
<p>가장 일반적으로 이를 많이 사용하게 되는 경우는 <code>impl</code> 블록에서 <code>Self</code> 별칭을 사용하는 경우입니다.</p>
<pre><code class="language-rs editable">enum VeryVerboseEnumOfThingsToDoWithNumbers {
    Add,
    Subtract,
}

impl VeryVerboseEnumOfThingsToDoWithNumbers {
    fn run(&amp;self, x: i32, y: i32) -&gt; i32 {
        match self {
            Self::Add =&gt; x + y,
            Self::Subtract =&gt; x - y,
        }
    }
}
</code></pre>
<p>enum과 Type Alias에 대해 더 많이 살펴보려면, <a href="https://github.com/rust-lang/rust/pull/61682/#issuecomment-502472847">여기</a>를 읽어보세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="use"><a class="header" href="#use">use</a></h1>
<p><code>use</code> 선언은 일일이 수동으로 스코핑을 하지 않고자 할 때 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 사용하지 않는 코드에 대한 경고를 숨깁니다.
#![allow(dead_code)]

enum Status {
    Rich,
    Poor,
}

enum Work {
    Civilian,
    Soldier,
}

fn main() {
    // `use`를 사용하면 수동 스코핑 없이 
    // enum의 각 변형에 접근할 수 있습니다.
    use crate::Status::{Poor, Rich};
    // `Work` 내의 모든 변형을 사용합니다.
    use crate::Work::*;

    // 아래는 `Status::Poor`과 동일합니다.
    let status = Poor;
    // 아래는 `Work::Civilian`과 동일합니다.
    let work = Civilian;

    // 과도한 `use`의 사용으로 인해
    // 스코프 내에서 충돌이 일어날 수 있다는 점에 주의합시다.
    match status {
        Rich =&gt; println!(&quot;The rich have lots of money!&quot;),
        Poor =&gt; println!(&quot;The poor have no money...&quot;),
    }

    match work {
        Civilian =&gt; println!(&quot;Civilians work!&quot;),
        Soldier  =&gt; println!(&quot;Soldiers fight!&quot;),
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="c-like"><a class="header" href="#c-like">C-like</a></h1>
<p><code>enum</code>은 C 에서의 enum과 유사하게 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 사용하지 않은 코드에 대한 경고를 숨깁니다.
#![allow(dead_code)]

// implicit discriminator를 활용한 enum (0부터 시작)
enum Number {
    Zero,
    One,
    Two,
}

// explicit discriminator를 활용한 enum
enum Color {
    Red = 0xff0000,
    Green = 0x00ff00,
    Blue = 0x0000ff,
}

fn main() {
    // 정수로 변환될 수 있습니다.
    println!(&quot;zero is {}&quot;, Number::Zero as i32);
    println!(&quot;one is {}&quot;, Number::One as i32);

    println!(&quot;roses are #{:06x}&quot;, Color::Red as i32);
    println!(&quot;violets are #{:06x}&quot;, Color::Blue as i32);
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-linked-list"><a class="header" href="#testcase-linked-list">Testcase: linked-list</a></h1>
<p><code>enums</code>의 일반적인 용도는 링크드 리스트(linked-list)를 만드는 것입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use crate::List::*;

enum List {
    // Cons : (요소, 다음 노드에 대한 포인터)
    Cons(u32, Box&lt;List&gt;),
    // Nil : 링크드 리스트의 끝을 나타내는 노드
    Nil,
}

// 메서드를 enum에 연결할 수 있습니다.
impl List {
    // 빈 리스트 생성
    fn new() -&gt; List {
        // `Nil` 은 리스트 타입을 보유합니다..
        Nil
    }

    // 새로운 값이 추가된 동일한 리스트를 반환합니다.
    fn prepend(self, elem: u32) -&gt; List {
        // `Cons`도 리스트 타입을 보유합니다.
        Cons(elem, Box::new(self))
    }

    // 리스트의 길이를 반환합니다.
    // 아래 메서드는는 `self`의 
    // 변형 형태에 따라 달라지기 때문에
    // `self`에 대해 match를 수행해야 합니다.
    fn len(&amp;self) -&gt; u32 {
        // `self`는 `&amp;List` 타입을 갖고,
        // `*self`는 `List` 타입을 갖습니다.
        // 콘크리트 타입 `T`에 대한 매치가 
        // 참조 `&amp;T`의 매치보다 선호됩니다.
        match *self {
            // `self`는 빌려온(borrow) 것이기에, 
            // `tail`을 소유할 수 없습니다.
            // 대신에 `tail`에 대한 참조를 가져옵니다.
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // 빈 리스트는 길이가 0입니다.
            Nil =&gt; 0
        }
    }

    // 리스트의 표현을 (Heap 할당) 문자열로 반환합니다.
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, ref tail) =&gt; {
                // `format!`은 `print!`와 유사하지만, 
                // 콘솔 출력 대신 heap 할당 문자열을 반환합니다.
                format!(&quot;{}, {}&quot;, head, tail.stringify())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // 빈 링크드 리스트를 만듭니다.
    let mut list = List::new();

    // 몇몇 요소들을 추가합니다.
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // 리스트의 상태를 출력합니다.
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">constants</a></h1>
<p>Rust는 두 가지 타입의 상수(constants)를 갖고 있습니다. 상수는 글로벌 스코프를 포함하여 어디에서는 선언될 수 있으며, 두 타입 모두 명시적으로 타입을 지정할 수 있습니다.</p>
<ul>
<li><code>const</code> : 바뀌지 않는 값 (일반적으로는 이를 사용합니다.)</li>
<li><code>static</code> : <code>'static</code> 라이프타임을 가진, 필요에 따라 mutable로 지정할 수 있는 변수입니다. static 라이프타임은 유추될 수 있기 때문에 직접 지정할 필요는 없습니다. 해당 값에 접근하거나 수정하는 것은 안전하지 않은 것으로 간주됩니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 글로벌 변수들을 선언, 할당합니다.
static LANGUAGE: &amp;str = &quot;Rust&quot;;
const THRESHOLD: i32 = 10;

fn is_big(n: i32) -&gt; bool {
    // THRESHOLD는 글로벌 변수이므로 해당 함수에서 접근 가능합니다.
    n &gt; THRESHOLD
}

fn main() {
    let n = 16;

    // 메인 쓰레드에서 상수에 접근합니다. 
    println!(&quot;This is {}&quot;, LANGUAGE);
    println!(&quot;The threshold is {}&quot;, THRESHOLD);
    println!(&quot;{} is {}&quot;, n, if is_big(n) { &quot;big&quot; } else { &quot;small&quot; });

    // ERROR! : `const`로 지정한 변수는 변경할 수 없습니다.
    THRESHOLD = 5;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variable-bindings"><a class="header" href="#variable-bindings">Variable Bindings</a></h1>
<p>Rust는 정적 타이핑을 통해 안정성을 보장합니다. 변수 바인딩은 선언 시에 타입이 지정될 수 있습니다. 그러나, 대부분의 경우 컴파일러는 컨텍스트를 통해 변수의 타입을 추측할 수 있으므로, 일일이 정적 타이핑을 해주는 것에 대한 부담이 줄어듭니다.</p>
<p>리터럴 등을 통해 생성해내는 값들은 변수에 바인딩될 수 있으며, 이 때는 <code>let</code> 바인딩을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let an_integer = 1u32;
    let a_boolean = true;
    let unit = ();

    // an_integer를 copied_integer에 복사합니다.
    let copied_integer = an_integer;

    println!(&quot;An integer: {:?}&quot;, copied_integer);
    println!(&quot;A boolean: {:?}&quot;, a_boolean);
    println!(&quot;Meet the unit value: {:?}&quot;, unit);

    // 컴파일러는 사용되지 않은 변수에 대해서는 경고합니다.
    // 이 경우, 변수명 앞에 `_`를 붙여 막을 수 있습니다.
    let _unused_variable = 3u32;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability"><a class="header" href="#mutability">Mutability</a></h1>
<p>변수 바인딩은 기본적으로 immutable 합니다. 그러나, <code>mut</code> 수식어를 덧붙여 오버라이딩이 가능하도록 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let _immutable_binding = 1;
    let mut mutable_binding = 1;

    println!(&quot;Before mutation: {}&quot;, mutable_binding);

    // `mut`을 덧붙였기에 값을 변경할 수 있습니다.
    mutable_binding += 1;

    println!(&quot;After mutation: {}&quot;, mutable_binding);

    // 기본적으로 바인딩은 immutable 합니다.
    // 따라서 아래는 에러가 발생합니다.
    _immutable_binding += 1;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scope-and-shadowing"><a class="header" href="#scope-and-shadowing">Scope and Shadowing</a></h1>
<p>변수 바인딩은 스코프를 가지며, 하나의 블록 영역 내에서만 사용됩니다. 블록은 <code>{}</code> 괄호로 둘러싸인 statement의 컬렉션입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 아래 바인딩은 `main` 함수에 종속됩니다.
    let long_lived_binding = 1;

    // 블록을 통해 직접 스코프를 만들 수 있습니다.
    {
        // 따라서 아래 바인딩은 해당 스코프에서만 유효합니다.
        let short_lived_binding = 2;

        println!(&quot;inner short: {}&quot;, short_lived_binding);
    }

    // 위의 블록 내에서 선언한 바인딩은 바깥에서는 유효하지 않습니다.
    // 따라서 아래의 코드는 에러가 발생합니다.
    println!(&quot;outer short: {}&quot;, short_lived_binding);

    // 아래는 유효한 범위 내에 있으므로 정상적으로 출력됩니다.
    println!(&quot;outer long: {}&quot;, long_lived_binding);
}
</code></pre></pre>
<p>Variable Shadowing도 가능합니다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let shadowed_binding = 1;

    {
        println!(&quot;before being shadowed: {}&quot;, shadowed_binding);

        // 바깥의 바인딩을 Shadowing합니다.
        let shadowed_binding = &quot;abc&quot;;

        println!(&quot;shadowed in inner block: {}&quot;, shadowed_binding);
    }
    println!(&quot;outside inner block: {}&quot;, shadowed_binding);

    // 최상단의 바인딩에 대해 Shadowing합니다.
    let shadowed_binding = 2;
    println!(&quot;shadowed in outer block: {}&quot;, shadowed_binding);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="declare-first"><a class="header" href="#declare-first">Declare first</a></h1>
<p>변수 바인딩을 먼저 선언만 하고, 추후에 초기화(할당)하는 것도 가능합니다. 허나, 이러한 방식은 초기화되지 않은 변수를 의도치않게 사용할 수도 있기 떄문에 거의 활용되지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 변수 바인딩을 선언'만' 합니다.
    let a_binding;

    {
        let x = 2;

        // 이후 초기화합니다.
        a_binding = x * x;
    }

    println!(&quot;a binding: {}&quot;, a_binding);

    let another_binding;

    // ERROR : 초기화되지 않은 바인딩을 사용했습니다.
    println!(&quot;another binding: {}&quot;, another_binding);

    another_binding = 1;

    println!(&quot;another binding: {}&quot;, another_binding);
}
</code></pre></pre>
<p>의도치 않은 동작을 방지하기 위해, 컴파일러 자체적으로도 초기화되지 않은 변수들에 대한 사용을 막고 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="freezing"><a class="header" href="#freezing">Freezing</a></h1>
<p>기존의 mutable 데이터가 동일한 이름을 가진 immutable 변수에 바인딩되면, 데이터를 얼릴(Freeze) 수 있습니다. 얼린 데이터는 해당 변수 바인딩이 적용된 스코프를 벗어날 때까지 유지되어, 수정할 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `_mutable_integer`는 최초에 mutable 합니다.
    let mut _mutable_integer = 7i32;

    {
        // 동일한 변수에 대한 바인딩으로 
        // 이를 immutable하게 만듭니다.
        let _mutable_integer = _mutable_integer;

        // ERROR : 이제 현재 스코프에서는 아래 바인딩을 수정할 수 없습니다.
        _mutable_integer = 50;
    }

    // Freezing을 적용한 스코프를 벗어나게 되면,
    // 다시 해당 바인딩은 mutable 합니다.
    _mutable_integer = 3;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="types"><a class="header" href="#types">Types</a></h1>
<p>Rust는 원시(primitive) 타입과 유저 정의 타입을 변경하거나 정의하기 위한 여러가지 매커니즘을 제공합니다.</p>
<ul>
<li>원시 타입 간의 캐스팅(Casting)</li>
<li>원하는 리터럴 타입의 지정</li>
<li>타입 추론 사용</li>
<li>타입 별칭</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="casting"><a class="header" href="#casting">Casting</a></h1>
<p>Rust는 원시 타입 간의 암묵적인 타입 변환을 제공하지 않습니다. 허나 <code>as</code> 키워드를 통한 명시적 타입 변환을 적용할 수 있습니다.</p>
<p>유형 간의 변환 규칙은 일반적으로 C에 정의되지 않은 동작이 있는 경우를 제외하고는 C에서의 규칙을 따릅니다. 타입 간의 모든 변환 동작에 대해서는 Rust 내에 잘 정의되어 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 오버플로되는 캐스트에 대한 경고를 표시하지 않게끔 합니다.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // ERROR : 암시적인 타입 변환은 불가능합니다.
    let integer: u8 = decimal;

    // 타입 변환을 위해서는 명시적인 변환이 필요합니다.
    let integer = decimal as u8;
    let character = integer as char;

    // ERROR : 변환 규칙에는 따라 몇가지 제한이 존재합니다.
    // float는 char 타입으로 직접적인 변환이 불가능합니다.
    let character = decimal as char;

    println!(&quot;Casting: {} -&gt; {} -&gt; {}&quot;, decimal, integer, character);

    // 어떤 값을 `unsigned` T 타입으로 변환하려고 하는 경우,
    // 새로운 타입에 값이 들어맞을 때까지
    /// T::MAX + 1을 더하거나 뺍니다.
    // Binary의 관점에서 보면, 
    // 이는 LSB에서부터 T개 자리의 숫자를 유지하고,
    // 남은 MSB로부터의 나머지는 버리는 작업을 수행하는 것입니다.

    // 1000은 애초에 u16의 범위 내에 있습니다.
    // (0 ~ 65535)
    println!(&quot;1000 as a u16 is: {}&quot;, 1000 as u16);

    // 1000은 `u8`의 범위를 벗어납니다. (0 ~ 255)
    // 따라서 여러번 T::MAX + 1 (256)를 뺍니다.
    // 1000 - 256 - 256 - 256 = 232
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);
    
    // -1의 경우도 마찬가지입니다.
    // -1 + 256 = 255
    println!(&quot;  -1 as a u8 is : {}&quot;, (-1i8) as u8);

    // 양수 입장에서, 이는 계수(modulus)와 동일해집니다.
    println!(&quot;1000 mod 256 is : {}&quot;, 1000 % 256);

    // signed 타입으로의 변환은 unsigned와 그 방식이 동일합니다.
    // 그 결과의 MSB가 1이라면 (음수라면)
    // 2의 보수를 구함으로써 signed 타입을 파악할 수 있습니다.

    // 128은 이미 `i16`의 범위 내에 있습니다.
    // (-32768 ~ 32768)
    println!(&quot; 128 as a i16 is: {}&quot;, 128 as i16);

    // 128 as u8 -&gt; 128이고, 해당 binary의
    // 2의 보수를 구하여 음수를 구해보면 -128입니다.
    println!(&quot; 128 as a i8 is : {}&quot;, 128 as i8);

    // 1000 as u8 -&gt; 232입니다.
    println!(&quot;1000 as a u8 is : {}&quot;, 1000 as u8);

    // 232의 binary를 2의 보수로 음수를 구해보면 -24입니다.
    println!(&quot; 232 as a i8 is : {}&quot;, 232 as i8);
    
    // Rust 1.45v 이후로, float -&gt; int 변환은 Saturating cast 됩니다.
    // 즉, 기존 float가 변환할 int 타입의 최대보다 크거나,
    // 최소보다 작을 경우 해당 최댓값 또는 최솟값으로 변환이 됩니다.
    
    // 300.0의 unsigned 8 변환은 256이 됩니다.
    println!(&quot;300.0 is {}&quot;, 300.0_f32 as u8);
    // -100.0의 unsigned 8 변환은 0이 됩니다.
    println!(&quot;-100.0 as u8 is {}&quot;, -100.0_f32 as u8);
    // NaN의 unsigned 8 변환은 0이 됩니다.
    println!(&quot;nan as u8 is {}&quot;, f32::NAN as u8);

    // 아래의 방식은 안전하지 않은 방법이지만,
    // 런타임 비용을 줄일 수 있습니다.
    // 다만, 그 결과가 오퍼플로우 될수 있어
    // 원치않는 값을 반환할 수도 있으니 주의해야 합니다.
    unsafe {
        // 300.0 -&gt; 44가 됩니다.
        println!(&quot;300.0 is {}&quot;, 300.0_f32.to_int_unchecked::&lt;u8&gt;());
        // -100.0 -&gt; 156이 됩니다.
        println!(&quot;-100.0 as u8 is {}&quot;, (-100.0_f32).to_int_unchecked::&lt;u8&gt;());
        // nan -&gt; 0이 됩니다.
        println!(&quot;nan as u8 is {}&quot;, f32::NAN.to_int_unchecked::&lt;u8&gt;());
    }
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="literals"><a class="header" href="#literals">Literals</a></h1>
<p>숫자 리터럴은 타입을 suffix(접미사)로 추가하여 타입을 지정할 수 있습니다. 예를 들어, <code>42</code> 리터럴에 대해 <code>42i32</code>로 작성하여 <code>i32</code> 타입을 갖도록 할 수 있습니다.</p>
<p>suffix가 없는 숫자 리터럴의 경우 해당 리터럴이 어떻게 사용되느냐에 따라 타입이 다르게 고려됩니다. 별도의 제약이 없다면, 컴파일러는 기본적으로 정수에 대해서는 <code>i32</code>로, 부동소수점 수에 대해서는 <code>f64</code> 타입이 적용됩니다.</p>
<pre><pre class="playground"><code class="language-rust eitable edition2018">fn main() {
    // 리터럴에 suffix가 붙으면,
    // 초기화 시점에 해당 타입을 알 수 있습니다.
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // suffix가 없는 리터럴의 경우,
    // 이들의 타입은 어떻게 사용되었느냐에 따라 달라집니다.
    let i = 1;
    let f = 1.0;

    // `size_of_val`은 변수의 사이즈를 bytes로 반환합니다.
    println!(&quot;size of `x` in bytes: {}&quot;, std::mem::size_of_val(&amp;x));
    println!(&quot;size of `y` in bytes: {}&quot;, std::mem::size_of_val(&amp;y));
    println!(&quot;size of `z` in bytes: {}&quot;, std::mem::size_of_val(&amp;z));
    println!(&quot;size of `i` in bytes: {}&quot;, std::mem::size_of_val(&amp;i));
    println!(&quot;size of `f` in bytes: {}&quot;, std::mem::size_of_val(&amp;f));
}
</code></pre></pre>
<p>위의 코드에서 설명하지 않은 부분이 있습니다.</p>
<ul>
<li><code>std::mem::size_of_val</code>는 <em>full path</em>를 통해 호출된 함수입니다. 코드는 **모듈(module)**이라고 부르는 로직 단위로 쪼개질 수 있습니다. 위의 경우, <code>size_of_val</code> 함수는 <code>mem</code> 모듈에서 정의된 것이며, 그 <code>mem</code> 모듈은 <code>std</code> 크레이트로부터 정의된 것입니다. 더 자세한 내용에 대해서는 추후에 설명하도록 하겠습니다.</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="inference"><a class="header" href="#inference">Inference</a></h1>
<p>타입 추론 엔진은 제법 똑똑합니다. 엔진은 단순히 초기화 시점 만으로 타입을 판단하지 않습니다. 초기화 이후에 변수를 어떻게 사용하는지를 보며, 이를 통해 타입을 유추합니다. 아래는 타입 추론의 심화 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // suffix 덕분에, 컴파일러는 `elem`의 타입을 알 수 있습니다.
    let elem = 5u8;

    // 비어있는 벡터 구조를 생성합니다.
    // 벡터는 가변적인 길이를 가진 Array입니다.
    let mut vec = Vec::new();
    // 현 시점에서, 컴파일러는 `vec`의 타입을 정확히 모릅니다.
    // 당장에 `vec`이 벡터라는 것만을 알고 있습니다.

    // 생성한 벡터에 `elem`을 삽입합니다.
    vec.push(elem);

    // 아하! 이제야 컴파일러는 `vec`가 `u8` 타입을
    // 담고있는 벡터임을 알 수 있습니다.

    // 만약, `vec.push(elem)`이 없다면,
    // 명확한 타입 추론이 불가능하기 때문에
    // 컴파일 에러가 발생합니다.
    println!(&quot;{:?}&quot;, vec);
}
</code></pre></pre>
<p>위에서 <code>vec</code>에 대한 별다른 타입 지정이 없었지만 컴파일링은 정상적으로 진행됩니다! :)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="aliasing"><a class="header" href="#aliasing">Aliasing</a></h1>
<p><code>type</code> 문은 기존 타입에 새로운 이름을 부여할 수 있습니다. 타입은 반드시 <code>UpperCamelCase</code>로 쓰여야 하고, 그렇지 않으면 경고를 출력합니다. 원시 타입의 경우는 예외입니다. (<code>usize</code>, <code>f32</code> 등)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `NanoSecond`는 `u64`의 새로운 타입명입니다.
type NanoSecond = u64;
type Inch = u64;

// camel case로 작성하지 않으면 경고가 출력됩니다.
// 다만 아래에서는 어트리뷰트를 통해 이를 무시합니다.
#[allow(non_camel_case_types)]
type u64_t = u64;

fn main() {
    // `NanoSecond` = `Inch` = `u64_t` = `u64`.
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    // 결국, 타입 별칭은 추가로 타입 안정성을 제공하는 기능이 아닙니다.
    // 별칭은 새로운 타입이 아닙니다.
    println!(&quot;{} nanoseconds + {} inches = {} unit?&quot;,
             nanoseconds,
             inches,
             nanoseconds + inches);
}
</code></pre></pre>
<p>타입 별칭의 주된 사용은 보일러플레이트를 줄이기 위함입니다. 예를 들어, <code>Result&lt;T, IoError&gt;</code>의 별칭으로 <code>IoResult&lt;T&gt;</code> 타입을 사용할 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="conversion"><a class="header" href="#conversion">Conversion</a></h1>
<p>원시값은 <strong>casting</strong>을 통해서 서로 간에 변환될 수 있습니다.</p>
<p>Rust는 트레이트를 사용해서 커스텀 타입(ex. <code>struct</code>, <code>enum</code>)간의 변환을 할 수 있습니다. 제네릭 변환은 <code>From</code>과 <code>Into</code> 트레이트가 사용됩니다. 그러나 더 일반적인 경우를 위해 더 구체적인 방법이 있으며, 이는 특히 <code>String</code>에서, 혹은 <code>String</code>으로 변환을 하려할 때 그렇습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="from-and-into"><a class="header" href="#from-and-into">From and Into</a></h1>
<p><code>From</code> 과 <code>Into</code> 트레이트는 상속적으로 연결되어 있으며, 실제로도 implementation의 일부입니다. 만약 A 타입에서 B 타입으로 변환을 할 수 있다면, B 타입에서 A타입으로 변환하는 것도 가능해야 합니다.</p>
<h2 id="from"><a class="header" href="#from">From</a></h2>
<p><code>From</code> 트레이트는 다른 타입으로부터 스스로의 타입을 정의할 수 있게끔 합니다. 따라서 여러 타입 간에 변환을 위한 간단한 매커니즘을 제공합니다. 원시 및 공통 타입의 변환을 위해 내장 라이브러리 내에도 수많은 <code>From</code> 트레이트의 구현이 존재합니다.</p>
<p>예를 들어, <code>str</code>는 간단하게 <code>String</code> 타입으로 변환할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unused)]
fn main() {
  let my_str = &quot;hello&quot;;
  let my_string = String::from(my_str);
}
</code></pre></pre>
<p>커스텀 타입에 대해서도 변환을 정의할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

// i32 정수로부터 Number 구조로의 변환을 구현합니다.
impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let num = Number::from(30);
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<h2 id="into"><a class="header" href="#into">Into</a></h2>
<p><code>Into</code> 트레이트는 단순히 <code>From</code> 트레이트의 역수입니다. 다시 말해, 타입 내에 <code>From</code> 트레이트가 구현되어 있다면, <code>Into</code>는 그것을 필요할 때 실행합니다.</p>
<p>일반적으로 <code>Into</code> 트레이트를 사용하려면 변환할 대상 타입의 구체적인 지정이 필요합니다. 대부분의 컴파일러가 이를 결정하는 것이 불가능하기 때문입니다. 하지만 해당 기능이 가져다주는 편의성을 생각할 때 이는 작은 절충입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::convert::From;

#[derive(Debug)]
struct Number {
    value: i32,
}

impl From&lt;i32&gt; for Number {
    fn from(item: i32) -&gt; Self {
        Number { value: item }
    }
}

fn main() {
    let int = 5;
    // 아래에서 `Number` 타입 지정이 없다면 에러가 발생합니다.
    let num: Number = int.into();
    println!(&quot;My number is {:?}&quot;, num);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tryfrom-and-tryinto"><a class="header" href="#tryfrom-and-tryinto">TryFrom and TryInto</a></h1>
<p><code>From</code>과 <code>Into</code>와 유사하게, <code>TryFrom</code>과 <code>TryInto</code>는 두 타입 간의 변환을 위한 제네릭 트레이트입니다. <code>From</code>/<code>Into</code>와 달리, <code>TryFrom</code>/<code>TryInto</code> 트레이트는 <em>틀릴 수도 있는</em> 변환에 사용되며, 따라서 <code>Result</code>를 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::convert::TryFrom;
use std::convert::TryInto;

#[derive(Debug, PartialEq)]
struct EvenNumber(i32);

impl TryFrom&lt;i32&gt; for EvenNumber {
    type Error = ();

    // Result는 `Ok` 혹은 `Err`를 반환합니다.
    fn try_from(value: i32) -&gt; Result&lt;Self, Self::Error&gt; {
        if value % 2 == 0 {
            Ok(EvenNumber(value))
        } else {
            Err(())
        }
    }
}

fn main() {
    // TryFrom
    assert_eq!(EvenNumber::try_from(8), Ok(EvenNumber(8)));
    assert_eq!(EvenNumber::try_from(5), Err(()));

    // TryInto
    let result: Result&lt;EvenNumber, ()&gt; = 8i32.try_into();
    assert_eq!(result, Ok(EvenNumber(8)));
    let result: Result&lt;EvenNumber, ()&gt; = 5i32.try_into();
    assert_eq!(result, Err(()));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="to-and-from-strings"><a class="header" href="#to-and-from-strings">To and from Strings</a></h1>
<h2 id="converting-to-string"><a class="header" href="#converting-to-string">Converting to String</a></h2>
<p>어떤 타입을 <code>String</code>으로 변환하는 것은 <code>ToString</code> 트레이트를 해당 타입에 대해서 구현하면 쉽습니다. 이를 직접 구현하기 보다는, <code>fmt::Display</code> 트레이트를 구현한다면, <code>ToString</code>이 자동으로 제공되며, <code>print!</code> 매크로의 사용 시 적절하게 출력하도록 할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

struct Circle {
    radius: i32
}

// Circle 구조에 대한 fmt::Display 트레이트를 구현합니다.
impl fmt::Display for Circle {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;Circle of radius {}&quot;, self.radius)
    }
}

fn main() {
    let circle = Circle { radius: 6 };
    // 아래의 `.to_string()`이 없더라도 제대로 출력됩니다.
    println!(&quot;{}&quot;, circle.to_string());
}
</code></pre></pre>
<h2 id="parsing-a-string"><a class="header" href="#parsing-a-string">Parsing a String</a></h2>
<p>어떤 타입을 String으로 변환하는 것만큼 일반적인 상황은 바로 Number 타입입니다. 이에 대해 접근하는 자연스러운 방법은 <code>parse</code> 함수를 통한 타입 추론 기반으로 처리하거나, <em>turbofish</em> 문을 통해 직접 파싱할 타입을 정해주는 것입니다. 두가지 방법 모두 아래의 예시에서 확인할 수 있습니다.</p>
<p><code>FromStr</code> 트레이트가 해당 타입에 대해 구현되어 있는 한, 지정된 타입으로 스트링을 변환할 수 있습니다. 내장 라이브러리에서도 수많은 타입에 대해 이것이 구현되어 있습니다. 직접 정의한 타입에 대해 해당 기능을 갖추게 하기 위해서는 단순히 <code>FromStr</code> 트레이트를 해당 타입에 대해 구현하기만 하면 됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 그냥 `parse` 함수를 사용하면 타입 추론을 기반으로 처리됩니다.
    // `unwrap`을 적용하기 전의 결과는 `Result` 입니다.
    let parsed: i32 = &quot;5&quot;.parse().unwrap();
    // turbofish 문은 직접 파싱할 타입을 지정해주어야 합니다.
    let turbo_parsed = &quot;10&quot;.parse::&lt;i32&gt;().unwrap();

    let sum = parsed + turbo_parsed;
    println!(&quot;Sum: {:?}&quot;, sum);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="expressions"><a class="header" href="#expressions">Expressions</a></h1>
<p>Rust로 작성한 프로그램은 대부분 Statement의 모음으로 구성됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">  fn main() {
    // statement
    // statement
    // statement
}
</code></pre></pre>
<p>Rust에는 몇몇 종류의 statement가 존재합니다. 그중 가장 일반적인 두가지는 '변수 바인딩'과 <code>;</code>을 사용하는 expression입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    // variable binding
    let x = 5;

    // expression;
    x;
    x + 1;
    15;
}
</code></pre></pre>
<p>블록(<code>{}</code>)도 마찬가지로 Expression 입니다. 따라서 블록 역시 할당에 사용될 수 있습니다. 이 경우, 블록 내의 마지막 Expression이 할당 값이 됩니다. 하지만, 마지막 Expression이 세미콜론(<code>;</code>)과 함께 작성되는 경우에는 아무 값도 반환되지 않고, 유닛 타입 <code>()</code>이 됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // 아래 expression이 y에 할당됩니다.
        x_cube + x_squared + x
    };

    let z = {
        // 세미콜론이 아래 식을 억제합니다.
        // `z`는 `()`이 됩니다.
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="flow-of-control"><a class="header" href="#flow-of-control">Flow of Control</a></h1>
<p>어떤 프로그래밍 언어든 제어 흐름을 수정하기 위한 필수적인 요소들을 갖추고 있습니다. 이를 테면 <code>if</code>, <code>else</code>, <code>for</code>과 같은 것들입니다. Rust에서의 이들에 대해 살펴봅시다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ifelse"><a class="header" href="#ifelse">if/else</a></h1>
<p><code>if</code>-<code>else</code>를 다루는 것은 다른 언어에서와 유사합니다. 대신 다른 언어에서와 달리, Boolean 조건은 괄호로 둘러싸일 필요가 없으며, 각각의 조건문은 블록으로 감싸져야 합니다. <code>if</code>-<code>else</code> 조건문 역시 Expression이며, 모든 분기점들은 반드시 동일한 타입을 반환해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let n = 5;

    if n &lt; 0 {
        print!(&quot;{} is negative&quot;, n);
    } else if n &gt; 0 {
        print!(&quot;{} is positive&quot;, n);
    } else {
        print!(&quot;{} is zero&quot;, n);
    }

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);
            
            // 해당 `if` 문은 `i32` 타입을 반환합니다.
            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);

            // 따라서 `else` 조건문 역시 `i32` 타입을 반환해야 합니다.
            n / 2
        };
    //   ^ 여기에 세미콜론을 사용하는 것을 잊지 마세요!
    // 모든 `let` 바인딩이 그런 것처럼요.

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="loop"><a class="header" href="#loop">Loop</a></h1>
<p>Rust는 무한 루프를 나타내는 <code>loop</code> 키워드를 제공합니다.</p>
<p><code>break</code> 문은 루프의 진행 중 어느 때라도 빠져나갈 수 있게 해줍니다. <code>continue</code> 문은 현재 반복 중 남은 부분들을 무시하고 다음 반복으로 넘어갈 수 있게 해줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // 무한 루프
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // 현재 반복의 나머지 부분들을 무시합니다.
            continue;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            // 루프에서 빠져나갑니다.
            break;
        }
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="nesting-and-labels"><a class="header" href="#nesting-and-labels">Nesting and labels</a></h1>
<p>중첩 루프를 다룰 때, 바깥 쪽의 루프에 대해서도 <code>break</code>나 <code>continue</code>를 사용할 수 있습니다. 이를 위해선, 각 루프들에 대한 <code>'label</code>이 정의되어야 하며, 해당 라벨이 <code>break</code>나 <code>continue</code> 문에 전달되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unreachable_code)]

fn main() {
    'outer: loop {
        println!(&quot;Entered the outer loop&quot;);

        'inner: loop {
            println!(&quot;Entered the inner loop&quot;);

            // 단순히 `break`를 사용하면 현재 루프를 멈춥니다.
            //break;

            // label을 함께 넘기면 지정한 label의 루프를 멈춥니다.
            break 'outer;
        }

        println!(&quot;This point will never be reached&quot;);
    }

    println!(&quot;Exited the outer loop&quot;);
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="returning-from-loops"><a class="header" href="#returning-from-loops">Returning from loops</a></h1>
<p><code>loop</code>의 사용 목적 중 하나는 '성공할 때까지 실행하는' 것입니다. 만약 작업 중 값을 반환하게 되면, 코드의 나머지 부분들을 무시해야 할 겁니다. <code>break</code> 뒤에 반환값을 두면, <code>loop</code> Expression에 의해 반환됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            // 여기서의 `;`은 선택사항입니다.
            break counter * 2;
        }
    };

    assert_eq!(result, 20);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="while"><a class="header" href="#while">while</a></h1>
<p><code>while</code> 키워드는 주어진 조건이 <code>true</code>인 경우에 루프를 실행합니다.</p>
<p><em>FizzBuzz</em> 문제를 <code>while</code>을 통해서 해결해보자.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let mut n = 1;

    // n이 101 미만인 동안만 루프가 실행됩니다.
    while n &lt; 101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }

        // n을 1씩 더합니다.
        n += 1;
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="for-loops"><a class="header" href="#for-loops">for loops</a></h1>
<h2 id="for-and-range"><a class="header" href="#for-and-range">for and range</a></h2>
<p><code>for in</code> 구조는 순회를 통해 반복되는 작업을 수행하고자 할 때에 사용됩니다. iterator를 생성하는 가장 쉬운 방법은 <code>a..b</code>로 range 표기를 사용하는 것입니다. 이는 <code>a</code>(포함)에서 <code>b</code>(제외)까지의 값들을 매번 하나씩 가져옵니다.</p>
<p>FizzBuzz 문제를 이번엔 <code>for</code>문을 통해 해결해봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `n`은 매 순회마다 순서대로 
    // 1, 2, ... 100 이 됩니다.
    for n in 1..101 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}

</code></pre></pre>
<p><code>a..=b</code>를 사용한다면, <code>b</code> 역시 순회에 포함하게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `n`은 매 순회마다 순서대로 
    // 1, 2, ... 100 이 됩니다.
    for n in 1..=100 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }
    }
}
</code></pre></pre>
<h2 id="for-and-iterators"><a class="header" href="#for-and-iterators">for and iterators</a></h2>
<p><code>for in</code> 구조는 <code>Iterator</code>와 다양한 방식으로 상호작용할 수 있습니다. 추후 Iterator에 대해 설명하겠지만, 기본적으로 <code>for</code> 루프는 컬렉션에 <code>into_iter</code> 함수를 적용합니다. 그러나, 컬렉션을 iterator로 변환하는 방법은 이것이 다가 아닙니다.</p>
<p>데이터에 대한 다양한 관점으로, <code>into_iter</code>, <code>iter</code> 와 <code>iter_mut</code> 모두 컬렉션을 iterator로 다른 방식으로 변환할 수 있습니다.</p>
<ul>
<li><code>iter</code> - 컬렉션의 각 요소들을 각 순회에서 '빌려'옵니다.  따라서 컬렉션 자체는 건들지 않으며, 루프가 진행된 이후에도 재사용될 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter() {
        match name {
            // `&amp;`로  가져오고 있음을 주의하세요.
            &amp;&quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
    
    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<ul>
<li><code>into_iter</code> - 실제 컬렉션을 사용하여, 각 순회에 실제 데이터가 사용됩니다. 한번 컬렉션이 사용되고 나면, 루프 내에서 <em>변했기</em> 때문에 더 이상 재사용할 수 없습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.into_iter() {
        match name {
            &quot;Ferris&quot; =&gt; println!(&quot;There is a rustacean among us!&quot;),
            _ =&gt; println!(&quot;Hello {}&quot;, name),
        }
    }
    
    // ERROR : 아래 코드에선 에러가 발생합니다.
    // `into_iter`의 메서드로 인해 `names`가 변경되었기 때문입니다.
    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<ul>
<li><code>into_mut</code> - 컬렉션에서 각 요소들을 mutable하게 빌려옵니다. 다시 말해, 매 순환마다 컬렉션 자체에 수정을 가할 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let mut names = vec![&quot;Bob&quot;, &quot;Frank&quot;, &quot;Ferris&quot;];

    for name in names.iter_mut() {
        *name = match name {
            &amp;mut &quot;Ferris&quot; =&gt; &quot;There is a rustacean among us!&quot;,
            _ =&gt; &quot;Hello&quot;,
        }
    }

    println!(&quot;names: {:?}&quot;, names);
}
</code></pre></pre>
<p>위의 여러 방법 간에, 순회에서 제공되는 타입이 저마다 다르다는 점을 주의하세요. 당연히, 타입이 다름에 따라 수행될 수 있는 동작 자체에도 차이가 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">match</a></h1>
<p>Rust에서는 <code>match</code> 키워드로 패턴을 시킬 수 있습니다. 이는 C에서의 <code>switch</code>와 유사합니다. match 내에서 첫번째로 일치하는 패턴에 따라 내요이 처리되며, match는 발생할 수 있는 패턴에 대해 처리할 수 있어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let number = 13;

    println!(&quot;Tell me about {}&quot;, number);
    match number {
        // 하나의 값에 대한 매칭
        1 =&gt; println!(&quot;One!&quot;),
        // 여러 값에 대해 매칭
        2 | 3 | 5 | 7 | 11 | 13=&gt; println!(&quot;This is a prime&quot;),
        // 범위에 대해 매칭
        14..=19 =&gt; println!(&quot;A teen&quot;),
        // 발생할 수 있는 나머지 부분에 대해 처리
        _ =&gt; println!(&quot;Ain't special&quot;),
    }

    let boolean = true;
    // match도 Expression 입니다.
    let binary = match boolean {
        // 발생할 수 있는 모든 경우에 대해 처리합니다.
        false =&gt; 0,
        true =&gt; 1,
    };

    println!(&quot;{} -&gt; {}&quot;, boolean, binary);
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h1>
<p><code>match</code> 블럭은 데이터를 여러 방식으로 분해할 수 있습니다.</p>
<ul>
<li><a href="flow_control/match/destructuring/./tuples.html">Destructuring Tuples</a></li>
<li><a href="flow_control/match/destructuring/./enums.html">Destructuring Enums</a></li>
<li><a href="flow_control/match/destructuring/./pointers.html">Destructuring Pointers</a></li>
<li><a href="flow_control/match/destructuring/./structs.html">Destructuring Structures</a></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tuples-1"><a class="header" href="#tuples-1">tuples</a></h1>
<ul>
<li>튜플은 <code>match</code>를 통해 분해될 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let triple = (0, -2, 3);

    println!(&quot;Tell me about {:?}&quot;, triple);
    // match는 튜플 값을 분해할 수 있습니다.
    match triple {
        // 2, 3번째 값을 바인딩하여 가져옵니다.
        (0, y, z) =&gt; println!(&quot;First is `0`, `y` is {:?}, and `z` is {:?}&quot;, y, z),
        (1, ..)  =&gt; println!(&quot;First is `1` and the rest doesn't matter&quot;),
        // `..`는 튜플의 나머지 부분을 무시하기 위해 사용됩니다.
        _      =&gt; println!(&quot;It doesn't matter what they are&quot;),
        // `_`는 값을 변수에 바인딩하지 않겠다는 의미입니다.
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="enums-1"><a class="header" href="#enums-1">enums</a></h1>
<p><code>enum</code>도 유사하게 분해될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 사용하지 않은 변수에 대한 경고를 감춥니다.
#[allow(dead_code)]
enum Color {
    // 아래 셋은 이름만 명시되어 있습니다.
    Red,
    Blue,
    Green,
    // 나머지는 `u32` 튜플들을 각자 다른 이름으로 묶습니다.
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn main() {
    // 아래의 `RGB`를 다른 변형으로 바꾸어보세요.
    let color = Color::RGB(122, 17, 40);

    println!(&quot;What color is it?&quot;);
    // `enum`은 `match`를 통해 분해될 수 있습니다.
    match color {
        Color::Red   =&gt; println!(&quot;The color is Red!&quot;),
        Color::Blue  =&gt; println!(&quot;The color is Blue!&quot;),
        Color::Green =&gt; println!(&quot;The color is Green!&quot;),
        Color::RGB(r, g, b) =&gt;
            println!(&quot;Red: {}, green: {}, and blue: {}!&quot;, r, g, b),
        Color::HSV(h, s, v) =&gt;
            println!(&quot;Hue: {}, saturation: {}, value: {}!&quot;, h, s, v),
        Color::HSL(h, s, l) =&gt;
            println!(&quot;Hue: {}, saturation: {}, lightness: {}!&quot;, h, s, l),
        Color::CMY(c, m, y) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}!&quot;, c, m, y),
        Color::CMYK(c, m, y, k) =&gt;
            println!(&quot;Cyan: {}, magenta: {}, yellow: {}, key (black): {}!&quot;,
                c, m, y, k),
        // 모든 변형에 대해서 처리했습니다.
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pointersref"><a class="header" href="#pointersref">pointers/ref</a></h1>
<p>포인터의 경우, C 언어와 같이, 다르게 사용되는 개념이기 때문에 분해(destructuring)과 역참조(dereferencing) 간의 구분이 필요하다.</p>
<ul>
<li>역참조(Dereference)는 <code>*</code>를 사용합니다.</li>
<li>분해(Destructuring)은 <code>&amp;</code>, <code>ref</code>, 그리고 <code>ref mut</code>를 사용합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `i32` 타입의 레퍼런스를 할당합니다.
    // `&amp;`는 할당된 참조가 존재함을 나타냅니다.
    let reference = &amp;4;

    match reference {
        // 참조의 매칭은 `&amp;val`에 대해 이루어집니다.
        // 즉 매칭은 `&amp;4` == `&amp;val`와 같이 이루어지는데,
        // `&amp;`를 떼놓고 본다면, `i32`가 `val`과 매칭됨을 알 수 있습니다.
        &amp;val =&gt; println!(&quot;Got a value via destructuring: {:?}&quot;, val),
    }

    // `&amp;`을 사용하지 않으려면, 역참조를 활용하면 됩니다.
    match *reference {
        val =&gt; println!(&quot;Got a value via dereferencing: {:?}&quot;, val),
    }

    // 애초에 참조를 사용하지 않는다면 어떨까요?
    let _not_a_reference = 3;

    // `ref`는 이런 경우에 사용하기 위해 `ref`를 제공합니다.
    // `ref`를 사용하면, 요소에 대한 참조가 생성되도록 할당을 수정합니다.
    // 이 경우, 값이 아닌, 참조가 할당됩니다.
    let ref _is_a_reference = 3;

    // 따라서, 참조 없이 정의한 아래의 두 값에 대해서도,
    // `ref`와 `ref mut`를 통해 참조값을 얻을 수 있습니다.
    let value = 5;
    let mut mut_value = 6;

    // `ref` 키워드가 참조를 생성합니다.
    match value {
        ref r =&gt; println!(&quot;Got a reference to a value: {:?}&quot;, r),
    }

    // `ref mut` 역시 유사합니다.
    match mut_value {
        ref mut m =&gt; {
            // 참조를 얻어, 이에 대한 역참조를 얻습니다.
            // 이후 해당 값을 수정합니다.
            *m += 10;
            println!(&quot;We added 10. `mut_value`: {:?}&quot;, m);
        },
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">structs</a></h1>
<p>이와 유사하게, <code>struct</code>도 분해될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    let foo = Foo { x: (1, 2), y: 3 };

    match foo {
        Foo { x: (1, b), y } =&gt; println!(&quot;First of x is 1, b = {},  y = {} &quot;, b, y),

        // 구조를 분해하고 변수명을 변경할수도 있습니다.
        // 순서는 상관 없습니다.
        Foo { y: 2, x: i } =&gt; println!(&quot;y is 2, i = {:?}&quot;, i),

        // 나머지 변수들을 무시해도 됩니다.
        Foo { y, .. } =&gt; println!(&quot;y = {}, we don't care about x&quot;, y),

        // 단, 아래는 에러가 발생합니다.
        // `x` 필드에 대한 처리를 다루지 않았기 때문입니다.
        Foo { y } =&gt; println!(&quot;y = {}&quot;, y),
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="guards"><a class="header" href="#guards">Guards</a></h1>
<p>가능한 경우에 대해 필터링을 하기 위해, Match Guard를 추가할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let pair = (2, -2);

    println!(&quot;Tell me about {:?}&quot;, pair);
    match pair {
        (x, y) if x == y =&gt; println!(&quot;These are twins&quot;),
        // 위의 `if 조건`이 match guard에 해당합니다.
        (x, y) if x + y == 0 =&gt; println!(&quot;Antimatter, kaboom!&quot;),
        (x, _) if x % 2 == 1 =&gt; println!(&quot;The first one is odd&quot;),
        _ =&gt; println!(&quot;No correlation...&quot;),
    }
}
</code></pre></pre>
<p>컴파일러는 모든 조건이 처리되는지에 대해서는 체크하지 않습니다. 따라서, 이를 활용할 때 마지막에 <code>_</code> 패턴을 통해 예외에 대한 처리를 해주어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let number: u8 = 4;

    match number {
        i if i == 0 =&gt; println!(&quot;Zero&quot;),
        i if i &gt; 0 =&gt; println!(&quot;Greater than zero&quot;),
        // 아래 조건은 도달할 일이 없지만,
        // 컴파일러 입장에서 요구됩니다.
        _ =&gt; println!(&quot;Fell through&quot;),
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="binding"><a class="header" href="#binding">Binding</a></h1>
<p>변수에 간접적으로 접근할 경우 다시 바인딩 하지 않고서는 변수를 사용하거나 분기를 처리할 수 없습니다. <code>match</code>는 값을 다른 이름으로 바인딩하기 위한 <code>@</code> 표기를 제공합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// A function `age` which returns a `u32`.
// `age` 함수는 `u32`를 반환합니다.
fn age() -&gt; u32 {
    15
}

fn main() {
    println!(&quot;Tell me what type of person you are&quot;);

    match age() {
        0             =&gt; println!(&quot;I haven't celebrated my first birthday yet&quot;),
        // 현재, `age()`에 대해 `1 ..= 12`로 매칭 여부는 판단할 수 있습니다.
        // 그런데, 해당 값에 어떻게 접근할 수 있을까요??
        // 이를 해결하기 위해, `1 ..= 12`의 시퀀스에 `n`을 바인딩 시킵니다.
        n @ 1  ..= 12 =&gt; println!(&quot;I'm a child of age {:?}&quot;, n),
        n @ 13 ..= 19 =&gt; println!(&quot;I'm a teen of age {:?}&quot;, n),
        // 아래는 바인딩된 것이 없습니다. `n`은 단순히 `age()`의 값입니다.
        n             =&gt; println!(&quot;I'm an old person of age {:?}&quot;, n),
    }
}
</code></pre></pre>
<p><code>Option</code>과 같은 <code>enum</code> 변형에 대해서도 분해를 할수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn some_number() -&gt; Option&lt;u32&gt; {
    Some(42)
}

fn main() {
    match some_number() {
        // `Some` 변형 가져와, 값을 매칭합니다.
        // 이후 이를 `n`에 바인딩시키며, 이는 `42`와 동일합니다.
        Some(n @ 42) =&gt; println!(&quot;The Answer: {}!&quot;, n),
        // 그 외의 다른 수인 경우와 매칭됩니다.
        Some(n)      =&gt; println!(&quot;Not interesting... {}&quot;, n),
        // 그 외의 경우와 매칭됩니다. (`None` 변형인 경우)
        _            =&gt; (),
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="if-let"><a class="header" href="#if-let">if let</a></h1>
<p>일부 상황에서, enums를 매칭할 때 <code>match</code>가 어색한 경우가 발생합니다. 하나의 예를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unused)]
fn main() {
// `Option&lt;i32&gt;` 타입의 `optional` 변수를 바인딩합니다.
let optional = Some(7);

match optional {
    Some(i) =&gt; {
        println!(&quot;This is a really long string and `{:?}`&quot;, i);
    },
    // `match`는 철저하게 모든 경우에 처리해야 하므로
    // 아래와 같은 처리가 필요합니다.
    // 공간 낭비처럼 보이지 않나요?
    _ =&gt; {},
};

}
</code></pre></pre>
<p><code>if let</code>은 이런 상황에서 더 깔끔한 코드를 작성할 수 있게끔 해줍니다. 추가적으로, 여러 실패 옵션들을 구체적으로 지정할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 아래는 모두 `Option&lt;i32&gt;` 타입입니다.
    let number = Some(7);
    let letter: Option&lt;i32&gt; = None;
    let emoticon: Option&lt;i32&gt; = None;

    // `if let` 구조는 다음과 같이 해석될 수 있습니다.
    // : &quot;만약 `number`가 `Some(i)`로 분해될 수 있다면, 아래의 블럭을 수행합니다.&quot;
    if let Some(i) = number {
        println!(&quot;Matched {:?}!&quot;, i);
    }

    // 수행될 수 없다면, 이에 대한 대처도 할 수 있습니다.
    if let Some(i) = letter {
        println!(&quot;Matched {:?}!&quot;, i);
    } else {
        // 분해에 실패했다면, 해당 블럭이 실행됩니다.
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    }

    // 다른 실패 케이스를 만들어 봅시다.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!(&quot;Matched {:?}!&quot;, i);
    // 분해에 실패하면, `else if` 조건에 대해 추가적으로 판단합니다.
    } else if i_like_letters {
        println!(&quot;Didn't match a number. Let's go with a letter!&quot;);
    } else {
        println!(&quot;I don't like letters. Let's go with an emoticon :)!&quot;);
    }
}
</code></pre></pre>
<p>동일한 방식으로, <code>if let</code>은 <code>enum</code>에 대해서도 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 임의로 enum을 만듭니다.
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    // 임의로 변수 바인딩을 몇개 만듭니다.
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);
    
    // 변수 `a`가 Foo::Bar에 해당한다면 블럭을 수행합니다.
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
    
    // 변수 `b`는 Foo::Bar에 매칭되지 않습니다.
    // 따라서 아래는 출력되지 않습니다.
    if let Foo::Bar = b {
        println!(&quot;b is foobar&quot;);
    }
    
    // 변수 `c`는 값을 보유한 Foo::Qux와 매칭됩니다.
    if let Foo::Qux(value) = c {
        println!(&quot;c is {}&quot;, value);
    }

    // `if let`에 대해서도 바인딩을 할 수 있습니다.
    if let Foo::Qux(value @ 100) = c {
        println!(&quot;c is one hundred&quot;);
    }
}
</code></pre></pre>
<p><code>if let</code>의 또 다른 이점은 <em>매개변수가 아닌(non-parameterized)</em> enum 변형에 대해 일치시킬 수 있다는 점입니다. 심지어 enum이 <code>PartialEq</code>를 구현/파생하지 않는 경우에도 마찬가지입니다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 아래 enum은 의도적으로 구현도, PartialEq도 파생하지 않았습니다.
// 이런 이유로, `Foo::Bar == a`는 아래에서 실패할 것입니다.
enum Foo {Bar}

fn main() {
    let a = Foo::Bar;

    // ERROR : 변수 `a`는 `Foo::Bar`에 매칭되지만, 
    // 아래는 컴파일 에러가 발생합니다.
    if Foo::Bar == a {
        println!(&quot;a is foobar&quot;);
    }

    // 대신 아래와 같이 사용한다면 문제 없습니다.
    if let Foo::Bar = a {
        println!(&quot;a is foobar&quot;);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="while-let"><a class="header" href="#while-let">while let</a></h1>
<p><code>if let</code>과 유사하게, <code>while let</code>도 어색한 <code>match</code> 문을 좀 더 낫게 만들어줍니다. <code>i</code>가 증가해나가는 아래의 루프를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unused)]
fn main() {
// `Option&lt;i32&gt;` 타입을 가진 `optional`을 바인딩합니다.
let mut optional = Some(0);

// 테스트를 반복적으로 수행합니다.
loop {
    match optional {
        // 만약 `optional`이 분해 가능하다면, 블럭을 수행합니다.
        Some(i) =&gt; {
            if i &gt; 9 {
                println!(&quot;Greater than 9, quit!&quot;);
                optional = None;
            } else {
                println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
                optional = Some(i + 1);
            }
        },
        // 구조 분해에 실패한다면 loop에서 빠져나옵니다.
        _ =&gt; { break; }
        // 과연 위의 코드가 필요한걸까요? 더 나은 방법이 있을겁니다!
    }
}
}
</code></pre></pre>
<p><code>while let</code>은 이를 더 나아보이게 만듭니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `Option&lt;i32&gt;` 타입을 갖는 `optional`을 바인딩합니다.
    let mut optional = Some(0);

    // : `optional`이 `Some(i)`로 구조 분해 될 수 있다면,
    // 블럭(`{}`)을 수행하고, 그렇지 않다면 `break` 합니다.
    while let Some(i) = optional {
        if i &gt; 9 {
            println!(&quot;Greater than 9, quit!&quot;);
            optional = None;
        } else {
            println!(&quot;`i` is `{:?}`. Try again.&quot;, i);
            optional = Some(i + 1);
        }
        // 들여쓰기가 줄어들고, 실패 케이스에 대한
        // 명확한 처리를 하지 않아도 됩니다!
    }
    // `if let`은 `else`, `else if` 문이 선택적으로 쓰일 수 있었지만,
    // `while let`은 이런 것들이 존재하지 않습니다.
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>함수는 <code>fn</code> 키워드로 선언될 수 있습니다. 이들의 인자(arguments)는 변수와 마찬가지로 타입을 지정해야하며, 함수가 값을 반환한다면, <code>-&gt;</code> 화살표를 통해 반환 값의 타입도 지정되어야 합니다. </p>
<p>함수 내에서의 마지막 Expression은 반환값으로 사용됩니다. 또는, <code>return</code> 값을 통해 원하는 시점에서 값을 반환할 수 있습니다. 이는 루프나 <code>if</code> 문 내에서 활용할 수 있습니다.</p>
<p>함수를 이용한 FizzBuzz를 구현해봅시다!</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// C/C++과 다르게, 함수 정의의 순서에는 제약이 없습니다.
fn main() {
    // 여기에서 `fizzbuzz_to`를 호출하되,
    // 구현은 아래에서 할 것입니다.
    fizzbuzz_to(100);
}

// 이 함수는 boolean값을 반환합니다.
fn is_divisible_by(lhs: u32, rhs: u32) -&gt; bool {
    // 코너 케이스(corner case)에 대해 값을 반환시킵니다.
    if rhs == 0 {
        return false;
    }

    // 아래는 Expression은 반환값으로 쓰입니다.
    // 여기서는 `return` 키워드가 필수적이지 않습니다.
    lhs % rhs == 0
}

// 함수가 값을 반환하지 않는 경우, 유닛 타입 `()`이 반환됩니다.
fn fizzbuzz(n: u32) -&gt; () {
    if is_divisible_by(n, 15) {
        println!(&quot;fizzbuzz&quot;);
    } else if is_divisible_by(n, 3) {
        println!(&quot;fizz&quot;);
    } else if is_divisible_by(n, 5) {
        println!(&quot;buzz&quot;);
    } else {
        println!(&quot;{}&quot;, n);
    }
}

// 함수가 `()`를 반환하는 경우는 반환 타입 정의를 생략할 수 있습니다.
fn fizzbuzz_to(n: u32) {
    for n in 1..n + 1 {
        fizzbuzz(n);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="methods"><a class="header" href="#methods">Methods</a></h1>
<p>메서드는 객체에 부착된 함수입니다. 메서드는 <code>self</code> 키워드를 통해 본인 객체의 데이터와 다른 메서드에 접근할 수 있습니다. 메서드는 <code>impl</code> 블럭 내에서 정의됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Point {
    x: f64,
    y: f64,
}

// 모든 'Point'의 메서드는 이 `impl` 블럭에 작성됩니다.
impl Point {
    // 이는 정적(static) 메서드 입니다.
    // 정적 메서드는 인스턴스를 통해 호출될 필요가 없습니다.
    // 일반적으로 이들은 생성자로 사용됩니다.
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // 두개의 인자를 갖는 다른 정적 메서드입니다.
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // 이것은 인스턴스 메서드입니다.
    // `&amp;self`는 `self: &amp;Self`의 Syntactic sugar 입니다.
    // `Self`는 호출 객체의 타입이며, 여기서는 `Rectangle` 입니다.
    fn area(&amp;self) -&gt; f64 {
        // `self`에서 `.`을 통해 인스턴스의 필드에 접근할 수 있습니다.
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs`는 호출자의 절대값을 반환하는 `f64` 메서드입니다.
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // `&amp;mut self` desugars to `self: &amp;mut Self`
    // 아래 메서드는 mutable한 호출 객체를 요구합니다.
    // `&amp;mut self`는 `self: &amp;mut Self`의 Syntactic Sugar입니다.
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair`는 정수가 할당된 두 개의 Heap을 보유합니다.
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // 아래 메서드는 호출 객체의 리소스를 &quot;소비&quot;합니다.
    // `self`는 `self: Self`의 Syntactic Sugar 입니다.
    fn destroy(self) {
        // `self`를 구조분해 합니다.
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);
        // `first`와 `second`는 이제 사용할 수 없습니다.
    }
}

fn main() {
    let rectangle = Rectangle {
        // 정적 메서드들은 `::`을 통해 호출됩니다.
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // 인스턴스 메서드들은 `.`로 호출됩니다.
    // 첫번째 인자인 `&amp;self`는 암시적으로 전달됩니다.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // ERROR : `rectangle`은 immutable 객체입니다.
    // 하지만 앞서 구현한 `translate` 메서드는 mutable 객체를 요구합니다.
    // 때문에 아래 코드는 에러가 발생합니다.
    rectangle.translate(1.0, 0.0);

    // `square`의 경우엔 mutable 객체이기 때문에 문제가 없습니다.
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // ERROR : 앞서 구현했듯, `destroy` 메서드는 리소스를 '소비'(consume)합니다.
    pair.destroy();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="closures"><a class="header" href="#closures">Closures</a></h1>
<p>클로저는 닫혀있는 환경을 캡처할 수 있는 기능입니다. 예를 들어, 아래는 <code>x</code> 변수를 캡처하는 클로저입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>|val| val + x
<span class="boring">}
</span></code></pre></pre>
<p>클로저 구문과 기능은 이를 즉시 사용할 수 있도록 하여 매우 편리하게 만들어줍니다. 클로저의 호출은 함수의 호출과 완전히 동일합니다. 그러나, 클로저의 입력과 반환 타입은 모두 유추될 수 있으며, 입력 변수명은 반드시 지정되어야 합니다.</p>
<p>클로저의 다른 특징에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li>입력 변수에 <code>()</code> 대신에 <code>||</code> 괄호를 사용합니다.</li>
<li>단일 식에 대해서는 <code>{}</code> 본문 구분을 선택적으로 사용할 수 있습니다.</li>
<li>외부 환경 변수들을 캡처할 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 클로저와 함수를 통해 값을 증가시킵니다.
    fn function(i: i32) -&gt; i32 { i + 1 }

    // 클로저는 익명으로, 여기서는 이들을 참조로 바인딩하고 있습니다.
    // 타입 지정은 함수와 동일하지만, 본문의 `{}`와 같이 선택 사항입니다.
    // 이들 익명 함수는 적절하게 명명된 변수에 할당됩니다.
    let closure_annotated = |i: i32| -&gt; i32 { i + 1 };
    let closure_inferred  = |i     |          i + 1  ;

    let i = 1;
    // 함수와 클로저를 호출합니다.
    println!(&quot;function: {}&quot;, function(i));
    println!(&quot;closure_annotated: {}&quot;, closure_annotated(i));
    println!(&quot;closure_inferred: {}&quot;, closure_inferred(i));

    // 인자가 존재하지 않는 클로저도 만들어봅시다.
    // 반환 타입에 대해서는 `i32`로 타입 추론이 적용됩니다.
    let one = || 1;
    println!(&quot;closure returning one: {}&quot;, one());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="capturing"><a class="header" href="#capturing">Capturing</a></h1>
<p>클로저는 유연하고, 타입 선언 없이도 클로저를 동작시키기 위한 작업들이 실행됩니다. 이는 캡처링을 실제로 유연하게 적용할 수 있도록 하고, 때로는 캡처한 변수를 이동(moving)시키거나, 대여(borrowing)합니다.</p>
<p>클로저는 아래 방법들을 통해 변수들을 캡처할 수 있습니다.</p>
<ul>
<li><code>&amp;T</code> : 참조를 통해</li>
<li><code>&amp;mut T</code> : mutable 참조를 통해</li>
<li><code>T</code> : 값을 통해</li>
</ul>
<p>클로저는 기본적으로 참조를 통한 변수 캡처링이 우선시하며, 필요에 따라 아래 순위로 옮겨갑니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    use std::mem;
    
    let color = String::from(&quot;green&quot;);

    // `color`를 출력하기 위한 클로저입니다.
    // 이는 `color`를 즉각적으로 참조(`&amp;`)로 가져와서
    // `print` 변수에 빌려온 `color`와 클로저를 저장합니다.
    // 이는 마지막으로 `print`를 사용할 때까지 유지됩니다.
    // `println!`은 오직 immutable 참조에 의한 인자만을 요구하며,
    // 따라서 별다른 제한 사항은 없습니다.
    let print = || println!(&quot;`color`: {}&quot;, color);

    // 클로저를 호출하여 대여한 변수를 사용합니다.
    print();

    // `color`는 다시 immutable하게 다른 변수에 대여될 수 있습니다.
    // 여기서의 클로저는 단순히 `color`에 대한 불변 참조를 보유할 뿐입니다.
    let _reborrow = &amp;color;
    print();

    // 이동(move)와 재대여(reborrow)는 마지막 `print`의 사용 이후 가능합니다.
    let _color_moved = color;


    let mut count = 0;

    // 값 증가를 구현하는 클로저 `count`는 `&amp;mut count`나 `count` 둘 다 사용할 수 있습니다.
    // 하지만, `&amp;mut count` 쪽이 덜 제한적이므로, 이를 사용합니다.
    // `&amp;mut`가 `inc` 내부에 저장되어 있기 때문에, `inc`에도 `mut`가 필요합니다.
    // 해당 클로저의 호출은 `mut`를 가진 클로저 스스로를 변형시킵니다.
    let mut inc = || {
        count += 1;
        println!(&quot;`count`: {}&quot;, count);
    };

    // mutable 대여를 사용하는 클로저를 호출합니다.
    inc();


    // `int` 클로저는 여전히 `count`를 mutable하게 대여하고 있습니다.
    // 추후에도 아래쪽에서 `int`가 호출되기 때문입니다.
    // ERROR: 따라서, 이를 reborrow 하려는 시도는 에러를 발생시킵니다.
    let _reborrow = &amp;count; 

    inc();

    // 클로저는 더 이상 `&amp;mut count`를 빌려올 필요가 없습니다.
    // 따라서 이제 reborrow에 대한 에러를 발생시키지 않습니다.
    let _count_reborrowed = &amp;mut count; 

    
    // non-copy 타입 -&gt; 값(value) 자체를 사용합니다.
    let movable = Box::new(3);

    // `mem::drop`은 `T`를 요구하므로, 참조가 아닌 값(value)을 사용해야 합니다.
    // copy 타입은 기존 값을 건드리지 않고 클로저에 이를 복사하는 반면,
    // non-copy 타입은 값 자체를 즉각적으로 클로저로 이동시킵니다.
    let consume = || {
        println!(&quot;`movable`: {:?}&quot;, movable);
        mem::drop(movable);
    };

    // `consume`은 변수를 소비하기 때문에(mem::drop), 한번만 호출될 수 있습니다.
    consume();

    // ERROR : 따라서 아래는 에러를 발생시킵니다.
    consume();
}
</code></pre></pre>
<p><code>move</code>를 사용하면 캡처된 변수의 소유권을 클로저가 갖도록 강제할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // `Vec`는 non-copy semantic들을 갖습니다.
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);

    println!(&quot;{}&quot;, contains(&amp;1));
    println!(&quot;{}&quot;, contains(&amp;4));

    // ERROR : `haystack`은 `moved` 되었으므로
    // 해당 변수 바인딩을 다시 사용할 수 없습니다.
    println!(&quot;There're {} elements in vec&quot;, haystack.len());
    
    // 위에서 구현한 클로저에서 `move`를 지우면,
    // 클로저가 `haystack`변수를 immutable하게 대여합니다.
    // 그러므로, 여전히 `haystack`은 이용가능한 상태이며,
    // 따라서 바로 위의 코드도 에러를 발생시키지 않습니다.
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="as-input-parameters"><a class="header" href="#as-input-parameters">As input parameters</a></h1>
<p>Rust는 대부분 타입 정의 없이 즉각적으로 변수를 캡처하는 방법을 택하지만, 이러한 모호성은 함수를 작성할 때는 허용되지 않습니다. 입력 파라미터로 클로저를 사용할 때, 클로저는 몇가지 트레이트 중 하나를 사용해 완전한 타입을 정의해야 합니다. </p>
<ul>
<li><code>Fn</code>: 참조로 클로저를 캡처(<code>&amp;T</code>)</li>
<li><code>FnMut</code> : mutable 참조로 클로저를 캡처(<code>&amp;mut T</code>)</li>
<li><code>FnOnce</code> : 값으로 클로저를 캡처(<code>T</code>)</li>
</ul>
<p>각 변수마다, 컴파일러는 가능한 제한이 적은 방식으로 변수를 캡처합니다. </p>
<p>예를 들어, 매개 변수가 <code>FnOnce</code>로 정의되었을 경우를 생각해봅시다. 이는 클로저가 <code>&amp;T</code>, <code>&amp;mut T</code> 또는 <code>T</code>로 캡처링 될 수 있음을 의미합니다. 그러나 컴파일러는 최종적으로 클로저 내에서 캡처링된 해당 변수가 어떻게 사용되느냐에 따라 어떤 방식을 사용할지를 결정합니다.</p>
<p>이는 이동(move)이 가능하다면, 어떤 형태의 대여(borrow)도 가능해야 하기 때문입니다. 이에 대한 역은 성립하지 않습니다. 만약 매개변수가 <code>Fn</code>으로 정해진다면, <code>&amp;mut T</code>나 <code>T</code>에 의한 변수 캡처링은 허용되지 않습니다.</p>
<p>아래 예시에서, <code>Fn</code>의 사용을 <code>FnMut</code>나 <code>FnOnce</code>로 바꾼 뒤 동작을 확인해보세요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 아래 함수는 클로저를 인자로 사용하여 호출합니다.
// `&lt;F&gt;`는 제네릭 타입 매개변수를 나타냅니다.
fn apply&lt;F&gt;(f: F) where
    // 해당 클로저는 아무 입출력(input/return)이 없습니다.
    F: FnOnce() {
    // 이 부분을 `Fn` 혹은 `FnMut`로 바꾸고 동작을 확인하세요.
    f();
}

// 클로저를 가져와 `i32`를 반환하는 함수입니다.
fn apply_to_3&lt;F&gt;(f: F) -&gt; i32 where
    // 해당 클로저는 i32 -&gt; i32로 동작합니다.
    F: Fn(i32) -&gt; i32 {

    f(3)
}

fn main() {
    use std::mem;

    let greeting = &quot;hello&quot;;
    // `greeting`은 non-copy 타입입니다.

    // `to_owned`은 빌려온 데이터를 바탕으로
    // 본인 소유의 데이터를 생성해냅니다.
    let mut farewell = &quot;goodbye&quot;.to_owned();

    // 두개의 변수를 캡쳐링 해봅시다.
    // `greeting`은 참조에 의해 캡처링되고
    // `farewell`은 값(value)에 의해 캡처링됩니다.
    let diary = || {
        // `greeting`은 참조에 의해 캡처링되며, 
        // 현재 이 클로저는 `Fn`이 요구됩니다.
        println!(&quot;I said {}.&quot;, greeting);

        // `farewell`은 mutable 참조에 의해 캡처됩니다.
        // 현재 이 클로저는 `FnMut`가 요구됩니다.
        farewell.push_str(&quot;!!!&quot;);
        println!(&quot;Then I screamed {}.&quot;, farewell);
        println!(&quot;Now I can sleep. zzzzz&quot;);

        // `drop`의 호출은 강제로 `farewell`이
        // 값(value)에 의해 캡처링되도록 만듭니다.
        // 최종적으로 이 클로저는 `FnOnce`가 요구됩니다.
        mem::drop(farewell);
    };

    // 클로저가 적용된 함수를 호출합니다.
    apply(diary);

    // `double`은 `apply_to_3`의 트레이트 바운드를 충족시킵니다.
    let double = |x| 2 * x;

    println!(&quot;3 doubled: {}&quot;, apply_to_3(double));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="type-anonymity"><a class="header" href="#type-anonymity">Type anonymity</a></h1>
<p>클로저는 스코프를 폐쇄함으로써 간단하게 변수들을 캡처합니다. 이 방법에도 단점이 있을까요? 당연히 그렇습니다. 클로저를 함수의 매개변수로 사용하는 경우, 제네릭이 어떻게 정의되는지 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unused)]
fn main() {
  // `F`는 반드시 제네릭이어야 합니다.
  fn apply&lt;F&gt;(f: F) where
      F: FnOnce() {
      f();
  }
}
</code></pre></pre>
<p>클로저가 정의될 때, 컴파일러는 캡처된 변수들을 담을 새로운 익명 구조를 내부적으로 생성합니다. 한편, <code>Fn</code>, <code>FnMut</code> 또는 <code>FnOnce</code>와 같이 여러 트레이트 중 하나로 함수에 대한 구현을 수행합니다. 이러한 타입은 호출되기 전까지 캡처된 변수에 할당됩니다.</p>
<p>이러한 새 타입은 알수없는 타입이기 때문에, 함수 내에서의 사용은 제네릭이 요구됩니다. 그러나, 무한한 타입 매개변수 <code>&lt;T&gt;</code>는 여전히 애매한 형태이기 때문에, 허용되지 않습니다. 따라서, 트레이트 중 하나(<code>Fn</code>, <code>FnMut</code>, <code>FnOnce</code>)로 그 타입을 지정해주어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 아무런 입력/반환이 존재하지 않는 클로저의 경우
// `F`는 반드시 `Fn`을 구현해야 합니다.
fn apply&lt;F&gt;(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 익명타입으로 `x`를 캡처하고
    // 이에 대해 `Fn`으로 구현합니다.
    // 이는 `print`에 저장됩니다.
    let print = || println!(&quot;{}&quot;, x);

    apply(print);
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="input-functions"><a class="header" href="#input-functions">Input functions</a></h1>
<p>앞에서 살펴본 것처럼, 클로저는 함수의 매개변수로 사용될 수 있습니다. 그렇다면 이 경우에 함수도 매개변수로 사용될 수 있을까요? 실제로 사용이 가능합니다! 만약 클로저를 매개변수로 받는 함수를 정의한다면, 해당 클로저의 트레이트 제한(trait bound)를 만족하는 어떤 함수든지 매개변수로 전달될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 제네릭 `F` 인자를 갖는 함수를 정의합니다.
// 이는 `Fn`으로 제한됩니다.
fn call_me&lt;F: Fn()&gt;(f: F) {
    f();
}

// `Fn` 규격을 만족하는 새로운 함수를 정의합니다.
fn function() {
    println!(&quot;I'm a function!&quot;);
}

fn main() {
    // `Fn` 규격을 만족하는 새로운 클로저를 정의합니다.
    let closure = || println!(&quot;I'm a closure!&quot;);

    call_me(closure);
    call_me(function);
}
</code></pre></pre>
<p>추가적인 참고 사항으로, <code>Fn</code>, <code>FnMut</code>, 그리고 <code>FnOnce</code> 트레이트는 닫힌 스코프로부터 변수를 어떤 식으로 캡처할지에 대한 방법을 지시합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="as-output-parameters"><a class="header" href="#as-output-parameters">As output parameters</a></h1>
<p>클로저는 입력 매개변수로 사용될 수 있습니다. 따라서 반환되는 결과로도 사용될 수 있어야 합니다. 그러나, 익명 클로저 타입은 정의 상 unknown에 해당하며, 이를 반환 타입으로 사용하기 위해선 <code>impl Trait</code>를 사용해야 합니다.</p>
<p>클로저를 반환하기 위해 사용 가능한 트레이트에는 다음과 같은 것들이 있습니다.</p>
<ul>
<li><code>Fn</code></li>
<li><code>FnMut</code></li>
<li><code>FnOnce</code></li>
</ul>
<p>그 밖에도, 모든 캡처들이 값(value)에 의해 발생함을 나타내는 <code>move</code> 키워드가 사용되어야 합니다. 참조에 의해 발생하는 모든 캡처들은 클로저 내에 부정확한 참조들을 남겨놓고 함수가 종료되는대로 사라지기 때문입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn create_fn() -&gt; impl Fn() {
    let text = &quot;Fn&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnmut() -&gt; impl FnMut() {
    let text = &quot;FnMut&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn create_fnonce() -&gt; impl FnOnce() {
    let text = &quot;FnOnce&quot;.to_owned();

    move || println!(&quot;This is a: {}&quot;, text)
}

fn main() {
    let fn_plain = create_fn();
    let mut fn_mut = create_fnmut();
    let fn_once = create_fnonce();

    fn_plain();
    fn_mut();
    fn_once();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="examples-in-a-hrefhttpsdocrust-langorgrust-by-examplefnclosuresclosure_exampleshtmlexamples-in-stdstda"><a class="header" href="#examples-in-a-hrefhttpsdocrust-langorgrust-by-examplefnclosuresclosure_exampleshtmlexamples-in-stdstda">Examples in <a href="https://doc.rust-lang.org/rust-by-example/fn/closures/closure_examples.html#examples-in-std">std</a></a></h1>
<p>해당 섹션은 <code>std</code> 라이브러리에서 사용되는 클로저의 몇가지 사례에 대해 담고 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iteratorany"><a class="header" href="#iteratorany">Iterator::any</a></h1>
<p><code>Iterator::any</code>는 iterator가 넘겨졌을 때, 특정 하나의 요소라도 조건을 만족하면 <code>true</code>를, 그외에는 <code>false</code>를 반환해주는 함수입니다. </p>
<p>이는 아래와 같이 구성되어, 클로저를 활용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    // 순회될 대상의 타입입니다.
    type Item;

    // `any`는 `&amp;mut self`를 가져옵니다.
    // 즉, 해당 함수의 호출은 스스로에 대한 참조를 빌려오고, 수정합니다.
    // 하지만, 소비(consume)하지는 않습니다.
    fn any&lt;F&gt;(&amp;mut self, f: F) -&gt; bool where
        // `FnMut`은 캡처된 변수가 수정될 수 있으나, 소비되지 않음을 의미합니다.
        // `Self::Item`은 인수를 받아 값(value)을 통해 클로저에 추가함을 의미합니다.
        F: FnMut(Self::Item) -&gt; bool {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `vec`의 `iter()`는 `&amp;i32`를 만듭니다.
    // 이는 `i32`로 구조 분해 될 수 있습니다.
    println!(&quot;2 in vec1: {}&quot;, vec1.iter()     .any(|&amp;x| x == 2));
    // `vec`의 `into_iter()`는 `i32`를 만듭니다.
    // 이 경우, 구조 분해가 필요없습니다. (그 자체가 값입니다.)
    println!(&quot;2 in vec2: {}&quot;, vec2.into_iter().any(| x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `array`의 `iter()`는 `&amp;i32`를 만듭니다.
    println!(&quot;2 in array1: {}&quot;, array1.iter()     .any(|&amp;x| x == 2));
    // `array`의 `into_iter()`는 예외적으로 `&amp;i32`를 만듭니다.
    println!(&quot;2 in array2: {}&quot;, array2.into_iter().any(|&amp;x| x == 2));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="searching-through-iterators"><a class="header" href="#searching-through-iterators">Searching through iterators</a></h1>
<p><code>Iterator::find</code>는 순회 가능한 구조 객체들을 순회하며, 특정 조건을 만족하는 첫번째 값을 탐색하여 반환하는 함수입니다. 만약, 아무 값도 찾지 못했다면 <code>None</code>을 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Iterator {
    // 순회될 대상 타입
    type Item;

    // `find`는 `&amp;mut self`를 받아서 사용합니다.
    // 즉, 해당 메서드의 호출은 인스턴스 본인에 대한 참조를
    // 대여하고 수정하지만, 소모하지는 않습니다.
    fn find&lt;P&gt;(&amp;mut self, predicate: P) -&gt; Option&lt;Self::Item&gt; where
        // `FnMut`는 캡처된 값이 수정될 순 있으나, 소모되진 않음을 의미합니다.
        // `&amp;Self::Item`은 인수를 참조를 바탕으로 클로저에 보관함을 의미합니다.
        P: FnMut(&amp;Self::Item) -&gt; bool {}
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let vec1 = vec![1, 2, 3];
    let vec2 = vec![4, 5, 6];

    // `vec`의 `iter()`는 `&amp;i32`가 생성됩니다.
    let mut iter = vec1.iter();
    // `vec`의 `into_iter()`는 `i32`가 생성됩니다.
    let mut into_iter = vec2.into_iter();

    // `vec`의 `iter()`는 `&amp;i32`를 생성합니다.
    // 그리고 우리는 각 요소들에 대한 레퍼런스를 참조하고자 합니다.
    // 따라서 `&amp;&amp;i32`를 통한 구조분해로 `i32`를 사용해야 합니다.
    println!(&quot;Find 2 in vec1: {:?}&quot;, iter     .find(|&amp;&amp;x| x == 2));

    // `vec`의 `into_iter()`는 `i32`를 생성합니다.
    // 그리고 우리는 각 요소들에 대한 레퍼런스를 참조하고자 합니다.
    // 따라서 `&amp;i32`을 통한 구조 분해로 `i32`를 사용합니다.
    println!(&quot;Find 2 in vec2: {:?}&quot;, into_iter.find(| &amp;x| x == 2));

    let array1 = [1, 2, 3];
    let array2 = [4, 5, 6];

    // `array`의 `iter()`는 `&amp;i32`를 생성합니다.
    println!(&quot;Find 2 in array1: {:?}&quot;, array1.iter()     .find(|&amp;&amp;x| x == 2));
    // `array`의 `into_iter()`는 예외적으로 `&amp;i32`를 생성합니다.
    println!(&quot;Find 2 in array2: {:?}&quot;, array2.into_iter().find(|&amp;&amp;x| x == 2));
}
</code></pre></pre>
<p><code>Iterator::find</code>는 발견한 요소에 대한 참조를 제공합니다. 만약, 참조가 아닌 요소에 대한 인덱스가 필요한 경우라면, <code>Iterator::position</code>을 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let vec = vec![1, 9, 3, 3, 13, 2];

    let index_of_first_even_number = vec.iter().position(|x| x % 2 == 0);
    assert_eq!(index_of_first_even_number, Some(5));
    
    let index_of_first_negative_number = vec.iter().position(|x| x &lt; &amp;0);
    assert_eq!(index_of_first_negative_number, None);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="higher-order-functions"><a class="header" href="#higher-order-functions">Higher Order Functions</a></h1>
<p>Rust는 고차 함수(HOF)를 제공합니다. 이는 하나 이상의 함수를 가져와 더 유용한 함수를 생성해내기 위한 함수입니다. 고차함수와 lazy iterator는 Rust에 함수형 프로그래밍의 맛을 부여합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn is_odd(n: u32) -&gt; bool {
    n % 2 == 1
}

fn main() {
    println!(&quot;Find the sum of all the squared odd numbers under 1000&quot;);
    let upper = 1000;

    // 명령형 프로그래밍으로 접근
    // `acc` 변수를 정의합니다.
    let mut acc = 0;
    // 0, 1, 2, ... infinity
    for n in 0.. {
        // 수의 제곱
        let n_squared = n * n;

        if n_squared &gt;= upper {
            // 상한을 넘기게 되면 루프를 멈춥니다.
            break;
        } else if is_odd(n_squared) {
            // 홀수라면 값을 더합니다.
            acc += n_squared;
        }
    }
    println!(&quot;imperative style: {}&quot;, acc);

    // 함수형 프로그래밍으로 접근
    let sum_of_squared_odd_numbers: u32 =
        (0..).map(|n| n * n) // 모든 자연수에 제곱을 적용합니다.
             .take_while(|&amp;n_squared| n_squared &lt; upper) // 상한을 지정합니다.
             .filter(|&amp;n_squared| is_odd(n_squared))     // 홀수 여부를 판단합니다.
             .fold(0, |acc, n_squared| acc + n_squared); // 이들을 더합니다.
    println!(&quot;functional style: {}&quot;, sum_of_squared_odd_numbers);
}
</code></pre></pre>
<p>Option과 Iterator는 HOF를 굉장히 많이 사용하게 됩니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="diverging-functions"><a class="header" href="#diverging-functions">Diverging functions</a></h1>
<p>Diverging funciton(발산 함수)는 값을 <em>절대</em> 반환하지 않는 함수입니다. 이는 <code>!</code>를 통해 표시되며, 이는 <em>비어있음</em>을 의미하는 타입입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(unused)]
fn main() {
  fn foo() -&gt; ! {
      panic!(&quot;This call never returns.&quot;);
  }
}
</code></pre></pre>
<p>다른 모든 타입들과는 다르게, 해당 함수는 인스턴스화될 수 없습니다. 해당 타입이 가질 수 있는 모든 가능한 값의 집합은 비어있기 때문입니다. 유닛 <code>()</code> 타입과는 다르다는 점을 기억하세요. <code>()</code>는 실제로는 가능한 값이 하나 존재함을 의미합니다.</p>
<p>예를 들어, 아래 함수는 별 다른 정보를 담고 있지 않지만, 일반적인 형태로 값을 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn some_fn() {
    ()
}

fn main() {
    let a: () = some_fn();
    println!(&quot;This function returns and you can see this line.&quot;)
}
</code></pre></pre>
<p>반면, 아래 함수는 호출 시에 말 그대로 아무 값도 반환하지 않습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![feature(never_type)]

fn main() {
    let x: ! = panic!(&quot;This call never returns.&quot;);
    println!(&quot;You will never see this line!&quot;);
}
</code></pre></pre>
<p>제법 추상적인 개념으로 보이긴 하지만, 이는 사실 굉장히 유용합니다. 해당 타입을 이용하는 경우의 주된 장점은, 정확한 타입이 요구되는 모든 부분에서 활용될 수 있다는 것입니다. 이를테면, match 분기에 대한 예를 들어볼 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    fn sum_odd_numbers(up_to: u32) -&gt; u32 {
        let mut acc = 0;
        for i in 0..up_to {
            // `addtion` 변수의 타입에 의해서,
            // match 문에서 반환되는 타입은 반드시 u32이어야 합니다.
            let addition: u32 = match i%2 == 1 {
                // `i` 변수는 `u32` 타입이기 때문에, 문제 없습니다.
                true =&gt; i,

                // 반면 `continue` 문은 `u32`를 반환하지 않습니다.
                // 하지만 문제 없습니다. 
                // 애초에 아무 것도 반환하지 않기 때문에,
                // match 문에서의 타입 조건을 해치지 않습니다.
                false =&gt; continue,
            };
            acc += addition;
        }
        acc
    }
    println!(&quot;Sum of odd numbers up to 9 (excluding): {}&quot;, sum_odd_numbers(9));
}
</code></pre></pre>
<p>이러한 형태의 함수는 네트워크 서버와 같이 끊임없이 루프가 동작해야 하는 경우(<code>loop {}</code>)나, 프로세스를 종료하는 경우(<code>exit()</code>)에서 살펴볼 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Rust는 로직 단위로 코드를 구조적으로 분리하고, 그들 사이의 가시성(public/private)을 관리하기 위한 강력한 모듈 시스템을 제공합니다.</p>
<p>모듈은 여러 항목의 컬렉션입니다. : 함수, 구조, 트레이트, <code>impl</code> 블럭, 등등..</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="visibility"><a class="header" href="#visibility">Visibility</a></h1>
<p>기본적으로, 모듈 내의 각 항목들은 private 가시성을 갖습니다. 그러나 이는 <code>pub</code> 수정자를 통해 public으로 오버라이딩될 수 있습니다. 오직 모듈의 public 항목들에만 모듈 스코프 바깥에서 접근할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `my_mod` 라는 이름의 모듈입니다.
mod my_mod {
    // 모듈 내의 항목들은 기본적으로 `private` 가시성을 갖습니다.
    fn private_function() {
        println!(&quot;called `my_mod::private_function()`&quot;);
    }

    // 가시성을 `public`으로 바꾸기 위해 `pub` 수정자로 오버라이딩합니다.
    pub fn function() {
        println!(&quot;called `my_mod::function()`&quot;);
    }

    // 동일한 모듈 내의 각 항목들은 private 여부와 상관없이 서로 접근할 수 있습니다.
    pub fn indirect_access() {
        print!(&quot;called `my_mod::indirect_access()`, that\n&gt; &quot;);
        private_function();
    }

    // 모듈은 중첩될 수 있습니다.
    pub mod nested {
        pub fn function() {
            println!(&quot;called `my_mod::nested::function()`&quot;);
        }

        #[allow(dead_code)]
        fn private_function() {
            println!(&quot;called `my_mod::nested::private_function()`&quot;);
        }

        // `pub(in path)`로 선언된 함수는 오직 주어진 경로에서만 가시적입니다.
        // 해당 `path`는 반드시 부모 혹은 조상 모듈이어야 합니다.
        pub(in crate::my_mod) fn public_function_in_my_mod() {
            print!(&quot;called `my_mod::nested::public_function_in_my_mod()`, that\n&gt; &quot;);
            public_function_in_nested();
        }

        // `pub(self)`로 선언된 함수는 오직 본인 모듈에서만 가시적입니다.
        // 이는 사실 상 private 상태로 두는 것과 동일합니다.
        pub(self) fn public_function_in_nested() {
            println!(&quot;called `my_mod::nested::public_function_in_nested()`&quot;);
        }

        // `pub(super)`로 선언된 함수는 부모 모듈 내에서만 가시적입니다.
        pub(super) fn public_function_in_super_mod() {
            println!(&quot;called `my_mod::nested::public_function_in_super_mod()`&quot;);
        }
    }

    pub fn call_public_function_in_my_mod() {
        print!(&quot;called `my_mod::call_public_function_in_my_mod()`, that\n&gt; &quot;);
        nested::public_function_in_my_mod();
        print!(&quot;&gt; &quot;);
        nested::public_function_in_super_mod();
    }

    // `pub(crate)`로 선언된 함수는 현재 크레이트내에서만 가시적입니다. 
    pub(crate) fn public_function_in_crate() {
        println!(&quot;called `my_mod::public_function_in_crate()`&quot;);
    }

    // 중첩 모듈은 가시성에 대해 동일한 규칙을 따릅니다.
    mod private_nested {
        #[allow(dead_code)]
        pub fn function() {
            println!(&quot;called `my_mod::private_nested::function()`&quot;);
        }

        // Private한 부모 항목들은 자식 항목들의 가시성에도 영향을 미칩니다.
        // 심지어 자식 항목에 `pub`이 수정자가 적용되더라도 말이죠.
        #[allow(dead_code)]
        pub(crate) fn restricted_function() {
            println!(&quot;called `my_mod::private_nested::restricted_function()`&quot;);
        }
    }
}

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    // 모듈은 동일한 이름을 가진 항목을 구분하여 사용할 수 있게끔 합니다.
    function();
    my_mod::function();

    // 중첩 모듈 내에 포함된 Public 항목들은 부모 모듈 바깥에서 접근할 수 있다.
    my_mod::indirect_access();
    my_mod::nested::function();
    my_mod::call_public_function_in_my_mod();

    // pub(crate) 항목들은 동일한 크레이트 내 어디서든 호출될 수 있습니다.
    my_mod::public_function_in_crate();

    // ERROR : `pub(in path)` 항목들은 지정된 모듈 내에서만 호출할 수 있습니다.
    my_mod::nested::public_function_in_my_mod();

    // private 항목들에는 직접 접근할 수 없습니다.
    // 심지어 public 모듈 내에 중첩되어 있더라도 마친가지입니다.

    // ERROR : private 항목들은 직접 접근할 수 없습니다.
    my_mod::private_function();

    // ERROR : `nested`는 public 모듈이지만,
    // 그 안에 중첩된 private 항목에는 접근할 수 없습니다.
    my_mod::nested::private_function();

    // ERROR : `private_nested`는 private 모듈입니다.
    // `function`이 public 으로 선언되더라도, 접근할 수 없습니다.
    my_mod::private_nested::function();

    // ERROR : `private_nested`는 private 모듈입니다.
    // `function`이 `pub(crate)`로 선언되더라도, 접근할 수 없습니다.
    my_mod::private_nested::restricted_function();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="struct-visibility"><a class="header" href="#struct-visibility">Struct visibility</a></h1>
<p>Struct는 본인의 필드에 대한 추가적인 가시성을 보유합니다. 이는 기본적으로 private로 설정되며, 마찬가지로 <code>pub</code> 수정자를 통해 오버라이딩될 수 있습니다.</p>
<p>이러한 가시성은 정의된 모듈의 외부에서 해당 struct에 접근할 때만 고려되며, 내부 정보를 숨기려는 목적을 갖고 있습니다(캡슐화).</p>
<pre><pre class="playground"><code class="language-rust edition2018">mod my {
    // 제네릭 타입 `T`의 public 필드를 가진 public 구조
    pub struct OpenBox&lt;T&gt; {
        pub contents: T,
    }

    // 제네릭 타입 `T`의 private 필드를 가진 public 구조
    #[allow(dead_code)]
    pub struct ClosedBox&lt;T&gt; {
        contents: T,
    }

    impl&lt;T&gt; ClosedBox&lt;T&gt; {
        // public 생성자 메서드
        pub fn new(contents: T) -&gt; ClosedBox&lt;T&gt; {
            ClosedBox {
                contents: contents,
            }
        }
    }
}

fn main() {
    // public 필드를 가진 public 구조는 평소와 같이 생성됩니다.
    let open_box = my::OpenBox { contents: &quot;public information&quot; };

    // 또한  해당 public 필드에도 정상적으로 접근할 수 있습니다.
    println!(&quot;The open box contains: {}&quot;, open_box.contents);

    // ERROR : private 필드를 가진 public 구조는 
    // 해당 private 필드를 사용하여 직접 생성할 수 없습니다.
    let closed_box = my::ClosedBox { contents: &quot;classified information&quot; };

    // 대신, private 필드를 가진 구조의 경우
    // public 생성자를 통해 구조를 생성할 수 있습니다.
    let _closed_box = my::ClosedBox::new(&quot;classified information&quot;);

    // ERROR : public 구조의 private 필드에는 접근할 수 없습니다.
    println!(&quot;The closed box contains: {}&quot;, _closed_box.contents);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-use-declaration"><a class="header" href="#the-use-declaration">The use declaration</a></h1>
<p><code>use</code> 선언은 모듈의 더 쉬운 접근을 위하여, 전체 경로를 새로운 이름으로 바인딩하기 위해 사용됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use crate::deeply::nested::{
    my_first_function,
    my_second_function,
    AndATraitType
};

fn main() {
    // 이제 `crate::deply::nested::my_first_function`이 아닌
    // `my_first_function`으로 접근할 수 있습니다.
    my_first_function();
}
</code></pre></pre>
<p><code>as</code> 키워드와 함께 사용하여 다른 이름으로 바인딩하여 가져올 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `deeply::nested::function` 경로를 `other_function`으로 바인딩합니다.
use deeply::nested::function as other_function;

fn function() {
    println!(&quot;called `function()`&quot;);
}

mod deeply {
    pub mod nested {
        pub fn function() {
            println!(&quot;called `deeply::nested::function()`&quot;);
        }
    }
}

fn main() {
    // `deeply::nested::function`은 이제 `other_function`으로 호출할 수 있습니다.
    other_function();

    println!(&quot;Entering block&quot;);
    {
        // 아래는 `use deeply::nested::function as function`과 동일합니다.
        // 이는 최상단에서 선언한 `function()`을 덮어쓰게 됩니다.
        use crate::deeply::nested::function;

        // `use` 바인딩은 로컬 스코프를 갖습니다.
        // 즉, 위에서 섀도잉한 `function`은 해당 블록에서만 유효합니다.
        function();

        println!(&quot;Leaving block&quot;);
    }

    function();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="super-and-self"><a class="header" href="#super-and-self">super and self</a></h1>
<p><code>super</code> 와 <code>self</code> 키워드는 항목에 접근할 때의 모호함을 없애고 path를 작성할 때의 불필요한 하드코딩을 막아줍니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn function() {
    println!(&quot;called `function()`&quot;);
}

mod cool {
    pub fn function() {
        println!(&quot;called `cool::function()`&quot;);
    }
}

mod my {
    fn function() {
        println!(&quot;called `my::function()`&quot;);
    }
    
    mod cool {
        pub fn function() {
            println!(&quot;called `my::cool::function()`&quot;);
        }
    }
    
    pub fn indirect_call() {
        // 이 스코프에서 접근할 수 있는 모든 `function` 함수들을 호출해봅시다!
        print!(&quot;called `my::indirect_call()`, that\n&gt; &quot;);
        
        // `self` 키워드는 현재의 모듈 스코프를 참조합니다. 여기선 `my`입니다.
        // `self::function()`와 해당 스코프에서의 `function()`는
        // 동일한 함수를 호출하기 때문에, 그 결과도 동일합니다.
        self::function();
        function();
        
        // `my` 모듈 내에서의 다른 항목에 접근하기 위해서도 `self`를 사용할 수 있습니다.
        self::cool::function();
        
        // `super` 키워드는 `my` 모듈 바깥의 부모 스코프를 참조합니다.
        super::function();
        
        // 아래는 `cool::function`을 *crate* 스코프에 바인딩합니다.
        // 여기서의 crate 스코프는 가장 바깥의 소코프가 됩니다.
        {
            use crate::cool::function as root_function;
            root_function();
        }
    }
}

fn main() {
    my::indirect_call();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="file-hierarchy"><a class="header" href="#file-hierarchy">File hierarchy</a></h1>
<p>모듈은 파일 혹은 디렉토리 구조에 매핑될 수 있습니다. 다음과 같은 파일 구조가 있다고 가정해봅시다.</p>
<pre><code class="language-bash">$ tree .
.
|-- my
|   |-- inaccessible.rs
|   |-- mod.rs
|   `-- nested.rs
`-- split.rs
</code></pre>
<p><code>split.rs</code>는 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 아래 선언은 `my.rs` 또는 `my/mod.rs` 파일을 탐색합니다.
// 탐색한 이후, 현재 스코프의 `my`라는 이름의 모듈에 해당 파일의 내용을 삽입합니다.
mod my;

fn function() {
    println!(&quot;called `function()`&quot;);
}

fn main() {
    my::function();

    function();

    my::indirect_access();

    my::nested::function();
}
</code></pre></pre>
<p><code>my/mod.rs</code>는 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `mod inaccessible`과 `mod nested`도 각자
// `nested.rs`와 `inaccessible.rs` 파일은 찾아
// 현재 스코프의 모듈에 해당 파일의 내용을 삽입합니다.
mod inaccessible;
pub mod nested;

pub fn function() {
    println!(&quot;called `my::function()`&quot;);
}

fn private_function() {
    println!(&quot;called `my::private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called `my::indirect_access()`, that\n&gt; &quot;);

    private_function();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>my/nested.rs</code>는 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn function() {
    println!(&quot;called `my::nested::function()`&quot;);
}

#[allow(dead_code)]
fn private_function() {
    println!(&quot;called `my::nested::private_function()`&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>my/inaccessible.rs</code>는 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[allow(dead_code)]
pub fn public_function() {
    println!(&quot;called `my::inaccessible::public_function()`&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>이제 <code>split.rs</code>를 컴파일함으로써 여기저기 흩어진 모듈들이 정상적으로 동작하는지 확인해봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>$ rustc split.rs &amp;&amp; ./split
called `my::function()`
called `function()`
called `my::indirect_access()`, that
&gt; called `my::private_function()`
called `my::nested::function()`
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="crates"><a class="header" href="#crates">Crates</a></h1>
<p>**크레이트(Crate)**는 Rust에서의 컴파일 유닛입니다. <code>rustc some_file.rs</code>가 실행될 때, <code>some_file.rs</code>가 바로 크레이트 파일로 취급됩니다. 만약 <code>some_file.rs</code> 내에 <code>mod</code> 선언이 존재한다면, 컴파일이 수행되기 전에, 해당 모듈의 내용도 크레이트 파일 내의 <code>mod</code>이 선언된 부분에 추가됩니다. 즉, 컴파일링은 모듈 각각에 대해 전부 수행되는 것이 아니라, 크레이트 파일에 대해서만 수행됩니다.</p>
<p>크레이트는 바이너리 혹은 라이브러리로 컴파일링 될 수 있습니다. 기본적으로 <code>rustc</code>는 크레이트로부터 바이너리를 생성합니다. 만약, 라이브러리로 컴파일하고 싶다면, <code>--crate-type</code> 플래그를 <code>lib</code>로 설정하여 오버라이딩을 하면 됩니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="creating-a-library"><a class="header" href="#creating-a-library">Creating a Library</a></h1>
<p>크레이트를 통해 라이브러리를 만들어봅시다. 그리고 나서 해당 크레이트가 어떻게 다른 크레이트와 연결되는지 확인해봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-bash">$ rustc --crate-type=lib rary.rs
$ ls lib*
library.rlib
</code></pre>
<p>라이브러리에는 <code>lib</code> 접두사가 붙습니다. 라이브러리 파일은 기본적으로 그들 크레이트 파일의 이름을 따서 이름 지어집니다. 이러한 기본 파일명은 <code>rustc</code>의 <code>--crate-name</code> 옵션 혹은 <code>crate_name</code> 어트리뷰트를 사용하여 오버라이딩될 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="using-a-library"><a class="header" href="#using-a-library">Using a Library</a></h1>
<p><code>rustc</code>의 <code>--extern</code> 플래그를 사용하면 크레이트를 새로운 라이브러리와 연결할 수 있습니다. 이 경우, 라이브러리와 동일한 이름의 모듈을 모두 가져오게 됩니다. 이 모듈은 일반적으로 다른 모듈과 동일한 방식으로 동작합니다.</p>
<p>이전 섹션에서 생성했던 라이브러리를 다시 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// rary.rs
pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
<span class="boring">}
</span></code></pre></pre>
<p>아래는 위의 라이브러리를 사용하고자 하는 크레이트 파일입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// executable.rs
// 아래 명령어는 Rust의 2015 이전 버전에서 요구됩니다.
// extern crate rary;

fn main() {
    rary::public_function();

    // 라이브러리 내 private 함수의 경우 여전히 private하게 취급됩니다.
    // rary::private_function();

    rary::indirect_access();
}
</code></pre></pre>
<pre><code class="language-bash"># library.rlib이 컴파일된 라이브러리의 경로입니다. 여기선 동일한 디렉토리 내에 위치한다고 가정하겠습니다.
$ rustc executable.rs --extern rary=library.rlib --edition=2018 &amp;&amp; ./executable 
called rary's `public_function()`
called rary's `indirect_access()`, that
&gt; called rary's `private_function()`
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cargo"><a class="header" href="#cargo">Cargo</a></h1>
<p><code>cargo</code>는 Rust의 공식 패키지 관리 툴입니다. 코드 퀄리티를 향상하고 개발 속도를 향상 시키기 위한 여러 유용한 기능들을 갖추고 있습니다.</p>
<ul>
<li><a href="https://crates.io/">crates.io</a>(공식 Rust 패키지 레지스트리)를 통한 의존성 관리 및 실행</li>
<li>유닛 테스트</li>
<li>벤치마크</li>
</ul>
<p>이번 챕터에서는 간단한 기초에 대해서만 배워보겠습니다. <a href="https://doc.rust-lang.org/cargo/">The Cargo Book</a>에서 더 상세한 문서로 살펴볼 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h1>
<p>대부분의 프로그램은 여러 라이브러리에 의존성을 갖고 있습니다. 만약 일일이 의존성을 관리했던 경험이 있다면, 그것이 얼마나 힘든 일인지 알고 계실 겁니다. 다행히도, Rust 생태계는 <code>cargo</code>를 기반으로 구축되어 있습니다! <code>cargo</code>가 프로젝트의 의존성을 관리해줄 수 있습니다.</p>
<p>Rust 프로젝트를 생성해봅시다.</p>
<pre><code class="language-bash"># 바이너리 프로젝트를 생성합니다.
cargo new foo

# 또는 라이브러리 프로젝트를 생성합니다.
cargo new --lib foo 
</code></pre>
<p>해당 챕터의 나머지 부분에서, 저희는 바이너리 프로젝트를 기반으로 한다고 가정하겠습니다. 하지만 전반적인 컨셉 자체는 모두 동일합니다.</p>
<p>위의 명령을 실행하고 나면, 아래와 같은 파일 구조를 확인할 수 있습니다.</p>
<pre><code>foo
├── Cargo.toml
└── src
    └── main.rs

</code></pre>
<p><code>main.rs</code>는 (특별할 것 없는) 새로운 프로젝트의 루트 소스 파일입니다. <code>Cargo.toml</code>은 해당 프로젝트(<code>foo</code>)에 대한 <code>cargo</code> 설정파일입니다. 이를 살펴보면, 아래와 같은 내용을 확인할 수 있습니다.</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
</code></pre>
<p><code>[package]</code> 아래의 <code>name</code> 필드는 프로젝트의 이름을 결정합니다. 이는 추후에 크레이트를 배포하는 경우 <code>crate.io</code>에 의해 사용됩니다. 컴파일 시에 출력되는 바이너리의 이름이기도 합니다.</p>
<ul>
<li>
<p><code>version</code> 필드는 <a href="https://semver.org/">Semantic Versioning</a>에 따른 크레이트 버전을 나타냅니다.</p>
</li>
<li>
<p><code>authors</code> 필드는 크레이트를 배포할 때 사용되는 작성자들의 리스트입니다.</p>
</li>
<li>
<p><code>[dependencies]</code> 섹션에는 프로젝트에 사용되는 모든 의존성이 추가됩니다.</p>
</li>
</ul>
<p>예를 들어, 어마어마한 CLI 프로그램을 개발하려 한다고 가정해봅시다. <a href="https://crates.io/">crate.io</a>에서 여러가지 굉장한 패키지를 찾을 수 있습니다. 그 중 인기있는 하나는 <a href="https://crates.io/crates/clap">clap</a>입니다. 현재 <code>clap</code>의 최신 버전은 <code>2.27.1</code>입니다. 저희 프로젝트에 해당 의존성을 추가하기 위해선, <code>Cargo.toml</code>의 <code>[dependencies]</code>에 단순히 <code>clap = &quot;2.27.1&quot;</code>을 추가하기만 하면 됩니다. 이제 <code>clap</code>을 프로젝트에서 사용할 수 있습니다!</p>
<p><code>cargo</code>는 [다른 종류의 의존성]도 지원합니다. 아래는 간단한 예시입니다.</p>
<pre><code class="language-toml">[package]
name = &quot;foo&quot;
version = &quot;0.1.0&quot;
authors = [&quot;mark&quot;]

[dependencies]
clap = &quot;2.27.1&quot; # crates.io 의존성
rand = { git = &quot;https://github.com/rust-lang-nursery/rand&quot; } # 온라인 저장소
bar = { path = &quot;../bar&quot; } # 로컬 파일시스템
</code></pre>
<p><code>cargo</code>는 단순한 의존성 관리자 그 이상의 역할을 수행합니다. <code>Cargo.toml</code>에서 활용할 수 있는 모든 설정 옵션들은 <a href="https://doc.rust-lang.org/cargo/reference/manifest.html">여기</a>에서 찾아볼 수 있습니다.</p>
<p>프로젝트를 빌드하기 위해서는 프로젝트 디렉토리 내 어디서든 <code>cargo build</code>를 실행하면 됩니다. <code>cargo run</code>을 실행하면 빌드와 구동을 한꺼번에 합니다. 이러한 명령들은 모든 종속성을 해결하고, 필요한 경우 크레이트를 다운로드하며, 우리 프로젝트의 크레이트를 포함한 모든 것을 빌드해줍니다. (이는 <code>make</code> 명령과 비슷하게, 이미 빌드되지 않은 사항에 대해서만 다시 빌드를 수행합니다.)</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="conventions"><a class="header" href="#conventions">Conventions</a></h1>
<p>이전 챕터에서, 다음의 디렉토리 구조들을 살펴봤습니다.</p>
<pre><code>foo
├── Cargo.toml
└── src
    └── main.rs
</code></pre>
<p>만약, 동일한 프로젝트 내에서, 두개의 바이너리를 생성하고 싶다면 어떻게 해야할까요?</p>
<p><code>cargo</code>가 이를 해결해줄 수 있습니다. 앞서 확인한 것처럼, 기본 바이너리의 이름은 <code>main</code>입니다. 그러나 <code>bin/</code> 디렉토리에 또 다른 바이너리를 추가할 수 있습니다.</p>
<pre><code>foo
├── Cargo.toml
└── src
    ├── main.rs
    └── bin
        └── my_other_bin.rs
</code></pre>
<p><code>cargo</code>에게 기본 바이너리 대신에 해당 바이너리를 컴파일하고, 실행하고 싶다면, <code>cargo</code>에 <code>--bin my_other_bin</code> 플래그를 전달하면 됩니다. <code>my_other_bin</code>은 작업을 수행하고자 하는 바이너리의 이름입니다.</p>
<p>추가적인 바이너리에 대해, <code>cargo</code>는 벤치마크, 테스트 등 <a href="https://doc.rust-lang.org/cargo/guide/project-layout.html">더 많은 기능</a>들을 제공하고 있습니다. </p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>테스트는 모든 소프트웨어에 필수적입니다. Rust는 유닛 및 통합테스트에 대해 최고 수준으로 지원하고 있습니다.</p>
<p>간단한 유닛 테스트와 통합 테스트를 어떻게 작성하는지에 대해 살펴봅시다. 구조적으로, 우리는 수행할 테스트를 <code>tests/</code> 디렉토리에 위치시킬 수 있습니다.</p>
<pre><code>foo
├── Cargo.toml
├── src
│   └── main.rs
└── tests
    ├── my_test.rs
    └── my_other_test.rs
</code></pre>
<p><code>tests</code>의 각 파일은 분리된 통합 테스트입니다.</p>
<p><code>cargo</code>는 모든 테스트를 실행하는 가장 간단한 방법을 제공합니다.</p>
<pre><code class="language-bash">$ cargo test
</code></pre>
<p>아래와 같은 결과를 얻을 수 있습니다.</p>
<pre><code class="language-bash">$ cargo test
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.89 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 3 tests
test test_bar ... ok
test test_baz ... ok
test test_foo_bar ... ok
test test_foo ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>특정 패턴과 일치하는 파일명을 가진 테스트에 대해서만 테스트를 수행할 수 있습니다.</p>
<pre><code class="language-bash">$ cargo test test_foo
   Compiling blah v0.1.0 (file:///nobackup/blah)
    Finished dev [unoptimized + debuginfo] target(s) in 0.35 secs
     Running target/debug/deps/blah-d3b32b97275ec472

running 2 tests
test test_foo ... ok
test test_foo_bar ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 2 filtered out
</code></pre>
<p>한 가지 주의사항이 있습니다. Cargo는 여러 테스트들을 동시에 실행할 수 있습니다. 따라서 이들이 서로 race 상태에 놓이지 않도록 해야합니다. 이를테면, 각각의 테스트가 하나의 파일에 그 결과를 출력한다면, 이를 각자 다른 파일로 작성하게끔 만드세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="build-scripts"><a class="header" href="#build-scripts">Build Scripts</a></h1>
<p>일부 경우, <code>cargo</code>를 통한 일반적인 빌드가 충분하지 않을 수 있습니다. 프로젝트의 크레이트가 <code>cargo</code> 컴파일 이전에 먼저 갖추어져야 하는 요구사항이 있을 지도 모릅니다. 이를테면, 코드 생성 혹은 컴파일되어야 하는 네이티브 코드와 같은 것들입니다. 이런 경우, Cargo가 실행할 수 있는 새로운 빌드 스크립트를 작성함으로써 문제를 해결할 수 있습니다.</p>
<p>빌드 스크립트를 작성하여 이를 패키지를 추가하기 위해선 <code>Cargo.toml</code>에 아래와 같이 작성할 수 있습니다.</p>
<pre><code class="language-toml">[package]
...
build = &quot;build.rs&quot;
</code></pre>
<p>이후, Cargo는 기본적으로 프로젝트 디렉토리 내에서 <code>build.rs</code>를 탐색하려고 할 것입니다.</p>
<h2 id="how-to-use-a-build-script"><a class="header" href="#how-to-use-a-build-script">How to use a build script</a></h2>
<p>빌드 스크립트는 다른 Rust 파일과 동일하며, 다른 파일들을 컴파일하기 전에 미리 컴파일되고 호출될 뿐입니다. 따라서 크레이트 사전 요구사항을 충족하기 위해 이를 사용할 수 있습니다.</p>
<p>Cargo는 <a href="https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">여기</a>에 명시된 환경 변수를 통해 스크립트에서 사용할 수 있는 입력을 제공합니다.</p>
<p>스크립트는 <code>stdout</code>을 통한 출력을 제공합니다. 출력되는 모든 내용은 <code>target/debug/build/&lt;pkg&gt;/output</code>에 작성됩니다. 덧붙여, <code>cargo:</code> 접두어가 붙은 출력에 대해서는 Cargo가 직접 해석할 수 있으므로, 패키지 컴파일을 위한 매개변수를 정의하기 위해 사용할 수 있습니다.</p>
<p>더 구체적인 사항과 예시에 대해서는 <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">Cargo</a> 명세서를 확인하세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="attributes"><a class="header" href="#attributes">Attributes</a></h1>
<p>어트리뷰트(attribute)는 일부 모듈, 크레이트 또는 항목(item)에 적용되는 메타데이터입니다. 이러한 메타데이터는 다음의 목적으로 사용됩니다.</p>
<ul>
<li>코드의 조건부 컴파일</li>
<li>크레이트의 이름, 버전, 타입 (바이너리 혹은 라이브러리) 설정</li>
<li>린트 (lint, 또는 경고 : warnings) 비활성화</li>
<li>컴파일러 기능 활성화 (매크로, glob import 등)</li>
<li>외부 라이브러리에 대한 링크</li>
<li>유닛 테스트를 시행할 함수 표시</li>
<li>벤치마크의 일부가 될 함수 표시</li>
</ul>
<p>어트리뷰트가 크레이트 전체에 적용될 때, 이들의 작성은 <code>#![crate_attribute]</code>가 되고, 하나의 모듈 또는 항목에 적용될 때, 이들의 작성은 <code>#[item_attribute]</code>가 됩니다. (<code>!</code>가 하나 사라졌음을 주의하세요.)</p>
<p>어트리뷰트는 다양한 형태로 인수를 전달받을 수 있습니다. :</p>
<ul>
<li><code>#[attribute = &quot;value&quot;]</code></li>
<li><code>#[attribute(key = &quot;value&quot;)]</code></li>
<li><code>#[attribute(value)]</code></li>
</ul>
<p>어트리뷰트는 여러 값들을 가질 수 있고, 여러 줄로 나누어 작성될 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[attribute(value, value2)]


#[attribute(value, value2, value3,
            value4, value5)]
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dead_code"><a class="header" href="#dead_code">dead_code</a></h1>
<p>컴파일러는 사용하지 않는 함수에 대해 경고하는 <code>dead_code</code> 린트를 제공합니다. 어트리뷰트는 이러한 린트를 비활성화하는데 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn used_function() {}

// `#[allow(dead_code)]`는 `dead_code` 린트를 비활성화하는 어트리뷰트입니다.
#[allow(dead_code)]
fn unused_function() {}

// 아래의 경우는 `dead_code`를 허용하지 않았으므로 경고가 출력됩니다.
fn noisy_unused_function() {}
// FIXME ^ Add an attribute to suppress the warning

fn main() {
    used_function();
}
</code></pre></pre>
<p>단, 실제 프로그램에서는 이러한 Dead Code가 없어야 한다는 점에 주의하세요. 여기서는 여러 예시들을 보여주기 위해 어쩔 수 없이 dead code를 허용하지만, 실제 개발 시에 Dead Code는 존재하지 않아야 합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="crates-1"><a class="header" href="#crates-1">Crates</a></h1>
<p><code>crate_type</code> 어트리뷰트는 컴파일러에게 크레이트가 바이너리인지 라이브러리인지(더불어 어떤 타입의 라이브러리인지) 전달해주는 역할을 합니다. <code>crate_name</code> 어트리뷰트는 크레이트의 이름을 설정하기 위해 사용될 수 있습니다.</p>
<p>그러나, <code>crate_type</code>과 <code>crate_name</code>은 Cargo를 사용하는 경우엔 아무런 영향을 미치지 않는다는 점을 기억하세요. Cargo는 대부분의 Rust 프로젝트에서 사용되기 때문에, <code>crate_type</code> 과 <code>crate_name</code>의 실제 사용이 상대적으로 제한적이라는 것을 의미합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 크레이트는 library입니다.
#![crate_type = &quot;lib&quot;]
// 라이브러리의 이름은 &quot;rary&quot;입니다.
#![crate_name = &quot;rary&quot;]

pub fn public_function() {
    println!(&quot;called rary's `public_function()`&quot;);
}

fn private_function() {
    println!(&quot;called rary's `private_function()`&quot;);
}

pub fn indirect_access() {
    print!(&quot;called rary's `indirect_access()`, that\n&gt; &quot;);

    private_function();
}
<span class="boring">}
</span></code></pre></pre>
<p><code>crate_type</code> 어트리뷰트가 사용된다면, 더 이상 <code>rustc</code>에 <code>--crate-type</code> 플래그를 전달할 필요가 없습니다.</p>
<pre><code>$ rustc lib.rs
$ ls lib*
library.rlib
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="cfg"><a class="header" href="#cfg">cfg</a></h1>
<p>환경 조건 검사는 두 가지 다른 연산자를 통해 이루어질 수 있습니다.</p>
<ul>
<li><code>cfg</code> 어트리뷰트 : <code>#[cfg(...)]</code>을 어트리뷰트로 사용</li>
<li><code>cfg</code> 매크로 : <code>cfg!(...)</code>을 Boolean 문에서 사용</li>
</ul>
<p>어트리뷰트를 이용한 방법은 조건부 컴파일을 활성화하지만, 후자는 런타임 시점에 조건을 판단하여 <code>true</code> 또는 <code>false</code> 리터럴을 반환합니다. 양쪽 모두 동일한 인수들을 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 아래 함수는 target OS가 리눅스인 경우에만 컴파일 됩니다.
#[cfg(target_os = &quot;linux&quot;)]
fn are_you_on_linux() {
    println!(&quot;You are running linux!&quot;);
}

// 아래 함수는 target OS가 리눅스가 아닌 경우에만 컴파일 됩니다.
#[cfg(not(target_os = &quot;linux&quot;))]
fn are_you_on_linux() {
    println!(&quot;You are *not* running linux!&quot;);
}

fn main() {
    are_you_on_linux();

    println!(&quot;Are you sure?&quot;);
    // target_os가 리눅스인 경우에만 true 조건이 충족됩니다.
    if cfg!(target_os = &quot;linux&quot;) {
        println!(&quot;Yes. It's definitely linux!&quot;);
    } else {
        println!(&quot;Yes. It's definitely *not* linux!&quot;);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="custom"><a class="header" href="#custom">Custom</a></h1>
<h1 id="custom-1"><a class="header" href="#custom-1">Custom</a></h1>
<p><code>target_os</code>와 같은 일부 조건들은 <code>rustc</code>에 의해 내부적으로 제공됩니다. 그러나 커스텀 조건들은 <code>rustc</code>에 <code>--cfg</code> 플래그를 사용하여 전달되어야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 아래 함수는 some_condition 조건이 없으면 컴파일되지 않습니다.
#[cfg(some_condition)]
fn conditional_function() {
    println!(&quot;condition met!&quot;);
}

fn main() {
    conditional_function();
}
</code></pre></pre>
<p>커스텀 <code>cfg</code> 플래그 없이 위의 파일에 대해 컴파일을 시도하면 에러가 발생할 것입니다.</p>
<p>따라서 다음과 같이 <code>cfg</code> 플래그를 사용해야 합니다.</p>
<pre><code>$ rustc --cfg some_condition custom.rs &amp;&amp; ./custom
condition met!
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<p><strong>제네릭</strong>은 더 다양한 상황에 적용될 수 있도록 타입과 함수를 일반화시키는 개념입니다. 이는 여러 방법으로 코드 중복을 줄일 수 있어 유용하지만, 추가적인 구문 작성을 요구합니다. 말 그대로, 제네릭이 되려면 제네릭 타입이 실제로 유효한 것으로 간주되는 타입을 명시하기 위한 세심한 주의가 필요합니다. 가장 간단하고 일반적인 제네릭의 사용은 타입 매개변수입니다.</p>
<p>타입 매개변수는 <code>&lt;&gt;</code> 괄호와 CamelCase로 제네릭을 명시할 수 있습니다. (ex. <code>&lt;Aaa, Bbb, ...&gt;</code>). <em>제네릭 타입 매개변수</em>는 일반적으로 <code>&lt;T&gt;</code>로 나타냅니다. Rust에서의 &quot;제네릭&quot;은 하나 이상의 제네릭 타입 매개변수를 허용하는 모든 항목을 의미합니다. 제네릭 타입 매개변수로 정의되는 어떤 타입이든 제네릭이 되며, 그렇지 않은 것들은 콘크리트(concrete, non-generic)가 됩니다.</p>
<p>예를 들어, <code>foo</code>라는 이름을 가진 제네릭함수를 정의하고 모든 타입에 대한 매개변수 <code>T</code>를 받도록 하겠습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn foo&lt;T&gt;(arg: T) { ... }
<span class="boring">}
</span></code></pre></pre>
<p><code>T</code>는 <code>&lt;T&gt;</code>를 통해 제네릭 타입 매개변수로서 정의된 것이므로, <code>(arg: T)</code>를 사용되는 경우 제네릭이 됩니다. 이는 이미 <code>T</code>가 이전에 <code>struct</code>로 따로 정의되었더라도 마찬가지입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 콘크리트 타입 A
struct A;

// Single은 콘크리트 타입이고, `A`는 바로 위에 정의된 것입니다.
struct Single(A);

// `SingleGen`은 제네릭 타입입니다.
// 타입 매개변수 `T`가 제네릭이기 때문에, 여기엔 위의 `A` 타입을 포함한 무엇이든 될 수 있습니다.
struct SingleGen&lt;T&gt;(T);

fn main() {
    // `Single`은 콘크리트이고, `A` 타입을 인수로 받습니다.
    let _s = Single(A);
    
    // `SingleGen&lt;char&gt;` 타입을 가진 `_char` 변수에 `SingleGen('a')`을 바인딩합니다.
    // 이 시점에서, 모호했던 `SingleGen`에 명시적인 타입 매개변수가 지정됩니다.
    let _char: SingleGen&lt;char&gt; = SingleGen('a');

    // 여전히 `SingleGen`은 암시적으로 지정된 제네릭 타입 매개변수가 있습니다.
    let _t    = SingleGen(A); // 최상단의 `A` 타입
    let _i32  = SingleGen(6); // `i32`
    let _char = SingleGen('a'); // `char`
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions-1"><a class="header" href="#functions-1">Functions</a></h1>
<p>동일한 규칙은 함수에도 적용됩니다. <code>&lt;T&gt;</code>가 타입 <code>T</code> 앞에 작성되면 해당 타입 <code>T</code>가 제네릭이 됩니다.</p>
<p>제네릭 함수를 사용하는 것은 종종 명시적인 타입 매개변수의 지정이 요구됩니다. 이러한 상황은 함수가 반환하는 타입이 제네릭에 해당하거나, 컴파일러 입장에서 필수적인 타입 매개변수를 추측하기 위한 충분한 정보가 존재하지 않을 경우에 그렇습니다.</p>
<p>명시적으로 타입 매개변수를 지정하여 함수를 호출하는 경우, 다음과 같은 형태를 띕니다. <code>func::&lt;A, B, ...&gt;()</code></p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct A;          // 콘크리트 타입 'A'
struct S(A);       // 콘크리트 타입 'B'
struct SGen&lt;T&gt;(T); // 제네릭 타입 'SGen'

// 아래에 오는 모든 함수들은 본인에게 전달된 변수들에 대한 소유권을 넘겨 받습니다.

// `reg_fn` 함수는 `S` 타입을 가진 `_s` 인수를 받습니다.
// 여기에는 `&lt;T&gt;`가 사용되지 않았으므로, 제네릭 함수가 아닙니다.
fn reg_fn(_s: S) {}

// `gen_spec_t` 함수는 `SGen&lt;T&gt;` 타입의 `_s` 인수를 받습니다.
// 이는 명시적으로 타입 매개변수 `A`를 넘겨받지만,
// 이는 `gen_spec_t`의 제네릭 타입 매개변수로 명시된 것이 아니므로,
// 해당 함수는 제네릭 함수가 아닙니다.
fn gen_spec_t(_s: SGen&lt;A&gt;) {}

// `gen_spec_i32` 함수는 `SGen&lt;i32&gt;` 타입의 `_s` 인수를 받습니다.
// 이는 명시적으로 타입 매개변수 `i32`를 넘겨받지만,
// `i32`는 제네릭 타입이 아니므로, 해당 함수 역시 제네릭이 아닙니다.
fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

// `generic` 함수는 `SGen&lt;T&gt;` 타입의 `_s` 인수를 받습니다.
// `&lt;T&gt;`가 `SGen&lt;T&gt;`에 앞서 있으므로, 해당 함수는 `T`에 대한 제네릭 함수입니다.
fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // 먼저, 제네릭이 아닌 함수들을 사용해봅시다.
    reg_fn(S(A));          // 콘크리트 타입
    gen_spec_t(SGen(A));   // 암시적으로 지정된 타입매개변수 `A`
    gen_spec_i32(SGen(6)); // 암시적으로 지정된 타입매개변수 `i32`

    // 명시적으로 `char`타입 매개변수를 지정합니다.
    generic::&lt;char&gt;(SGen('a'));

    // 암시적으로 `char` 타입 매개변수를 지정합니다.
    generic(SGen('c'));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="implementation"><a class="header" href="#implementation">implementation</a></h1>
<p>함수와 유사하게, 구현(Implementation) 역시 제네릭을 활용할 수 있다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(unused)]
fn main() {
  struct S; // 콘크리트 타입 `S`
  struct GenericVal&lt;T&gt;(T); // 제네릭 타입 `GenericVal`
  
  // 명시적인 타입 매개변수 지정을 통한 GenericVal의 구현
  impl GenericVal&lt;f32&gt; {} // `f32` 지정
  impl GenericVal&lt;S&gt; {} // 상단의 `S` 타입에 대한 지정

  // `&lt;T&gt;`가 제네릭을 위해 사용되었습니다.
  impl&lt;T&gt; GenericVal&lt;T&gt; {}
}
</code></pre></pre>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Val {
    val: f64,
}

struct GenVal&lt;T&gt; {
    gen_val: T,
}

// Val 구현
impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}

// 제네릭 타입 `T`에 대한 GenVal의 구현
impl&lt;T&gt; GenVal&lt;T&gt; {
    fn value(&amp;self) -&gt; &amp;T {
        &amp;self.gen_val
    }
}

fn main() {
    let x = Val { val: 3.0 };
    let y = GenVal { gen_val: 3i32 };

    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>당연히 <code>trait</code> 역시 제네릭이 될 수 있습니다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// Non-copyable 타입
struct Empty;
struct Null;

// `T`에 대한 트레이트 제네릭
trait DoubleDrop&lt;T&gt; {
    // 추가 단일 매개변수 `T`를 받아 아무 것도 하지 않는
    // 호출자 타입에 대한 메서드를 정의합니다.
    fn double_drop(self, _: T);
}

// 제네릭 매개변수 `T`와 호출자 `U`로 `DoubleDrop&lt;T&gt;`를 구현합니다.
impl&lt;T, U&gt; DoubleDrop&lt;T&gt; for U {
    // 아래 메서드는 전달된 두 인수의 소유권을 가져와 할당을 취소합니다.
    fn double_drop(self, _: T) {}
}

fn main() {
    let empty = Empty;
    let null  = Null;

    // `empty`와 `null`의 할당을 취소합니다.
    empty.double_drop(null);

    // ERROR : 소유권이 이전되어 아래 변수들은 사용할 수 없습니다.
    empty;
    null;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bounds"><a class="header" href="#bounds">Bounds</a></h1>
<p>제네릭으로 작업을 진행할 때, 종종 타입 파라미터는 타입을 구현하는 기능을 명시하기 위해 트레이트를 **바운드(bounds)**로 사용해야 합니다. 예를 들어, 아래 예시에서는 출력을 위해 <code>Display</code> 트레이트를 사용하며, 따라서 <code>Display</code>에 의해 바운드 되기 위해 <code>T</code>가 요구됩니다. 다시 말해, <code>T</code>는 반드시 <code>Display</code>를 구현해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// `Display` 트레이트를 반드시 구현해야 하는
// 제네릭 타입 `T`를 받는 `printer` 함수입니다.
fn printer&lt;T: Display&gt;(t: T) {
    println!(&quot;{}&quot;, t);
}
<span class="boring">}
</span></code></pre></pre>
<p>바운딩은 제네릭을 바운드를 만족하는 타입으로 제한합니다. 예를 들어 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct S&lt;T: Display&gt;(T);

// ERROR : `Vec&lt;T&gt;`는 `Display`를 구현하지 않았습니다.
let s = S(vec![1]);
<span class="boring">}
</span></code></pre></pre>
<p>바운딩의 또 다른 효과는 제네릭 인스턴스가 바운드 내에 정의된 트레이트의 메서드에 접근할 수 있게끔 해준다는 것입니다. 예를 들자면 다음과 같습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `{:?}` 출력 마커에 대해 구현하는 트레이트입니다.
use std::fmt::Debug;

trait HasArea {
    fn area(&amp;self) -&gt; f64;
}

impl HasArea for Rectangle {
    fn area(&amp;self) -&gt; f64 { self.length * self.height }
}

#[derive(Debug)]
struct Rectangle { length: f64, height: f64 }
#[allow(dead_code)]
struct Triangle  { length: f64, height: f64 }

// `T` 제네릭은 반드시 `Debug`를 구현해야 합니다.
// 타입과 무관하게, 아래는 제대로 동작할 것입니다.
fn print_debug&lt;T: Debug&gt;(t: &amp;T) {
    println!(&quot;{:?}&quot;, t);
}

// `T`는 반드시 `HasArea`를 구현해야 합니다.
// 해당 바운드를 만족하는 어떤 타입이든
// `HasArea`의 함수인 `area`에 접근할 수 있습니다.
fn area&lt;T: HasArea&gt;(t: &amp;T) -&gt; f64 { t.area() }

fn main() {
    let rectangle = Rectangle { length: 3.0, height: 4.0 };
    let _triangle = Triangle  { length: 3.0, height: 4.0 };

    print_debug(&amp;rectangle);
    println!(&quot;Area: {}&quot;, area(&amp;rectangle));

    // ERROR : `Triangle`에는 `Debug`나 `HasArea`가 구현되어 있지 않습니다.
    // 따라서 아래는 에러가 발생합니다.
    print_debug(&amp;_triangle);
    println!(&quot;Area: {}&quot;, area(&amp;_triangle));
}
</code></pre></pre>
<p>추가적으로, 경우에 따라 바운드를 적용하기 위해 <code>where</code> 문이 사용될 수도 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-empty-bounds"><a class="header" href="#testcase-empty-bounds">Testcase: empty bounds</a></h1>
<p>바운드가 동작하는 방식의 결과로, 트레이트는 어떤 기능을 포함하지 않더라도, 여전히 바운드로 사용할 수 있습니다. <code>Eq</code>와 <code>Copy</code>는 <code>std</code> 라이브러리에서 제공되는 트레이트의 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Cardinal;
struct BlueJay;
struct Turkey;

trait Red {}
trait Blue {}

impl Red for Cardinal {}
impl Blue for BlueJay {}

// 아래 함수들은 트레이트들을 구현한 타입에 대해서만 유효합니다.
// 반면, 트레이트가 비어있다는 사실 자체는 무관합니다.
fn red&lt;T: Red&gt;(_: &amp;T)   -&gt; &amp;'static str { &quot;red&quot; }
fn blue&lt;T: Blue&gt;(_: &amp;T) -&gt; &amp;'static str { &quot;blue&quot; }

fn main() {
    let cardinal = Cardinal;
    let blue_jay = BlueJay;
    let _turkey   = Turkey;

    // `red()`는 blu_jay에는 동작하지 않습니다.
    // 그 반대도 마찬가지이며, 이는 바운드 때문입니다.
    println!(&quot;A cardinal is {}&quot;, red(&amp;cardinal));
    println!(&quot;A blue jay is {}&quot;, blue(&amp;blue_jay));

    // ERROR : `red()`는 blu_jay에는 동작하지 않습니다.
    // 그 반대도 마찬가지이며, 이는 바운드 때문입니다.
    println!(&quot;A turkey is {}&quot;, red(&amp;_turkey));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="multiple-bounds"><a class="header" href="#multiple-bounds">Multiple bounds</a></h1>
<p>다중 바운드(Multiple bounds)는 <code>+</code>로 적용할 수 있습니다. 여러 타입에 대해서는 <code>,</code>로 구분합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt::{Debug, Display};

fn compare_prints&lt;T: Debug + Display&gt;(t: &amp;T) {
    println!(&quot;Debug: `{:?}`&quot;, t);
    println!(&quot;Display: `{}`&quot;, t);
}

fn compare_types&lt;T: Debug, U: Debug&gt;(t: &amp;T, u: &amp;U) {
    println!(&quot;t: `{:?}`&quot;, t);
    println!(&quot;u: `{:?}`&quot;, u);
}

fn main() {
    let string = &quot;words&quot;;
    let array = [1, 2, 3];
    let vec = vec![1, 2, 3];

    compare_prints(&amp;string);
    // ERROR : array에는 `Display`에 구현되어 있지 않습니다.
    compare_prints(&amp;array);

    compare_types(&amp;array, &amp;vec);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="where-clauses"><a class="header" href="#where-clauses">Where clauses</a></h1>
<p>바운드는 <code>{</code>로 블럭을 열기 전에 <code>where</code>문을 사용하여 표현될 수도 있습니다. 추가적으로, <code>where</code> 문은 타입 매개변수 뿐만 아니라 임의의 타입에 바운드를 적용할 수 있습니다.</p>
<p><code>where</code> 문이 유용한 몇가지 상황은 다음과 같습니다.</p>
<ul>
<li>제네릭 타입과 바운드를 명확하게 정의하는 것이 더 깔끔한 경우 :</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl &lt;A: TraitB + TraitC, D: TraitE + TraitF&gt; MyTrait&lt;A, D&gt; for YourType {}

// `where` 문으로 바운드를 표현
impl &lt;A, D&gt; MyTrait&lt;A, D&gt; for YourType where
    A: TraitB + TraitC,
    D: TraitE + TraitF {}
<span class="boring">}
</span></code></pre></pre>
<ul>
<li><code>where</code>문을 사용하는 것이 일반 구문보다 더 명확한 경우. 아래 예시에서 <code>impl</code>은 <code>where</code>문 없이는 직접 표현될 수 없습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt::Debug;

trait PrintInOption {
    fn print_in_option(self);
}

// 아래는 `where` 문이 요구됩니다.
// 그렇지 않다면, `T: Debug`에 대해 표현하거나,
// 간접적인 접근을 위한 또 다른 메서드를 사용해야 합니다.
impl&lt;T&gt; PrintInOption for T where
    Option&lt;T&gt;: Debug {
    // 우리는 `Option&lt;T&gt;: Debug`가 바운드로서 필요합니다.
    // 아래 메서드에서 출력이 가능해야 하기 때문입니다.
    fn print_in_option(self) {
        println!(&quot;{:?}&quot;, Some(self));
    }
}

fn main() {
    let vec = vec![1, 2, 3];

    vec.print_in_option();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="new-type-idiom"><a class="header" href="#new-type-idiom">New Type Idiom</a></h1>
<p><code>newtype</code> 패턴은 컴파일 시점에 값의 올바른 타입이 프로그램에 전달되도록 합니다.</p>
<p>예를 들어, 연령 확인 함수는 년 단위로 이루어지며, <code>Years</code> 타입의 값을 넘겨받아야 합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Years(i64);

struct Days(i64);

impl Years {
    pub fn to_days(&amp;self) -&gt; Days {
        Days(self.0 * 365)
    }
}


impl Days {
    // 나눈 후의 나머지 연도는 버립니다.
    pub fn to_years(&amp;self) -&gt; Years {
        Years(self.0 / 365)
    }
}

fn old_enough(age: &amp;Years) -&gt; bool {
    age.0 &gt;= 18
}

fn main() {
    let age = Years(5);
    let age_days = age.to_days();
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age));
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days.to_years()));
    // ERROR : `old_enough`는 `Years` 타입에 대해서만 유효합니다.
    println!(&quot;Old enough {}&quot;, old_enough(&amp;age_days));
}
</code></pre></pre>
<p><code>newtype</code>의 값을 기본 타입으로 얻으려면, 다음과 같이 튜플을 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Years(i64);

fn main() {
    let years = Years(42);
    let years_as_primitive: i64 = years.0;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="associated-items"><a class="header" href="#associated-items">Associated items</a></h1>
<p>**연관 항목(Associated items)**이란 다양한 유형의 항목들과 관련된 규칙들의 집합을 가리킵니다. 이는 <code>trait</code> 제네륵의 확장이며, <code>trait</code>들이 내부적으로 새로운 항목들을 정의할 수 있도록 합니다.</p>
<p>이러한 항목 중 하나를 *연관 유형(Associated Type)*이라고 하며, 트레이트가 컨테이너 타입보다 제네릭일 때 더 간단한 사용 패턴을 제공합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h1>
<p>컨테이너 타입보다는 제네릭에 해당하는 트레이트는 구체적인 타입 요구사항이 존재합니다. 트레이트의 사용자는 반드시 모든 제네릭 타입을 명시해주어야 합니다.</p>
<p>아래 예시에서, <code>Contains</code> 트레이트는 제네릭 타입 <code>A</code>와 <code>B</code>의 사용을 허가합니다. 이후 해당 트레이트는 <code>fn difference()</code>를 통해 <code>Container</code> 타입에 대해 구현하고, <code>A</code>와 <code>B</code>에 대해 <code>i32</code> 타입을 명시합니다.</p>
<p><code>Contains</code>는 제네릭이기 때문에, 여기서 우리는 <code>fn difference()</code>로 모든 제네릭 타입에 대해 명시적으로 정의해주어야 합니다. 실제로, <code>A</code>와 <code>B</code>는 입력 <code>C</code>에 의해 결정되는 방식을 원합니다. 아래 예시에서 볼 수 있듯, *연관 항목(Associated types)*이 정확히 그 기능을 제공해줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Container(i32, i32);

// 컨테이너 내부에 두 항목이 존재하는지 체크하는 트레이트 입니다.
// 또한 첫번째 혹은 마지막 값을 검색합니다.
trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool; // 명시적으로 `A`와 `B`를 요구합니다.
    fn first(&amp;self) -&gt; i32; // 명시적으로 `A`와 `B`를 요구하지 않습니다.
    fn last(&amp;self) -&gt; i32;  // 명시적으로 `A`와 `B`를 요구하지 않습니다.
}

impl Contains&lt;i32, i32&gt; for Container {
    // 저장된 수가 동일하다면 `true`를 반환합니다.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }

    // 첫번째 수를 가져옵니다.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // 마지막 수를 가져옵니다.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

// `C`는 이미 `A`와 `B`를 갖습니다.
// 그런 점에서, `A`와 `B`를 일일이 다시 표현할 필요는 없습니다.
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());

    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h1>
<p>*관련 항목(Associated types)*의 사용은 내부의 타입들을 로컬에서 트레이트로 출력타입으로 옮겨 코드의 전반적인 가독성을 향상시킵니다.</p>
<p><code>trait</code> 정의에 대한 내용을 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#![allow(unused)]
fn main() {
// `A`와 `B`는 `type` 키워드로 트레이트 내에 정의됩니다.
// (주의 : 해당 컨텍스트 내에서의 `type`은 타입 별칭에서의 `type`과 다릅니다.)
  trait Contains {
      type A;
      type B;

      // 제네릭으로 새로운 타입들에 대한 참조를 업데이트했습니다.
      fn contains(&amp;self, &amp;Self::A, &amp;Self::B) -&gt; bool;
  }
}
</code></pre></pre>
<ul>
<li>다음 함수에서 <code>Contains</code> 트레이트의 사용이 더 이상 <code>A</code>와 <code>B</code>에 대한 표현을 요구하지 않는다는 점을 확인하세요.</li>
</ul>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 관련 타입(associated types)을 사용하지 않는 경우
fn difference&lt;A, B, C&gt;(container: &amp;C) -&gt; i32 where
    C: Contains&lt;A, B&gt; { ... }

// 관련 타입(associated types)를 사용하는 경우
fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 { ... }
<span class="boring">}
</span></code></pre></pre>
<p>자, 이제 이전 섹션에서의 구현을 관련 타입을 통해서 다시 작성해봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Container(i32, i32);

// 컨테이너 내부에 두 항목이 존재하는지 체크하는 트레이트 입니다.
// 또한 첫번째 혹은 마지막 값을 검색합니다.
trait Contains {
    // 활용할 수 있는 제네릭 타입들에 대해 정의합니다.
    type A;
    type B;

    fn contains(&amp;self, _: &amp;Self::A, _: &amp;Self::B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains for Container {
    // 여기에서 `A`와 `B`의 타입에 대해 명시합니다.
    // 만약, `Container(i32, i32)`가 입력 타입이 된다면,
    // 결과 타입은 따라서 결정됩니다.
    type A = i32;
    type B = i32;

    // `&amp;Self::A` and `&amp;Self::B` are also valid here.
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;C: Contains&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="phantom-type-parameters"><a class="header" href="#phantom-type-parameters">Phantom type parameters</a></h1>
<p>팬텀 타입 매개변수(phantom type parameter)는 런타임 시점에 표시되지 않으나, 컴파일 시점에 정적으로 확인되는 타입 매개변수입니다.</p>
<p>데이터 타입들은 마커로서의 역할을 수행하거나, 컴파일 시점에 타입 체킹을 수행하기 위해 추가적인 제네릭 타입 매개변수를 사용할 수 있습니다. 이러한 추가적인 매개변수들은 저장소 공간을 요구하지 않으며, 런타임 시점에서의 행동도 없습니다.</p>
<p>아래 예시에서, 우리는 다른 데이터 타입들을 포함하는 튜플을 생성하는 팬텀 타입 매개변수로 <code>std::marker::PhantomData</code>를 결합합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::marker::PhantomData;

// 숨겨진 매개변수 `B`로 `A`에 제네릭을 적용한 팬텀 튜플 구조입니다.
#[derive(PartialEq)] // 해당 타입에 대한 동등성 테스트를 수행합니다.
struct PhantomTuple&lt;A, B&gt;(A,PhantomData&lt;B&gt;);
.
// 숨겨진 매개변수 `B`로 `A`에 제네릭을 적용하는 팬텀 타입 구조입니다.
#[derive(PartialEq)] // 해당 타입에 대한 동등성 테스트를 수행합니다.
struct PhantomStruct&lt;A, B&gt; { first: A, phantom: PhantomData&lt;B&gt; }

// 주의 : 저장소는 제네릭 `A` 타입에 대해서는 할당되지만, `B`는 그렇지 않습니다.
// 그러므로, `B` 타입은 연산에 활용될 수 없습니다.

fn main() {
    // 여기, `f32`와 `f64`가 숨겨진 매개변수로 존재합니다.
    // PhantomTuple 타입은 `&lt;char, f32&gt;`로 명시될 수 있습니다.
    let _tuple1: PhantomTuple&lt;char, f32&gt; = PhantomTuple('Q', PhantomData);
    // PhantomTuple 타입은 `&lt;char, f64&gt;`로 명시될 수 있습니다.
    let _tuple2: PhantomTuple&lt;char, f64&gt; = PhantomTuple('Q', PhantomData);

    // 타입은 `&lt;char, f32&gt;`로 명시될 수 있습니다.
    let _struct1: PhantomStruct&lt;char, f32&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    // 타입은 `&lt;char, f64&gt;`로 명시될 수 있습니다.
    let _struct2: PhantomStruct&lt;char, f64&gt; = PhantomStruct {
        first: 'Q',
        phantom: PhantomData,
    };
    
    // ERROR : 아래는 타입이 불일치하여 비교될 수 없습니다.
    // 따라서 컴파일 에러가 발생합니다.
    println!(&quot;_tuple1 == _tuple2 yields: {}&quot;,
             _tuple1 == _tuple2);
    
    // ERROR : 아래는 타입이 불일치하여 비교될 수 없습니다.
    // 따라서 컴파일 에러가 발생합니다.
    println!(&quot;_struct1 == _struct2 yields: {}&quot;,
             _struct1 == _struct2);
}

</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="testcase-unit-clarification"><a class="header" href="#testcase-unit-clarification">Testcase: unit clarification</a></h1>
<p>단위 변환의 유용한 메서드는 팬텀 타입 매개변수로 <code>Add</code>를 구현함으로서 검사할 수 있습니다. <code>Add</code> 트레이트는 아래와 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 아래 생성은 `Self + RHS = Output`을 구성합니다.
// RHS는 구현 내에서 명시되지 않는다면 `Self`가 기본값이 됩니다.
pub trait Add&lt;RHS = Self&gt; {
    type Output;

    fn add(self, rhs: RHS) -&gt; Self::Output;
}

// `Output`은 반드시 `T&lt;U&gt;`가 되며,
// 따라서 `T&lt;U&gt; + T&lt;U&gt; = T&lt;U&gt;` 입니다.
impl&lt;U&gt; Add for T&lt;U&gt; {
    type Output = T&lt;U&gt;;
    ...
}
<span class="boring">}
</span></code></pre></pre>
<p>전체 구현은 아래와 같습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::ops::Add;
use std::marker::PhantomData;

// 유닛 타입 정의를 위해 비어있는 enum을 만듭니다.
#[derive(Debug, Clone, Copy)]
enum Inch {}
#[derive(Debug, Clone, Copy)]
enum Mm {}

// `Length`는 팬텀 타입 매개변수 `Unit`을 사용하는 타입입니다.
// 그리고 이는 length 타입(`f64`)에 대한 제네릭이 아닙니다.
// `f64`는 이미 `Clone`과 `Copy` 트레이트에 대해 구현되었습니다.
#[derive(Debug, Clone, Copy)]
struct Length&lt;Unit&gt;(f64, PhantomData&lt;Unit&gt;);

// `Add` 트레이트는 `+` 연산자의 동작에 대해 정의합니다.
impl&lt;Unit&gt; Add for Length&lt;Unit&gt; {
     type Output = Length&lt;Unit&gt;;

    // add() returns a new `Length` struct containing the sum.
    // `add()`는 덧셈이 수행된 새로운 `Length` 구조를 반환합니다.
    fn add(self, rhs: Length&lt;Unit&gt;) -&gt; Length&lt;Unit&gt; {
        // `+` 는 `f64`에 대한 새로운 `Add` 구현을 호출합니다.
        Length(self.0 + rhs.0, PhantomData)
    }
}

fn main() {
    // 팬텀 타입 매개변수 `Inch`를 갖기 위해 `one_foot`를 정의합니다.
    let one_foot:  Length&lt;Inch&gt; = Length(12.0, PhantomData);
    // `one_meter`는 `Mm` 팬텀 타입 매개변수를 갖습니다.
    let one_meter: Length&lt;Mm&gt;   = Length(1000.0, PhantomData);

    // `+`는 `Length&lt;Unit&gt;` 에 대해 구현한 `add()` 메서드를 호출합니다. 
    //
    // `Length`의 `Copy`, `add()` 구현은 `one_foot`과 `one_meter`를
    // &quot;소비&quot;하지 않고, `self`와 `rhs`에 이를 복사해옵니다.
    let two_feet = one_foot + one_foot;
    let two_meters = one_meter + one_meter;

    // 덧셈이 동작합니다.
    println!(&quot;one foot + one_foot = {:?} in&quot;, two_feet.0);
    println!(&quot;one meter + one_meter = {:?} mm&quot;, two_meters.0);

    // ERROR : `one_foot`과 `one_meter`간에는 타입이 맞지 않습니다.
    // 이러한 비논리적인 작업은 컴파일 에러를 유발합니다.
    let one_feter = one_foot + one_meter;
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="scoping-rules"><a class="header" href="#scoping-rules">Scoping rules</a></h1>
<p>스코프는 소유권(ownership), 대여(borrowing), 그리고 라이프타임(limetime)에서 중요한 역할을 합니다. 즉, 대여가 유효한 시기, 리소스를 확보할 수 있는 시기, 변수가 생성되거나 폐기되는 시기를 컴파일러에게 알려줍니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="raii"><a class="header" href="#raii">RAII</a></h1>
<p>Rust의 변수들은 단순히 데이터를 스택에 보관하는 것 이상의 일을 합니다. 그들은 자원(resources) 역시 소유합니다. (예를 들어, <code>Box&lt;T&gt;</code>는 힙에 본인의 메모리를 소유합니다.) Rust는 RAII(Resource Acquisition Is Initialization)를 강요합니다. 따라서, 한 객체가 스코프를 벗어날 때마다, 소멸자가 호출되고 소유되었던 리소스는 풀려납니다.</p>
<p>이러한 방식은 <em>resource leak(리소스 누수)</em> 문제에 대한 방어의 역할을 합니다. 덕분에 수동으로 메모리를 관리를 하거나 메모리 누수에 대한 걱정을 할 필요가 없습니다! 아래는 간단한 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// raii.rs
fn create_box() {
    // 힙에 정수를 할당합니다.
    let _box1 = Box::new(3i32);

    // `_box1`은 이 시점에 파괴됩니다.
    // 할당되었던 메모리는 이제 자유로워집니다.
}

fn main() {
    // 힙에 정수를 할당합니다.
    let _box2 = Box::new(5i32);

    // 중첩 스코프
    {
        // 힙에 정수를 할당합니다.
        let _box3 = Box::new(4i32);

        // `_box3`은 이 시점에 파괴됩니다.
        // 할당되었던 메모리는 이제 자유로워집니다.
    }

    // 수 많은 Box들을 만들어 봅시다.
    // 수동적으로 메모리를 관리할 필요가 없습니다!
    for _ in 0u32..1_000 {
        create_box();
    }

    // `_box2`은 이 시점에 파괴됩니다.
    // 할당되었던 메모리는 이제 자유로워집니다.
}
</code></pre></pre>
<p>물론, <code>valgrind</code>를 통해 메모리 에러에 대해 한번 더 체크해줄 수 있습니다.</p>
<pre><code>$ rustc raii.rs &amp;&amp; valgrind ./raii
==26873== Memcheck, a memory error detector
==26873== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==26873== Using Valgrind-3.9.0 and LibVEX; rerun with -h for copyright info
==26873== Command: ./raii
==26873==
==26873==
==26873== HEAP SUMMARY:
==26873==     in use at exit: 0 bytes in 0 blocks
==26873==   total heap usage: 1,013 allocs, 1,013 frees, 8,696 bytes allocated
==26873==
==26873== All heap blocks were freed -- no leaks are possible
==26873==
==26873== For counts of detected and suppressed errors, rerun with: -v
==26873== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 2 from 2)
</code></pre>
<p>아무런 메모리 누수가 없네요!</p>
<h2 id="destructor"><a class="header" href="#destructor">Destructor</a></h2>
<p>러스트에서의 소멸자(destructor)는 <code>Drop</code> 트레이트를 통해 제공됩니다. 소멸자는 리소스가 스코프를 벗어날 때마다 호출됩니다. 해당 트레이트는 모든 타입에 대해서 구현될 필요는 없고, 자체적인 소멸자 로직이 요구되는 경우에만 구현합니다.</p>
<p>아래 예시를 실행하여 <code>Drop</code> 트레이트가 동작하는 방식에 대해 살펴봅시다. <code>main</code> 함수의 변수가 스코프를 벗어나게 되면 커스텀 소멸자가 실행될 것입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct ToDrop;

impl Drop for ToDrop {
    fn drop(&amp;mut self) {
        println!(&quot;ToDrop is being dropped&quot;);
    }
}

fn main() {
    let x = ToDrop;
    println!(&quot;Made a ToDrop!&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-moves"><a class="header" href="#ownership-and-moves">Ownership and moves</a></h1>
<p>변수들은 자체 리소스들을 해방(free)하는 역할을 담당해야하기 때문에, <strong>리소스는 오직 하나의 소유자(owner)만 가질 수 있습니다.</strong> 이는, 리소스의 해방이 한번을 초과하며 발생하는 상황을 방지합니다. 모든 변수들이 스스로의 리소스를 소유하지는 않음(ex. references)을 명심하세요.</p>
<p>변수를 선언하거나(<code>let x = y</code>), 함수에 인수를 <strong>값으로</strong> 넘길 때(<code>foo(x)</code>), 리소스의 소유권은 이전됩니다. 이를 러스트에서는 **이동했다(move)**고 부릅니다.</p>
<p>리소스를 이동시키고 나면, 이전의 리소스 소유자는 더 이상 사용할 수 없습니다. 이는 <a href="https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0">허상 포인터(Dangling pointer)</a> 문제를 피하도록 해줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 아래 함수는 힙에 할당된 메모리의 소유권을 갖습니다.
fn destroy_box(c: Box&lt;i32&gt;) {
    println!(&quot;Destroying a box that contains {}&quot;, c);

    // `c`는 파괴되고 메모리는 해방됩니다.
}

fn main() {
    // 스택(_Stack_)은 메모리를 할당합니다.
    let x = 5u32;

    // `x`를 `y`로 &quot;복사&quot;하는 것은 리소스를 이동시키지 않습니다.
    let y = x;

    // 양쪽 값 모두 독립적으로 사용될 수 있습니다.
    println!(&quot;x is {}, and y is {}&quot;, x, y);

    // `a`는 힙(_heap_)에 할당된 정수에 대한 포인터입니다.
    let a = Box::new(5i32);

    println!(&quot;a contains: {}&quot;, a);

    // `a`를 `b`로 &quot;이동&quot;시킵니다.
    let b = a;
    // 이 때 `a`의 포인터 주소(데이터가 아닙니다!)는 `b`로 복사됩니다.
    // 현재 양쪽 모두 힙에 할당된 동일한 데이터를 가리키는 포인터입니다.
    // 하지만, 이제 `b`가 데이터를 &quot;소유&quot;하며, `a`는 권한이 없습니다.
    
    // ERROR : `a`는 더 이상 데이터에 접근할 수 없습니다.
    // `a`는 더이상 힙 메모리를 소유하지 않기 때문입니다.
    println!(&quot;a contains: {}&quot;, a);

    // 아래 함수는 `b`로부터 힙에 할당된 메모리의 소유권을 넘겨받습니다.
    destroy_box(b);

    // 힙 메모리는 이 시점에서 해방되기 때문에,
    // 아래 작업을 수행하면 해방된 메모리를 역참조합니다.
    // 하지만, 이는 컴파일러에 의해 금지됩니다.
    // ERROR : `b`는 더 이상 데이터에 접근할 수 없습니다.
    // `b`는 더 이상 힙 메모리를 소유하지 않기 때문입니다.
    println!(&quot;b contains: {}&quot;, b);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability-1"><a class="header" href="#mutability-1">Mutability</a></h1>
<p>소유권이 변경될 때 데이터의 불변성(Mutability) 여부를 변경할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let immutable_box = Box::new(5u32);

    println!(&quot;immutable_box contains {}&quot;, immutable_box);

    // ERROR : `immutable_box`은 immutable 하기 때문에 값을 변경할 수 없습니다.
    *immutable_box = 4;

    // box를 이동시켜, 소유권을 이전합니다.
    // 동시에 불변성의 여부도 변경합니다.
    let mut mutable_box = immutable_box;

    println!(&quot;mutable_box contains {}&quot;, mutable_box);

    // `mutable_box`는 이제 mutable하기 때문에
    // 값을 변경해도 문제가 없습니다.
    *mutable_box = 4;

    println!(&quot;mutable_box now contains {}&quot;, mutable_box);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="partial-moves"><a class="header" href="#partial-moves">Partial moves</a></h1>
<p>패턴 바인딩은 해체(destructuring)에서 사용되는 <code>by-move</code>와 <code>by-reference</code> 바인딩을 동시에 가질 수 있습니다. 이러한 패턴은 변수를 부분적으로 이동시키며, 이로 인해 변수의 일부만 이동되고, 나머지는 유지됩니다. 이 경우, 부모 변수는 나중에 완전한 형태로는 사용할 수 없습니다. 그러나, 참조를 이용하여 이동되지 않은 부분들은 여전히 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: u8,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: 20,
    };

    // `name`은 person으로부터 이동됩니다.
    // 반면, `age`는 단순히 참조합니다.
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // ERROR : 부분적으로 이동한 값이 존재합니다.
    // 따라서 `person`은 완전한 형태로 사용될 수 없습니다.
    println!(&quot;The person struct is {:?}&quot;, person);

    // `person`은 사용될 수 없으나,
    // `person.age`는 이동하지 않았기 때문에 사용할 수 있습니다.
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="borrowing"><a class="header" href="#borrowing">Borrowing</a></h1>
<p>대부분의 경우, 우리는 데이터의 소유권을 넘겨받지 않고 데이터에 접근하고자 합니다. 이를 위해, Rust는 <strong>대여(Borrowing)</strong> 매커니즘을 사용합니다. 이는 객체를 값(<code>T</code>)으로 전달하지 않고, 참조(<code>&amp;T</code>)를 통해 넘겨줄 수 있게 합니다.</p>
<p>컴파일러는 (borrow checker를 통해서) 참조들이 항상 올바른 객체들을 가리키고 있음을 정적으로 보장합니다. 다시 말해, 어떤 객체에 대한 참조가 존재하는 한, 해당 객체는 파괴될 수 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 아래 함수는 Box의 소유권을 넘겨받고, 파괴합니다.
fn eat_box_i32(boxed_i32: Box&lt;i32&gt;) {
    println!(&quot;Destroying box that contains {}&quot;, boxed_i32);
}

// 아래 함수는 `i32`를 &quot;대여&quot;합니다.
fn borrow_i32(borrowed_i32: &amp;i32) {
    println!(&quot;This int is: {}&quot;, borrowed_i32);
}

fn main() {
    // Box에 저장된 i32와 스택에 저장된 i32를 생성합니다.
    let boxed_i32 = Box::new(5_i32);
    let stacked_i32 = 6_i32;

    // Box의 컨텐츠를 대여합니다.
    // 소유권은 넘겨받지 않기 때문에,
    // 이는 여전히 다시 대여할 수 있습니다.
    borrow_i32(&amp;boxed_i32);
    borrow_i32(&amp;stacked_i32);

    {
        // Box 내에 보관된 데이터에 대한 참조를 넘겨받습니다.
        let _ref_to_i32: &amp;i32 = &amp;boxed_i32;

        // ERROR : `boxed_i32`는 파괴될 수 없습니다.
        // 현재 스코프의 아래쪽에서 다시 대여될 것이기 때문입니다.
        eat_box_i32(boxed_i32);

        // 내부 값이 파괴된 이후 `_ref_to_i32`를 대여합니다. 
        borrow_i32(_ref_to_i32);
        // `_ref_to_i32`는 스코프를 벗어나 더 이상 대여될 수 없습니다.
    }

    // `boxed_i32`는 이제야 `eat_box`에 대한 소유권을 넘겨주고, 파괴될 수 있습니다.
    eat_box_i32(boxed_i32);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="mutability-2"><a class="header" href="#mutability-2">Mutability</a></h1>
<p>mutable한 데이터는 <code>&amp;mut T</code>를 통해 mutable하게 대여될 수 있습니다. 이를 *가변 참조(mutable reference)*라고 하며, 대여자에게 읽기/쓰기 권한을 전달합니다. 대조적으로, <code>&amp;T</code>는 불변 참조(immutable reference)를 통해 대여되며, 대여자들은 해당 데이터를 읽을 순 있지만, 수정할 수는 없습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#[allow(dead_code)]
#[derive(Clone, Copy)]
struct Book {
    // `&amp;'static str`은 읽기 전용 메모리에 할당된 
    // String에 대한 참조입니다.
    author: &amp;'static str,
    title: &amp;'static str,
    year: u32,
}

// 아래 함수는 `book`에 대한 참조를 받습니다.
fn borrow_book(book: &amp;Book) {
    println!(&quot;I immutably borrowed {} - {} edition&quot;, book.title, book.year);
}

// 아래 함수는 mutable한 `book`에 대한 참조를 받아
// `year` 필드를 `2014`로 변경합니다.
fn new_edition(book: &amp;mut Book) {
    book.year = 2014;
    println!(&quot;I mutably borrowed {} - {} edition&quot;, book.title, book.year);
}

fn main() {
    // `immutabook`이란 이름을 가진 immutaable Book을 만듭니다.
    let immutabook = Book {
        // String 리터럴은 `&amp;'static str` 타입을 갖습니다.
        author: &quot;Douglas Hofstadter&quot;,
        title: &quot;Gödel, Escher, Bach&quot;,
        year: 1979,
    };

    // `immutabook`의 mutable 복사를 만들고 이를 `mutabook`으로 바인딩합니다.
    let mut mutabook = immutabook;

    // immutable 객체를 immutable하게 대여합니다.
    borrow_book(&amp;immutabook);

    // mutable 객체를 immutable하게 대여합니다.
    borrow_book(&amp;mutabook);

    // mutable 객체를 mutable하게 대여합니다.
    new_edition(&amp;mut mutabook);
    
    // ERROR : immutable 객체를 mutable하게 대여할 수는 없습니다.
    new_edition(&amp;mut immutabook);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="aliasing-1"><a class="header" href="#aliasing-1">Aliasing</a></h1>
<p>데이터는 여러번 immutable하게 대여될 수 있습니다. 하지만, immutable하게 대여가 된 이후, 해당 데이터의 원본은 mutable하게 대여될 수 없습니다. 한편으로, mutable 대여는 오직 한번에 하나씩만 가능합니다. 원본 데이터는 마지막으로 사용되는 mutable 참조 이후에야 또 다시 대여될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">struct Point { x: i32, y: i32, z: i32 }

fn main() {
    let mut point = Point { x: 0, y: 0, z: 0 };

    let borrowed_point = &amp;point;
    let another_borrow = &amp;point;

    // 데이터는 참조와 기존 소유자를 통해서 대여될 수 있습니다.
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // ERROR : `point`는 mutable하게 대여할 수 없습니다.
    // 이는 현재 immutable하게 대여된 상태로,
    // 바로 아래의 코드에서 사용되고 있기 때문입니다.
    let mutable_borrow = &amp;mut point; 

    // 대여한 데이터가 여기서 다시 사용됩니다.
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                borrowed_point.x, another_borrow.y, point.z);

    // `point`에 대한 immutable 참조가 더 이상 위에서 사용되지 않기 때문에,
    // 이제 mutable 참조로 다시 대여를 할 수 있습니다.
    let mutable_borrow = &amp;mut point;

    // mutable 참조로 데이터를 수정합니다.
    mutable_borrow.x = 5;
    mutable_borrow.y = 2;
    mutable_borrow.z = 1;

    // ERROR : `point`는 현재 mutable하게 대여되고 있습니다.
    // 따라서 이를 다시 immutable하게 대여할 수 없습니다.
    let y = &amp;point.y;

    // ERROR : `println!`은 immutable 참조를 받습니다.
    // 현재 mutable하게 대여 중인 `point`를 대여할 수 없습니다.
    println!(&quot;Point Z coordinate is {}&quot;, point.z);

    // 반면, mutable 참조 변수는 `println!`에
    // immutable하게 대여될 수 있습니다!
    println!(&quot;Point has coordinates: ({}, {}, {})&quot;,
                mutable_borrow.x, mutable_borrow.y, mutable_borrow.z);

    // `point`에 대한 mutable 참조가 더 이상 사용되지 않기 때문에,
    // 다시 immutable하게 대여될 수 있습니다.
    let new_borrowed_point = &amp;point;
    println!(&quot;Point now has coordinates: ({}, {}, {})&quot;,
             new_borrowed_point.x, new_borrowed_point.y, new_borrowed_point.z);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="the-ref-pattern"><a class="header" href="#the-ref-pattern">The ref pattern</a></h1>
<p><code>let</code> 바인딩으로 패턴을 매칭시키거나, 해체(destructuring)할 때, <code>ref</code> 키워드는 구조 혹은 튜플의 필드를 참조하기 위해 사용될 수 있습니다. 아래 예시는 이것이 유용한 몇가지 경우에 대해 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">#[derive(Clone, Copy)]
struct Point { x: i32, y: i32 }

fn main() {
    let c = 'Q';

    // 아래 할당의 좌측에 사용된 `ref` 대여는
    // 할당 우측에 `&amp;`를 사용하는 대여와 동일합니다.
    // 따라서, 아래의 둘은 그 원리가 동일합니다.
    let ref ref_c1 = c;
    let ref_c2 = &amp;c;

    println!(&quot;ref_c1 equals ref_c2: {}&quot;, *ref_c1 == *ref_c2);

    let point = Point { x: 0, y: 0 };

    // `ref` 또한 구조를 분해할 때 사용될 수 있습니다.
    let _copy_of_x = {
        // `ref_to_x`는 `point`의 `x` 필드에 대해 참조합니다.
        let Point { x: ref ref_to_x, y: _ } = point;

        // `point`의 `x` 필드의 복사를 반환합니다.
        *ref_to_x
    };

    // `point`의 mutable한 복사입니다.
    let mut mutable_point = point;

    {
        // mutable 참조를 받기 위해
        // `ref`가 `mut`와 함께 사용되었습니다.
        let Point { x: _, y: ref mut mut_ref_to_y } = mutable_point;

        // mutable 참조를 통해서
        // `mutable_point`의 `y` 필드를 수정합니다.
        *mut_ref_to_y = 1;
    }

    println!(&quot;point is ({}, {})&quot;, point.x, point.y);
    println!(&quot;mutable_point is ({}, {})&quot;, mutable_point.x, mutable_point.y);

    // 포인터를 갖는 mutable 튜플입니다.
    let mut mutable_tuple = (Box::new(5u32), 3u32);
    
    {
        // `mutable_tuple`을 분해하여
        // `last` 변수의 값으로 변경합니다.
        let (_, ref mut last) = mutable_tuple;
        *last = 2u32;
    }
    
    println!(&quot;tuple is {:?}&quot;, mutable_tuple);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h1>
<p>라이프타임(lifetime)은 컴파일러(구체적으로는, borrow checker)가 유효한 대여(borrow)만을 사용하도록 보장해줍니다. 변수의 라이프타임은 그것이 생성될 때 시작되어, 파괴될 때 끝납니다. 라이프타임과 스코프가 종종 같이 언급되는 경우가 많지만, 둘은 동일하지 않습니다.</p>
<p>예를 들어, 아래 예시는 <code>&amp;</code>를 통해 변수를 대여합니다. 대여의 라이프타임은 그것이 선언되는 위치에서 결정됩니다. 그 결과, 해당 대여는 대여자가 파괴되기 전까지 유효합니다. 그러나, 대여의 스코프는 참조가 사용되는 위치에 따라 결정됩니다.</p>
<p>아래 예시를 통해 스코프와 라이프타임이 어떻게 다른지를 확인하세요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 라이프타임은 각 변수의 생성 및 파괴에 따라 결정됩니다.
// `i`는 `main` 스코프에 둘러싸여 있으므로, 그 수명이 가장 깁니다.
// `borrow1`과 `borrow2`는 블럭으로 분리되어 있어
// 각 변수의 지속시간은 서로에게 무관합니다.
fn main() {
    let i = 3; // `i`의 라이프타임 시작     ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &amp;i; // `borrow1` 라이프타임 시작   ──┐│
        //                                                ││
        println!(&quot;borrow1: {}&quot;, borrow1); //              ││
    } // `borrow1` 끝   ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &amp;i; // `borrow2` 라이프타임 시작 . ──┐│
        //                                                ││
        println!(&quot;borrow2: {}&quot;, borrow2); //              ││
    } // `borrow2` 끝    ─────────────────────────────────┘│
    //                                                     │
}   // `i` 라이프타임 끝 ───────────────────────────────────┘
</code></pre></pre>
<p>라이프타임을 지정하는 별도의 이름이나 타입이 존재하지 않는다는 점을 유의하세요. 이는 추후 우리가 보게 될 내용처럼 라이프타임이 어떻게 사용될 수 있는지를 제한합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="explicit-annotation"><a class="header" href="#explicit-annotation">Explicit annotation</a></h1>
<p>borrow checker는 레퍼런스가 얼마나 오래동안 유효한지를 결정하기 위해 라이프 타임의 명시적인 지정을 사용합니다. Rust는 엘리션(Elision)을 사용하지 않은 경우, 참조의 라이프타임을 결정하기 위해 명시적인 지정을 요구합니다. 라이프타임을 명시적으로 지정하기 위한 문법은 다음과 같이 <code>'</code> 문자를 사용합니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo&lt;'a&gt;
// `foo` 는 `'a` 라이프타임 매개변수를 갖습니다.
<span class="boring">}
</span></code></pre></pre>
<p>클로저와 유사하게, 라이브타임의 사용은 제네릭을 요구합니다. 이에 덧붙여, 위의 라이프타임 문법은 <code>foo</code>의 라이프타임이 <code>'a</code>를 초과할 수 없음을 나타냅니다. 타입의 명시적인 지정은 <code>&amp;'a T</code> 형식을 갖습니다. 여기서의 <code>'a</code>는 위에서와 동일합니다.</p>
<p>여러 라이프타임을 가져야하는 경우, 문법은 아래와 같습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>foo&lt;'a, 'b&gt;
// `foo` 는 `'a` 와 `'b` 라이프타임 매개변수를 갖습니다.
<span class="boring">}
</span></code></pre></pre>
<p>이 경우, <code>foo</code>의 라이프타임 <code>'a</code>와 <code>'b</code>를 초과할 수 없습니다.</p>
<p>명시적인 라이프타임 지정은 아래 예시와 같이 사용될 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `print_refs`는 다른 라이프타임을 갖는 `'a`와 `'b`에 대한 두 참조를 갖습니다.
// 이 두 라이프타임은 적어도 `print_refs` 내에서는 유효합니다. 
fn print_refs&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;x is {} and y is {}&quot;, x, y);
}

// 아래 함수는 아무 인수를 갖지 않지만, `'a` 라이프타임 매개변수를 갖습니다.
fn failed_borrow&lt;'a&gt;() {
    let _x = 12;

    // ERROR : `_x`는 `'a`보다 더 오래 존재할 수 없습니다.
    let y: &amp;'a i32 = &amp;_x;
    // 이 함수 내에서 `'a` 라이프 타임을 명시적 타입 지정으로 사용하는 것은
    // `&amp;_x`가 `y`보다 짧은 라이프타임을 갖기 때문에 불가능 합니다.
    // 한 라이프타임은 그보다 더 긴 라이프타임으로 변환될 수 없습니다.
}

fn main() {
    // 아래에서 대여될 변수들을 생성합니다.
    let (four, nine) = (4, 9);
    
    // 두 변수들의 대여(`&amp;`)가 함수로 넘겨집니다.
    print_refs(&amp;four, &amp;nine);
    // 대여(borrowed)는 빌린 대상(borrower)보다 긴 라이프타임을 가져야합니다.
    // 다시 말해, `four`와 `nine`의 라이프타임은 `print_refs`의 라이프타임보다 길어야 합니다.
    
    failed_borrow();
    // `failed_borrow`는 `'a`가 함수의 라이프타임보다 더 길도록
    // 강제하는 참조가 존재하지 않지만, `'a`가 더 깁니다.
    // 이는 기본적으로 라이프타임이 제한되지 않기 때문입니다.
    // 라이프타임의 기본 값은 `'static`입니다.
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="functions-2"><a class="header" href="#functions-2">Functions</a></h1>
<p>엘리션(Elision)을 제외하면, 라이프 타임을 가진 함수의 선언에는 몇 가지 제약이 있습니다.</p>
<ul>
<li>참조는 <em>반드시</em> 라이프타임이 명시되어야 합니다.</li>
<li>반환되는 참조는 <em>반드시</em> 입력과 동일한 라이프타임을 갖거나, <code>static</code>이어야 합니다.</li>
</ul>
<p>덧붙여, 입력 없이 반환되는 참조는 유효하지 않은 데이터에 대한 참조를 반환할 경우 금지된다는 점을 주의하세요. 아래 예시는 라이프타임을 가진 몇가지 유효한 형태의 함수를 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 적어도 해당 함수의 라이프타임을 갖는
// `'a` 라이프타임을 가진 참조 입력입니다.
fn print_one&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`print_one`: x is {}&quot;, x);
}

// 라이브타임을 가진 mutable 참조도 가능합니다.
fn add_one&lt;'a&gt;(x: &amp;'a mut i32) {
    *x += 1;
}

// 다른 라이프타임을 가진 여러 요소들을 사용합니다.
// 이 경우, 동일한 라이프 타임 `'a`를 갖더라도 문제 없습니다.
// 다만 대부분의 복잡한 경우에는 다른 라이프타임들이 요구됩니다.
fn print_multi&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32) {
    println!(&quot;`print_multi`: x is {}, y is {}&quot;, x, y);
}

// 입력받은 참조를 그대로 반환하는 것은 가능합니다.
// 다만, 이 경우 올바른 라이프타임이 반환되어야 합니다.
fn pass_x&lt;'a, 'b&gt;(x: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'a i32 { x }

// ERROR : `'a`는 해당 함수보다 더 긴 라이프타임을 가져야 합니다.
// 여기서, `&amp;String::from(&quot;foo&quot;)`는 참조에 따른 `String`을 생성합니다.
// 스코프가 종료되면, 해당 데이터는 삭제되고,
// 이 경우 잘못된 데이터에 대한 참조가 반환됩니다.
// 따라서, 아래는 에러를 발생시킵니다.
fn invalid_output&lt;'a&gt;() -&gt; &amp;'a String { &amp;String::from(&quot;foo&quot;) }

fn main() {
    let x = 7;
    let y = 9;
    
    print_one(&amp;x);
    print_multi(&amp;x, &amp;y);
    
    let z = pass_x(&amp;x, &amp;y);
    print_one(z);

    let mut t = 3;
    add_one(&amp;mut t);
    print_one(&amp;t);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="methods-1"><a class="header" href="#methods-1">Methods</a></h1>
<p>메서드들도 함수와 유사하게 지정됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Owner(i32);

impl Owner {
    // 독립적인 함수에 라이프타임을 지정해줍니다.
    fn add_one&lt;'a&gt;(&amp;'a mut self) { self.0 += 1; }
    fn print&lt;'a&gt;(&amp;'a self) {
        println!(&quot;`print`: {}&quot;, self.0);
    }
}

fn main() {
    let mut owner = Owner(18);

    owner.add_one();
    owner.print();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="structs-1"><a class="header" href="#structs-1">Structs</a></h1>
<p>구조(structure)에서의 라이프타임 지정도 함수와 유사합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `Borrowed` 타입은 `i32`에 대한 참조를 보유합니다.
// `i32` 참조의 라이프타임은 `Borrowed`의 라이프타임보다 길어야 합니다.
#[derive(Debug)]
struct Borrowed&lt;'a&gt;(&amp;'a i32);

// 유사하게, 두 입력 참조 역시 해당 구조보다 라이프타임이 길어야 합니다.
#[derive(Debug)]
struct NamedBorrowed&lt;'a&gt; {
    x: &amp;'a i32,
    y: &amp;'a i32,
}

// 아래 `enum`은 `i32` 또는 그에 대한 참조가 될 수 있습니다.
#[derive(Debug)]
enum Either&lt;'a&gt; {
    Num(i32),
    Ref(&amp;'a i32),
}

fn main() {
    let x = 18;
    let y = 15;

    let single = Borrowed(&amp;x);
    let double = NamedBorrowed { x: &amp;x, y: &amp;y };
    let reference = Either::Ref(&amp;x);
    let number    = Either::Num(y);

    println!(&quot;x is borrowed in {:?}&quot;, single);
    println!(&quot;x and y are borrowed in {:?}&quot;, double);
    println!(&quot;x is borrowed in {:?}&quot;, reference);
    println!(&quot;y is *not* borrowed in {:?}&quot;, number);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits-1"><a class="header" href="#traits-1">Traits</a></h1>
<p>트레이트 메서드에서의 라이프타임 지정은 기본적으로 함수와 유사하니다. <code>impl</code> 역시 라이프타임 지정이 가능함을 기억하세요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 라이프타임의 지정을 가진 구조
#[derive(Debug)]
 struct Borrowed&lt;'a&gt; {
     x: &amp;'a i32,
 }

// impl에 대한 라이프타임 지정
impl&lt;'a&gt; Default for Borrowed&lt;'a&gt; {
    fn default() -&gt; Self {
        Self {
            x: &amp;10,
        }
    }
}

fn main() {
    let b: Borrowed = Default::default();
    println!(&quot;b is {:?}&quot;, b);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="bounds-1"><a class="header" href="#bounds-1">Bounds</a></h1>
<p>제네릭 타입이 제한(bound)될 수 있었던 것처럼, 라이프타임(사실, 그 자체가 제네릭입니다.) 역시 제한을 가질 수 있습니다. <code>:</code> 문자는 여기서 조금 다른 의미를 가지는 반면, <code>+</code>는 동일합니다.</p>
<ol>
<li><code>T: 'a</code>: <code>T</code> 내의 모든 참조는 반드시 <code>'a</code> 보다 라이프타임이 길어야 합니다.</li>
<li><code>T: Trait + 'a</code>: <code>T</code> 타입은 반드시 <code>Trait</code> 트레이트를 구현하고, 모든 <code>T</code> 내의 참조들은 반드시 <code>'a</code>보다 라이프타임이 길어야 합니다. </li>
</ol>
<p>아래의 예제는 <code>where</code> 키워드 다음에 위와 같이 라이프타임 제한을 적용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt::Debug; // 제한을 적용할 트레이트입니다.

#[derive(Debug)]
struct Ref&lt;'a, T: 'a&gt;(&amp;'a T);
// `Ref`는 알 수 없는 라이프타임 `'a`를 가진 제네릭 타입 `T`에 대한 참조를 갖습니다.
// `T` 내의 모든 참조들은 반드시 `'a`보다 긴 라이프타임을 가져야 합니다.
// 추가로, `Ref`의 라이프타임은 `'a`를 초과하지 않습니다.

// `Debug` 트레이트를 사용하여 출력하는 제네릭 함수입니다.
fn print&lt;T&gt;(t: T) where
    T: Debug {
    println!(&quot;`print`: t is {:?}&quot;, t);
}

// `T`에 위치할 참조는 `Debug`를 구현해야 하며,
// `T` 의 모든 참조들은 `'a`보다 긴 라이프타임을 가져야 합니다.
// 추가로 `'a`는 반드시 본인 함수보다 라이프타임이 길어야 합니다.
fn print_ref&lt;'a, T&gt;(t: &amp;'a T) where
    T: Debug + 'a {
    println!(&quot;`print_ref`: t is {:?}&quot;, t);
}

fn main() {
    let x = 7;
    let ref_x = Ref(&amp;x);

    print_ref(&amp;ref_x);
    print(ref_x);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="coercion"><a class="header" href="#coercion">Coercion</a></h1>
<p>라이프타임은 보다 짧은 라이프타임으로 변환될 수 있으며, 이를 통해 일반적으로는 작동할 수 없는 스코프 내에서도 동작하도록 할수 있습니다. 이는 Rust 컴파일러에 의해 추론 변형(inferred coercion)의 형태 또는 라이프타임의 변경을 정의하는 형태로 이루어질 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 여기서, Rust는 가능한 짧은 쪽으로 라이프타임을 추론합니다.
// 두 참조들은 더 짧은 쪽의 라이프타임으로 변환됩니다.
fn multiply&lt;'a&gt;(first: &amp;'a i32, second: &amp;'a i32) -&gt; i32 {
    first * second
}

// `&lt;'a: 'b, 'b&gt;` : `'a`는 적어도 `'b`만큼의 라이프타임을 갖습니다.
// 아래 함수에서 우리는 `&amp;'a i32`를 받아서 변환하여 `&amp;'b i32`를 반환합니다.
fn choose_first&lt;'a: 'b, 'b&gt;(first: &amp;'a i32, _: &amp;'b i32) -&gt; &amp;'b i32 {
    first
}

fn main() {
    let first = 2; // 더 긴 라이프타임
    
    {
        let second = 3; // 더 짧은 라이프 타임
        
        println!(&quot;The product is {}&quot;, multiply(&amp;first, &amp;second));
        println!(&quot;{} is the first&quot;, choose_first(&amp;first, &amp;second));
    };
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="static"><a class="header" href="#static">Static</a></h1>
<p>Rust에는 몇 가지 지정된(reserved) 라이프타임 이름이 있습니다. 그 중 하나가 <code>'static</code>입니다. 아마 다음과 같은 두 가지 상황에 이를 마주하게 될 것입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 'static 라이프타임을 갖는 참조
let s: &amp;'static str = &quot;hello world&quot;;

// 트레이트 제한의 일부로 'static을 갖는 경우
fn generic&lt;T&gt;(x: T) where T: 'static {}
</code></pre></pre>
<p>양쪽 다 서로 관련이 있긴 하지만 미묘하게 다르며, 이는 Rust를 배울때 종종 혼란을 일으킵니다. 이제 각각의 상황에 대한 예시에 대해 알아봅시다.</p>
<h2 id="reference-lifetime"><a class="header" href="#reference-lifetime">Reference lifetime</a></h2>
<p>참조 라이프타임으로 쓰인 <code>'static</code>은 참조가 가리키는 데이터의 라이프타임이 프로그램 실행 내내 유지됨을 의미합니다. 이는 여전히 더 짧은 라이프타임으로 변환될 수 있습니다.</p>
<p><code>'static</code> 라이프타임을 갖는 변수를 만드는 두 가지 방법이 있으며, 두 방법 모두 바이너리 내의 읽기 전용 메모리에 저장됩니다.</p>
<ul>
<li><code>static</code> 선언으로 상수를 생성하는 방법</li>
<li><code>&amp;'static str</code> 타입으로 <code>string</code> 리터럴을 만드는 방법</li>
</ul>
<p>각 방법을 사용하는 예시를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `'static` 라이프타임을 갖는 상수를 만듭니다.
static NUM: i32 = 18;

// `'static` 라이프타임이 입력 인수의 라이프타임으로 변환되는
// `NUM`에 대한 참조를 반환합니다.
fn coerce_static&lt;'a&gt;(_: &amp;'a i32) -&gt; &amp;'a i32 {
    &amp;NUM
}

fn main() {
    {
        // `string` 리터럴을 만들고 출력합니다.
        let static_string = &quot;I'm in read-only memory&quot;;
        println!(&quot;static_string: {}&quot;, static_string);

        // `static_string`이 스코프를 벗어날 때,
        // 참조는 더 이상 사용될 수 없습니다.
        // 따라서 데이터는 바이너리 내에서 유지됩니다.
    }

    {
        // `coerce_static`을 사용하기 위한 정수를 만듭니다.
        let lifetime_num = 9;

        // `NUM`을 `lifetime_num`의 라이프타임으로 변환합니다.
        let coerced_static = coerce_static(&amp;lifetime_num);

        println!(&quot;coerced_static: {}&quot;, coerced_static);
    }

    println!(&quot;NUM: {} stays accessible!&quot;, NUM);
}
</code></pre></pre>
<h2 id="trait-bound"><a class="header" href="#trait-bound">Trait bound</a></h2>
<p>트레이트 제한의 경우, 해당 타입은 정적이지 않은 참조는 포함하지 않는다는 것을 의미합니다. 예를 들어, 참조의 수신자는 원하는 한 해당 타입을 계속 유지할 수 있으며, 수신자가 사라질 때까지 절대 무효(invalid)해지지 않습니다.</p>
<p>이는 소유한 모든 데이터의 경우(참조가 아닌 경우) <code>'static</code>' 라이프타임 제한을 통과한다는 것을 의미하지만, 해당 소유 데이터에 대한 <strong>참조</strong>는 일반적으로 그렇지 않다는 것을 의미합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt::Debug;

fn print_it( input: impl Debug + 'static ) {
    println!( &quot;'static value passed in is: {:?}&quot;, input );
}

fn main() {
    // `i`는 소유된 상태이며, 아무런 참조도 갖고 있지 않습니다.
    // 그러므로, 이는 `'static`에 해당합니다.
    let i = 5;
    print_it(i);

    // `&amp;i`는 오직 `use_it()`의 스코프에 의해 정의된 라이프타임을 갖습니다.
    // 따라서, 이는 `'static`이 아닙니다.
    print_it(&amp;i);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="elision"><a class="header" href="#elision">Elision</a></h1>
<p>일부 라이프타임 패턴은 지극히 일반적이기 때문에, borrow checker는 이를 생략하는 것을 허용합니다. 덕분에 타이핑을 줄이고 가독성을 향상시킬 수 있습니다. 이를 일리전(Elision)이라 합니다. 이러한 패턴들은 지극히 일반적이기 때문에, 일리전은 오로지 Rust에만 존재합니다.</p>
<p>아래 코드는 일리전의 일부 예시들을 보여줍니다. 일리전에 대한 더 심도있는 설명을 보고 싶다면, <a href="https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html#lifetime-elision">여기</a>를 살펴보세요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `elided_input`과 `annotated_input`은 근본적으로는 동일한 방식의 할당입니다.
// `elided_input`의 라이프타임은 컴파일러에 의해 추론될 수 있기 때문입니다.
fn elided_input(x: &amp;i32) {
    println!(&quot;`elided_input`: {}&quot;, x);
}

fn annotated_input&lt;'a&gt;(x: &amp;'a i32) {
    println!(&quot;`annotated_input`: {}&quot;, x);
}

// 이와 유사하게, `elided_pass`와 `annotated_pass`도 근본적으로는 같습니다.
// `elided_pass`에 대한 라이프타임이 암시적으로 추가되기 때문입니다. 
fn elided_pass(x: &amp;i32) -&gt; &amp;i32 { x }

fn annotated_pass&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32 { x }

fn main() {
    let x = 3;

    elided_input(&amp;x);
    annotated_input(&amp;x);

    println!(&quot;`elided_pass`: {}&quot;, elided_pass(&amp;x));
    println!(&quot;`annotated_pass`: {}&quot;, annotated_pass(&amp;x));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="traits-2"><a class="header" href="#traits-2">Traits</a></h1>
<p><strong>트레이트</strong>는 unknown 타입(<code>Self</code>)에 대해 정의하는 메서드의 컬렉션입니다. 트레이트 각각은 동일한 트레이트 내에 정의된 다른 메서드들에 접근할 수 있습니다.</p>
<p>트레이트들은 어떤 데이터 타입에 대해서도 구현될 수 있습니다. 아래 예시에서, 우리는 <code>Animal</code>이라고 하는 메서드 모음을 정의할 것입니다. 이 <code>Animal</code> 트레이트는 <code>Sheep</code> 데이터 타입에 대해서 구현될 것이고, 이에 따라 <code>Sheep</code> 타입에서 <code>Animal</code>로부터의 메서드를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Sheep { naked: bool, name: &amp;'static str }

trait Animal {
    // 정적 메서드 선언;
    // `Self`는 구현자(implementor) 타입을 나타냅니다.
    fn new(name: &amp;'static str) -&gt; Self;

    // 인스턴스 메서드 선언
    // 아래 함수들은 string을 반환합니다.
    fn name(&amp;self) -&gt; &amp;'static str;
    fn noise(&amp;self) -&gt; &amp;'static str;

    // 트레이트는 기본 메서드 정의를 제공할 수 있습니다.
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // 구현자 메서드는 구현자의 트레이트 메서드를 사용할 수 있습니다.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// `Sheep`에 대해 `Animal` 트레이트를 구현합니다.
impl Animal for Sheep {
    // `Self`는 구현자 타입입니다. 여기서는 `Sheep`에 해당합니다.
    fn new(name: &amp;'static str) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; &amp;'static str {
        self.name
    }

    fn noise(&amp;self) -&gt; &amp;'static str {
        if self.is_naked() {
            &quot;baaaaah?&quot;
        } else {
            &quot;baaaaah!&quot;
        }
    }
    
    // 기본 트레이트 메서드들은 오버라이딩될 수 있습니다.
    fn talk(&amp;self) {
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // 이 경우, 타입 지정은 필수적입니다.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;);

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="derive"><a class="header" href="#derive">Derive</a></h1>
<p>컴파일러는 <code>#[derive]</code> 어트리뷰트를 통해 일부 트레이트에 대한 기본적인 구현을 제공할 수 있습니다. 이들 트레이트들은 더 복잡한 로직이 요구되는 경우에는 여전히 수동으로 구현될 수 있습니다.</p>
<p>아래는 <code>derive</code> 가능한 트레이트들의 목록입니다.</p>
<ul>
<li>비교 트레이트들: <code>Eq</code>, <code>PartialEq</code>, <code>Ord</code>, <code>PartialOrd</code></li>
<li><code>Clone</code>, <code>&amp;T</code>로부터 복사를 통해 <code>T</code>를 만듭니다.</li>
<li><code>Copy</code>, 'move semantics' 대신에 'copy semantics' 타입을 지정합니다.</li>
<li><code>Hash</code>, <code>&amp;T</code>로부터 해쉬를 계산합니다.</li>
<li><code>Default</code>, 데이터 타입의 비어있는 인스턴스를 생성합니다.</li>
<li><code>Debug</code>, <code>{:?}</code> 포맷에 사용할 값을 지정합니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `Centimeters`는 비교 가능한 튜플 구조입니다.
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`는 출력 가능한 튜플 구조입니다.
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// `Seconds`는 별 다른 추가 어트리뷰트가 없는 튜플 구조입니다.
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    // ERROR : `Seconds`는 `Debug` 트레이트를 구현하지 않았기에 출력될 수 없습니다.
    println!(&quot;One second looks like: {:?}&quot;, _one_second);

    // ERROR : `Seconds`는 `PartialEq` 트레이트를 구현하지 않았기에 비교될 수 없습니다.
    let _this_is_true = (_one_second == _one_second);

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="returning-traits-with-dyn"><a class="header" href="#returning-traits-with-dyn">Returning Traits with dyn</a></h1>
<p>Rust 컴파일러는 모든 함수들의 반환 타입이 요구하는 공간이 어느 정도인지 알아야합니다. 다시 말해, Rust에서 구현하는 모든 함수의 반환 타입은 콘크리트(concrete) 타입입니다. 다른 언어들과는 다르게, 만약, <code>Animal</code>과 같은 트레이트를 갖고 있다면, 이 <code>Animal</code>을 반환하는 함수를 작성할 수 없습니다. 다른 구현들은 메모리의 다른 부분들을 차지할 것이기 때문입니다.</p>
<p>하지만, 쉬운 해결 방안이 있습니다. 트레이트 객체를 곧바로 반환하는 대신, <code>Animal</code>을 담은 <code>Box</code>를 반환하는 것입니다. <code>Box</code>는 힙 내의 특정 메모리에 대한 단순한 참조입니다. 참조는 정적으로 알려진(statically-known) 사이즈를 보유하기 때문에, 컴파일러는 힙에 할당된 <code>Animal</code>에 대한 참조를 보장합니다. 이를 통해, 함수에서도 트레이트를 반환할 수 있습니다!</p>
<p>Rust는 힙에 메모리를 할당할 때마다 가능한 명시적으로 하려고 합니다. 따라서, 만약 함수가 아래 방식으로 <em>힙에 있는 트레이트에 대한 포인터</em>(pointer-to-trait-on-heap)를 반환한다면, 반환 타입을 <code>dyn</code> 키워드와 함께 작성해주어야 합니다. (ex. <code>Box&lt;dyn Animal&gt;</code>)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Sheep {}
struct Cow {}

trait Animal {
    // 인스턴스 메서드 서명
    fn noise(&amp;self) -&gt; &amp;'static str;
}

// `Sheep`에 대한 `Animal` 트레이트 구현
impl Animal for Sheep {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;baaaaah!&quot;
    }
}

// `Cow`에 대한 `Animal` 트레이트 구현
impl Animal for Cow {
    fn noise(&amp;self) -&gt; &amp;'static str {
        &quot;moooooo!&quot;
    }
}

// `Animal`을 구현하는 어떤 구조를 반환합니다.
// 여전히 컴파일 시점에는 무엇이 반환될지 모릅니다.
fn random_animal(random_number: f64) -&gt; Box&lt;dyn Animal&gt; {
    if random_number &lt; 0.5 {
        Box::new(Sheep {})
    } else {
        Box::new(Cow {})
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="operator-overloading"><a class="header" href="#operator-overloading">Operator Overloading</a></h1>
<p>Rust에서는 여러 연산자가 트레이트에 의해 오버로딩될 수 있습니다. 다시 말해, 일부 연산자들이 그들의 입력 인수에 기반하여 다른 동작을 수행하도록 할 수 있습니다. 이것이 가능한 이유는 각 연산자가 메서드 호출에 대한 Syntactic sugar 이기 때문입니다. 예를 들어, <code>a + b</code> 에서의 <code>+</code> 연산자는 사실 <code>a.add(b)</code>와 같이 <code>add</code> 메서드를 호출하는 것입니다. 이 <code>add</code> 메서드는 <code>Add</code> 트레이트의 일부입니다. 그러므로 <code>+</code> 연산자는 <code>Add</code> 트레이트의 구현자를 통해 사용될 수 있습니다.</p>
<p><code>Add</code>와 같은 트레이트들의 오버로드 연산자의 목록은 <a href="https://doc.rust-lang.org/core/ops/"><code>core::ops</code></a>에서 찾아볼 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::ops;

struct Foo;
struct Bar;

#[derive(Debug)]
struct FooBar;

#[derive(Debug)]
struct BarFoo;

// `std::ops:Add` 트레이트는 `+`의 기능을 구체화하기 위해 사용됩니다.
// 여기서 `Add&lt;Bar&gt;`는 RHS(연산자 우측)의 `Bar` 타입에 대한 트레이트입니다.
// 이후의 블럭은 다음 연산을 수행합니다. : Foo + Bar = FooBar 
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        println!(&quot;&gt; Foo.add(Bar) was called&quot;);

        FooBar
    }
}

// 여기서 `Add&lt;Foo&gt;`는 RHS의 `Foo` 타입에 대한 트레이트입니다.
// 이후의 블럭은 다음 연산을 수행합니다. : Bar + Foo = BarFoo
impl ops::Add&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn add(self, _rhs: Foo) -&gt; BarFoo {
        println!(&quot;&gt; Bar.add(Foo) was called&quot;);

        BarFoo
    }
}

fn main() {
    println!(&quot;Foo + Bar = {:?}&quot;, Foo + Bar);
    println!(&quot;Bar + Foo = {:?}&quot;, Bar + Foo);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p><code>Drop</code> 트레이트는 오직 하나의 메서드 <code>drop</code>만 갖습니다. 이는 객체가 스코프를 벗어났을 때 호출됩니다. <code>Drop</code> 트레이트의 주된 사용은 구현자 인스턴스가 소유한 리소스들을 비우기 위함입니다.</p>
<p><code>Box</code>, <code>Vec</code>, <code>String</code>, <code>File</code>, 그리고 <code>Process</code>는 리소스를 비우기 위해 <code>Drop</code> 트레이트를 구현한 타입들의 예시입니다. <code>Drop</code> 트레이트는 커스텀 데이터 타입에 대해서 수동으로 구현될 수 있습니다.</p>
<p>아래는 <code>drop</code> 함수가 실행될 때 콘솔에 문구를 출력해보는 예시입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Droppable {
    name: &amp;'static str,
}

// `drop`에 콘솔 출력을 추가하는 간단한 구현입니다.
impl Drop for Droppable {
    fn drop(&amp;mut self) {
        println!(&quot;&gt; Dropping {}&quot;, self.name);
    }
}

fn main() {
    let _a = Droppable { name: &quot;a&quot; };

    // block A
    {
        let _b = Droppable { name: &quot;b&quot; };

        // block B
        {
            let _c = Droppable { name: &quot;c&quot; };
            let _d = Droppable { name: &quot;d&quot; };

            println!(&quot;Exiting block B&quot;);
        }
        println!(&quot;Just exited block B&quot;);

        println!(&quot;Exiting block A&quot;);
    }
    println!(&quot;Just exited block A&quot;);

    // `drop` 함수를 사용하면 수동으로 리소스를 해제할 수 있습니다.
    drop(_a);

    println!(&quot;end of the main function&quot;);

    // `_a`는 이미 위에서 `drop`되었기 때문에, 
    // 여기서 다시 `drop`이 호출되진 않습니다.
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iterators"><a class="header" href="#iterators">Iterators</a></h1>
<p>반복자([Iterator])(https://doc.rust-lang.org/core/iter/trait.Iterator.html) 트레이트는 Array와 같은 컬렉션 내의 순회를 구현하기 위해 사용됩니다.</p>
<p>해당 트레이트는 <code>next</code> 요소를 정의하는 하나의 메서드만을 요구하며, 이는 <code>impl</code> 블럭을 통해 직접 구현하거나, 자동으로 정의됩니다.(array나 range의 경우에는)</p>
<p>일반적인 상황에서 편리한 점으로, <code>for</code> 문은 <code>.into_iter()</code> 메서드를 사용하여 일부 컬렉션들을 반복자로 변경해줍니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Fibonacci {
    curr: u32,
    next: u32,
}

// `Fibonacci`에 대한 `Iterator`를 구현합니다.
// `Iterator` 트레이트는 오직 `next` 요소에 대해
// 구현하는 하나의 메서드만 요구합니다.
impl Iterator for Fibonacci {
    type Item = u32;

    // 여기서, 우리는 `.curr`과 `.next`를 통해 순서를 정의합니다.
    // 반환타입은 `Option&lt;T&gt;`입니다 :
    //    * `Iterator`가 종료되었을 때, `None`이 반환됩니다.
    //    * 그렇지 않은 경우, `Some`으로 감싸진 다음 값이 반환됩니다.
    fn next(&amp;mut self) -&gt; Option&lt;u32&gt; {
        let new_next = self.curr + self.next;

        self.curr = self.next;
        self.next = new_next;

        // 피보나치 수에는 끝이 없기 때문에,
        // `Iterator`는 절대 `None`을 반환하지 않습니다.
        // 따라서 항상 `Some`이 반환됩니다.
        Some(self.curr)
    }
}

// 피보나치 배열 생성기를 반환합니다.
fn fibonacci() -&gt; Fibonacci {
    Fibonacci { curr: 0, next: 1 }
}

fn main() {
    // `0..3`은 `0, 1, 2`은 생성하는 반복자입니다.
    let mut sequence = 0..3;

    println!(&quot;Four consecutive `next` calls on 0..3&quot;);
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());
    println!(&quot;&gt; {:?}&quot;, sequence.next());

    // `for`는 `None` 반환 전까지 `Iterator`를 통해 동작합니다.
    // 각각의 `Some`값의 래핑이 해제된 후 변수(`i`)에 바인딩됩니다.
    println!(&quot;Iterate through 0..3 using `for`&quot;);
    for i in 0..3 {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `take(n)` 메서드는 첫 `n`개의 값만큼
    // 반복자를 진행합니다.
    println!(&quot;The first four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    // `skip(n)` 메서드는 첫 `n`개의 값만큼을 버리고
    // 반복자를 진행합니다.
    println!(&quot;The next four terms of the Fibonacci sequence are: &quot;);
    for i in fibonacci().skip(4).take(4) {
        println!(&quot;&gt; {}&quot;, i);
    }

    let array = [1u32, 3, 3, 7];

    // `iter` 메서드는 array/slice에 대한
    // `Iterator`를 생성해냅니다.
    println!(&quot;Iterate the following array {:?}&quot;, &amp;array);
    for i in array.iter() {
        println!(&quot;&gt; {}&quot;, i);
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="impl-trait"><a class="header" href="#impl-trait">impl Trait</a></h1>
<p>함수가 <code>MyTrait</code>를 구현한 타입을 반환한다고 할 때, 이를 <code>-&gt; impl MyTrait</code>와 같이 작성할 수 있습니다. 이는 타입 시그니처를 굉장히 간단하게 만들도록 해줍니다!</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::iter;
use std::vec::IntoIter;

// 아래 함수는 두 개의 `Vec&lt;i32&gt;`를 합쳐
// 이에 대한 Iterator를 반환합니다.
fn combine_vecs_explicit_return_type(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; iter::Cycle&lt;iter::Chain&lt;IntoIter&lt;i32&gt;, IntoIter&lt;i32&gt;&gt;&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

// 아래는 정확히 동일한 함수입니다.
// 하지만 반환 타입으로 `impl Trait`를 사용하고 있습니다.
// 훨씬 간결해보이네요!
fn combine_vecs(
    v: Vec&lt;i32&gt;,
    u: Vec&lt;i32&gt;,
) -&gt; impl Iterator&lt;Item=i32&gt; {
    v.into_iter().chain(u.into_iter()).cycle()
}

fn main() {
    let v1 = vec![1, 2, 3];
    let v2 = vec![4, 5];
    let mut v3 = combine_vecs(v1, v2);
    assert_eq!(Some(1), v3.next());
    assert_eq!(Some(2), v3.next());
    assert_eq!(Some(3), v3.next());
    assert_eq!(Some(4), v3.next());
    assert_eq!(Some(5), v3.next());
    println!(&quot;all done&quot;);
}
</code></pre></pre>
<p>더 중요한 점은, 일부 Rust 타입은 기록할 수 없다는 점입니다. 예를 들어, 모든 클로저는 고유한 이름이 존재하지 않는 콘크리트 타입을 갖습니다. <code>impl Trait</code>를 사용하지 않는다면, 클로저를 반환할 때는 이를 직접 힙에 할당해주어야 합니다. 그러나, 이제 이를 완전히 정적으로 처리할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 함수의 입력에 `y`를 추가하는 함수를 반환합니다. 
fn make_adder_function(y: i32) -&gt; impl Fn(i32) -&gt; i32 {
    let closure = move |x: i32| { x + y };
    closure
}

fn main() {
    let plus_one = make_adder_function(1);
    assert_eq!(plus_one(2), 3);
}
</code></pre></pre>
<p><code>impl Trait</code>를 <code>map</code> 또는 <code>filter</code> 클로저를 사용하는 반복자를 반환하도록 사용할 수도 있습니다. 이는 <code>map</code>과 <code>filter</code>의 사용을 더 쉽게 만들어줍니다. 클로저 타입들은 이름이 존재하지 않기 때문에, 함수가 클로저와 함께 반복자를 반환하는 경우, 반환 타입을 명시적으로 작성해줄 수 없습니다. 그러나 <code>impl Trait</code>를 통해 이를 손 쉽게 해결할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn double_positives&lt;'a&gt;(numbers: &amp;'a Vec&lt;i32&gt;) -&gt; impl Iterator&lt;Item = i32&gt; + 'a {
    numbers
        .iter()
        .filter(|x| x &gt; &amp;&amp;0)
        .map(|x| x * 2)
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="clone"><a class="header" href="#clone">Clone</a></h1>
<p>리소스를 다룰 때의 기본 동작은, 할당 또는 함수의 호출 중에 이들을 전송하는 것입니다. 그러나, 때때로 리소스에 대한 복사본을 만들어야 하는 경우가 있습니다.</p>
<p><code>Clone</code> 트레이트는 정확히 이를 수행해줌으로써 우리를 돕습니다. 가장 일반적으로, 우리는 <code>Clone</code> 트레이트에 의해 정의된 <code>clone()</code> 메서드를 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 리소스가 존재하지 않는 유닛 구조입니다.
#[derive(Debug, Clone, Copy)]
struct Unit;

// `Clone` 트레이트를 구현하는, 리소스를 가진 튜플 구조입니다.
#[derive(Clone, Debug)]
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

fn main() {
    // `Unit`으로 초기화합니다.
    let unit = Unit;
    // `Unit`을 복사합니다.
    // 여기서는 &quot;이동&quot;시킬 별다른 리소스가 없습니다.
    let copied_unit = unit;

    // 두 `Unit` 모두 독립적으로 사용될 수 있습니다.
    println!(&quot;original: {:?}&quot;, unit);
    println!(&quot;copy: {:?}&quot;, copied_unit);

    // `Pair`로 초기화 합니다.
    let pair = Pair(Box::new(1), Box::new(2));
    println!(&quot;original: {:?}&quot;, pair);

    // `pair`를 `moved_pair`로 이동시킵니다.
    // 리소스의 이동이 발생합니다.
    let moved_pair = pair;
    println!(&quot;moved: {:?}&quot;, moved_pair);

    // ERROR : `pair`는 본인의 리소스를 잃었습니다.
    println!(&quot;original: {:?}&quot;, pair);

    // `moved_pair`를 `cloned_pair`로 복사합니다.
    // 여기엔 리소스의 이동도 포함됩니다.
    let cloned_pair = moved_pair.clone();
    // 기존의 `Pair`를 `std::mem::drop`으로 제거합니다.
    drop(moved_pair);

    // ERROR : `moved_pair`는 제거되었습니다.
    println!(&quot;copy: {:?}&quot;, moved_pair);

    // .clone()을 통해 리소스를 옮겨온 `cloned_pair`는 여전히 사용 가능합니다.
    println!(&quot;clone: {:?}&quot;, cloned_pair);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h1>
<p>Rust에는 <em>상속</em>이라는 개념이 없습니다. 그러나 다른 트레이트에 대한 슈퍼셋이 되는 트레이트(Supertraits)를 정의할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person은 Student의 슈퍼트레이트 입니다.
// Student의 구현은 Person에 대한 구현 역시 요구합니다.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// `CompSciStudent` 는 `Programmer`와 `Student`의 서브트레이트(subtrait)입니다.
// 이에 대한 구현은 양쪽의 슈퍼트레이트에 대한 구현을 모두 요구합니다.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

fn main() {}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="disambiguating-overlapping-traits"><a class="header" href="#disambiguating-overlapping-traits">Disambiguating overlapping traits</a></h1>
<p>하나의 타입에는 여러 트레이트를 구현할 수 있습니다. 만약, 동일한 이름을 요구하는 두 개의 트레이트가 있다면 어떨까요? 예를 들어, 많은 트레이트들이 <code>get()</code>이라는 이름의 메서드를 가질 수 있을겁니다. 이들은 심지어 각자 다 다른 반환 타입을 가질겁니다.</p>
<p><em>좋은 소식</em> : 각각의 트레이트 구현은 고유한 <code>impl</code> 블럭을 갖기 때문에, 어떤 트레이트의 <code>get</code> 메서드에 구현하려고 하는지에 대해 분명합니다.</p>
<p>이들 메서드를 호출해야 하는 경우에는 어떨까요? 이들 간의 애매함을 없애려면, 정규화된 구문(Fully Qualified Syntax)을 사용해야 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">trait UsernameWidget {
    // 해당 위젯에서 선택된 사용자 이름을 가져옵니다.
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // 해당 위젯에서 선택된 나이를 가져옵니다.
    fn get(&amp;self) -&gt; u8;
}

// `UsernameWidget`과 `AgeWidget`에 대한 폼(Form)입니다.
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // ERROR : `Form`에는 여러 트레이트에 대해 구현된
    // `get` 메서드들이 존재하므로, `form.get()`은 모호합니다.
    // 따라서 아래는 &quot;multiple `get` found&quot; 에러가 발생합니다.
    println!(&quot;{}&quot;, form.get());

    // 조금 성가시더라도, 아래와 같이 호출되어야 합니다.
    let username = &lt;Form as UsernameWidget&gt;::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = &lt;Form as AgeWidget&gt;::get(&amp;form);
    assert_eq!(28, age);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="macro_rules"><a class="header" href="#macro_rules">macro_rules!</a></h1>
<p>Rust는 <a href="https://ko.wikipedia.org/wiki/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D">메타프로그래밍</a>을 가능하게 하는 강력한 매크로 시스템을 제공합니다. 이전 챕터에서 봤던 것처럼, 매크로는 <code>!</code>문자로 끝난다는 것을 제외하면 함수와 비슷합니다. 그러나 함수의 호출을 생성하는 대신, 매크로는 소스코드로 확장되어 프로그램의 나머지 부분과 함께 컴파일 됩니다. 하지만 C나 다른 언어에서의 마크로와는 다르게, Rust의 매크로는 문자열에 대한 사전처리가 아닌, 추상 구문 트리로 확장되어 있으므로, 예상치 못한 우선순위 버그가 발생하지 않습니다.</p>
<p>매크로는 <code>macro_rules!</code> 매크로를 통해 생성됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">// 이는 `say_hello`라고 하는 간단한 매크로입니다.
macro_rules! say_hello {
    // `()`는 매크로가 아무 인수도 받지 않음을 의미합니다.
    () =&gt; {
        // 매크로는 해당 블럭의 컨텐츠로 확장됩니다.
        println!(&quot;Hello!&quot;);
    };
}

fn main() {
    // 아래 호출은 `println!(&quot;Hello&quot;);`로 확장됩니다.
    say_hello!()
}
</code></pre></pre>
<p>그래서, 왜 매크로가 유용할까요?</p>
<ol>
<li>
<p>DRY(Don't repeat yourself) 원칙에 활용할 수 있습니다. 여러 타입에 대해 유사한 기능을 반복적으로 구현해야 하는 많은 경우가 발생합니다. 종종, 매크로를 작성하는 것은 반복 코드 작성을 피하는 유용한 방법입니다.</p>
</li>
<li>
<p>DSL(Domain-specific languages)를 활용할 수 있습니다.. 매크로는 특정 목적에 사용될 특별한 구문에 대해 정의할 수 있습니다.</p>
</li>
<li>
<p>가변인자 인터페이스(Variadic interfaces)를 사용할 수 있습니다. 어떤 경우, 수많은 인수를 갖는 인터페이스를 정의해야 할지도 모릅니다. 이를테면, <code>prinln!</code>은 포맷스트링에 따라 수많은 인수들을 가질 수 있습니다.</p>
</li>
</ol>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="syntax"><a class="header" href="#syntax">Syntax</a></h1>
<p>이후의 하위 섹션들에서는, Rust에서 매크로를 정의하는 방법에 대해 알아보겠습니다. 기본적으로 다음의 3가지 기본 원칙이 있습니다.</p>
<ul>
<li>패턴과 지정자(Patterns and Designators)</li>
<li>오버로딩(Overloading)</li>
<li>반복(Repetition)</li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="designators"><a class="header" href="#designators">Designators</a></h1>
<p>매크로의 인수는 <code>$</code>문자가 접두어로 붙습니다. 이후 *지정자(designator)*로 타입이 지정됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">macro_rules! create_function {
    // 아래 매크로는 `ident` 지정자의 인수를 받아
    // `$func_name`라는 이름의 함수를 생성합니다.
    // `ident` 지정자는 변수/함수명에 사용됩니다.
    ($func_name:ident) =&gt; {
        fn $func_name() {
            // `stringify!` 매크로는 `ident`를 String으로 변환합니다.
            println!(&quot;You called {:?}()&quot;,
                     stringify!($func_name));
        }
    };
}

// 위의 매크로로 `foo`와 `bar`라는 이름의 함수를 생성합니다.
create_function!(foo);
create_function!(bar);

macro_rules! print_result {
    // 아래 매크로는 `expr` 타입을 갖는 Expression을 받습니다.
    // 그리고 결과와 함께 이를 String으로 출력합니다.
    // `expr` 지정자는 Expression으로 사용됩니다.
    ($expression:expr) =&gt; {
        // `stringify!`는 Expression을 *그대로* string으로 변환합니다.
        println!(&quot;{:?} = {:?}&quot;,
                 stringify!($expression),
                 $expression);
    };
}

fn main() {
    foo();
    bar();

    print_result!(1u32 + 1);

    // 블럭도 Expression이라는 점을 기억하세요!
    print_result!({
        let x = 1u32;

        x * x + 2 * x - 1
    });
}
</code></pre></pre>
<p>아래는 가능한 지정자(designator)들의 일부입니다.</p>
<ul>
<li><code>block</code></li>
<li><code>expr</code>: Expression에 사용</li>
<li><code>ident</code> : 변수/함수명에 사용</li>
<li><code>item</code></li>
<li><code>literal</code> : 리터럴 상수에 사용</li>
<li><code>pat</code> : 패턴</li>
<li><code>path</code></li>
<li><code>stmt</code> : Statement</li>
<li><code>tt</code> : 토큰 트리(token tree)</li>
<li><code>ty</code> : 타입(type)</li>
<li><code>vis</code> : 가시성 한정자(visibility qualifier)</li>
</ul>
<p>완전한 리스트에 대해서는 <a href="https://doc.rust-lang.org/reference/macros-by-example.html">여기</a>를 참조하세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="overload"><a class="header" href="#overload">Overload</a></h1>
<p>매크로는 여러 조합의 인수들을 받기 위해 오버로딩될 수 있습니다. 이를 통해, <code>macro_rules!</code>는 <code>match</code> 블럭과 유사하게 동작할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `test!`는 어떻게 호출하느냐에 따라 다른 방식으로
// `$left`와 `$right`를 비교합니다.
macro_rules! test {
    // 인수는 `,`로 구분되지 않아도 됩니다.
    // 모든 형식을 사용할 수 있습니다!
    ($left:expr; and $right:expr) =&gt; {
        println!(&quot;{:?} and {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left &amp;&amp; $right)
    };
    // 각 분기는 `;`로 끝나야 합니다.
    ($left:expr; or $right:expr) =&gt; {
        println!(&quot;{:?} or {:?} is {:?}&quot;,
                 stringify!($left),
                 stringify!($right),
                 $left || $right)
    };
}

fn main() {
    test!(1i32 + 1 == 2i32; and 2i32 * 2 == 4i32);
    test!(true; or false);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="repeat"><a class="header" href="#repeat">Repeat</a></h1>
<p>매크로는 인수 리스트에서 <code>+</code>를 사용해 인수가 한번 이상 반복될 수 있음을 나타내거나, <code>*</code>을 사용하여 인수가 0번 이상 반복될 수 있음을 나타낼 수 있습니다.</p>
<p>아래 예시에서, <code>$(...),+</code>는 <code>,</code>로 구분된 하나 이상의 Expression과 매치될 것입니다. <code>;</code>의 사용은 마지막 케이스의 경우, 선택 사항임에 주의하세요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `find_min!`은 여러 인수들 중 최소값을 계산합니다.
macro_rules! find_min {
    // 기본 케이스
    ($x:expr) =&gt; ($x);
    // `$x`에는 적어도 하나의 `$y,`가 뒤따라옵니다.
    ($x:expr, $($y:expr),+) =&gt; (
        // 뒤의 `$y`에 `find_min!`을 호출합니다.
        std::cmp::min($x, find_min!($($y),+))
    )
}

fn main() {
    println!(&quot;{}&quot;, find_min!(1u32));
    println!(&quot;{}&quot;, find_min!(1u32 + 2, 2u32));
    println!(&quot;{}&quot;, find_min!(5u32, 2u32 * 3, 4u32));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dry-dont-repeat-yourself"><a class="header" href="#dry-dont-repeat-yourself">DRY (Don't Repeat Yourself)</a></h1>
<p>매크로는 함수의 공통된 부분을 일괄적으로 처리해내고, 덧붙여 테스트를 적용할 수도 있습니다. 아래는 <code>Vec&lt;T&gt;</code>에 <code>+=</code>, <code>*=</code> 그리고 <code>-=</code> 연산자에 대해 구현 및 테스트하는 예제입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::ops::{Add, Mul, Sub};

macro_rules! assert_equal_len {
    // `tt` (토큰 트리) 지정자는 
    // 연산자 및 토큰에 사용됩니다.
    ($a:expr, $b:expr, $func:ident, $op:tt) =&gt; {
        assert!($a.len() == $b.len(),
                &quot;{:?}: dimension mismatch: {:?} {:?} {:?}&quot;,
                stringify!($func),
                ($a.len(),),
                stringify!($op),
                ($b.len(),));
    };
}

macro_rules! op {
    ($func:ident, $bound:ident, $op:tt, $method:ident) =&gt; {
        fn $func&lt;T: $bound&lt;T, Output=T&gt; + Copy&gt;(xs: &amp;mut Vec&lt;T&gt;, ys: &amp;Vec&lt;T&gt;) {
            assert_equal_len!(xs, ys, $func, $op);

            for (x, y) in xs.iter_mut().zip(ys.iter()) {
                *x = $bound::$method(*x, *y);
                // *x = x.$method(*y);
            }
        }
    };
}

// `add_assign`, `mul_assign`, 그리고 `sub_assign` 함수를 구현합니다.
op!(add_assign, Add, +=, add);
op!(mul_assign, Mul, *=, mul);
op!(sub_assign, Sub, -=, sub);

mod test {
    use std::iter;
    macro_rules! test {
        ($func:ident, $x:expr, $y:expr, $z:expr) =&gt; {
            #[test]
            fn $func() {
                for size in 0usize..10 {
                    let mut x: Vec&lt;_&gt; = iter::repeat($x).take(size).collect();
                    let y: Vec&lt;_&gt; = iter::repeat($y).take(size).collect();
                    let z: Vec&lt;_&gt; = iter::repeat($z).take(size).collect();

                    super::$func(&amp;mut x, &amp;y);

                    assert_eq!(x, z);
                }
            }
        };
    }

    // `add_assign`, `mul_assign`, 그리고 `sub_assign`을 테스트합니다.
    test!(add_assign, 1u32, 2u32, 3u32);
    test!(mul_assign, 2u32, 3u32, 6u32);
    test!(sub_assign, 3u32, 2u32, 1u32);
}
</code></pre></pre>
<pre><code>$ rustc --test dry.rs &amp;&amp; ./dry
running 3 tests
test test::mul_assign ... ok
test test::add_assign ... ok
test test::sub_assign ... ok

test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="dsl-domain-specific-languages"><a class="header" href="#dsl-domain-specific-languages">DSL (Domain Specific Languages)</a></h1>
<p>DSL은 Rust 매크로에 포함된 작은 &quot;언어&quot;(language)입니다. 이는 작은 언어처럼 보이지만, 완전히 유효한 Rust 언어인데, 매크로 시스템이 일반적인 Rust 구조의 확장에 해당하기 때문입니다. DSL은 특별한 기능을 갖는 간결하거나 직관적인 구문을(Bound와 같이) 정의할 수 있도록 해줍니다.</p>
<p>간단한 계산기 API를 정의하려 한다고 가정해봅시다. 계산식을 전달하고 이에 대한 결과를 콘솔로 출력하려고 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">macro_rules! calculate {
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // 정수로 강제합니다.
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};
}

fn main() {
    calculate! {
        eval 1 + 2 // `eval`은 Rust의 키워드가 아니네요!
    }

    calculate! {
        eval (1 + 2) * (3 / 4)
    }
}
</code></pre></pre>
<p>출력은 다음과 같습니다.</p>
<pre><code>1 + 2 = 3
(1 + 2) * (3 / 4) = 0
</code></pre>
<p>이는 매우 간단한 예시이지만, 훨씬 더 복잡한 인터페이스도 구현할 수 있습니다. 이를테면 <a href="https://crates.io/crates/lazy_static"><code>lazy_static</code></a> 또는 <a href="https://crates.io/crates/clap"><code>clap</code></a> 같은 것들이 있습니다.</p>
<p>또, 매크로 내의 겹괄호(<code>{{ ... }}</code>)를 주의하세요. 바깥의 괄호가 <code>macro_rules!</code>문의 일부입니다. <code>()</code>와 <code>[]</code>를 포함해서요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variadic-interface"><a class="header" href="#variadic-interface">Variadic Interface</a></h1>
<p>가변 매크로(Variadic Interface)는 임의 개수의 인수들을 받습니다. 예를 들어, <code>println!</code>은 포맷스트링에 의해서 인수의 개수를 판단하는 Variadic Interface의 예시가 됩니다.</p>
<p>이전 섹션에서의 <code>calculate!</code> 매크로를 variadic하게 확장할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">macro_rules! calculate {
    // 단일 `eval` 패턴
    (eval $e:expr) =&gt; {{
        {
            let val: usize = $e; // Force types to be integers
            println!(&quot;{} = {}&quot;, stringify!{$e}, val);
        }
    }};

    // 여러 `eval`의 사용을 재귀적으로 분해합니다.
    (eval $e:expr, $(eval $es:expr),+) =&gt; {{
        calculate! { eval $e }
        calculate! { $(eval $es),+ }
    }};
}

fn main() {
    calculate! { 
      // 이제 임의적인 갯수의 인수들에 대해서도 처리할 수 있게 됐습니다!
        eval 1 + 2,
        eval 3 + 4,
        eval (2 * 3) + 1
    }
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="error-handling"><a class="header" href="#error-handling">Error handling</a></h1>
<p>에러 핸들링은 발생할 수 있는 문제에 대해 다루는 과정입니다. 예를 들어, 파일을 읽는데 실패한 상황에서, 잘못된 입력을 가지고 계속해서 진행하는 것은 분명히 문제가 될 것입니다. 이러한 에러들을 인식하고 명시적으로 관리하면 프로그램의 나머지 부분을 문제에서 벗어나게 해줄 수 있습니다.</p>
<p>Rust에서 에러는 다양한 방식으로 다루어질 수 있습니다. 이 &quot;다양한 방식&quot;에 대해서는 하위 챕터들을 통해 다루겠습니다. 이들은 모두 미묘한 차이와 다른 이용 사례들을 갖고 있으며, 원칙적으로는 다음과 같습니다.</p>
<p>명시적인 <code>panic</code>은 주로 테스트나, 복구할 수 없는 에러를 다룰 때 유용합니다. 이는 프로토타이핑 단계에서 유용할 수 있는데, 아직 완전히 구현되지 않은 함수들을 디버깅하는 경우에 사용할 수 있습니다. 그러나, 이런 경우에는 좀 더 서술적인 <code>unimplemented</code>가 유용합니다. 테스트 단계에서, <code>panic</code>은 명시적으로 실패(fail)할 수 있는 합리적인 방법입니다.</p>
<p><code>Option</code> 타입은 값이 선택적(optional)이거나, 값이 존재하지 않는 것이 오류 조건이 아닌 경우에 사용됩니다. 예를 들어, 디렉토리의 부모는 존재하지 않을 수 있습니다.(ex. <code>/</code> 또는 <code>C:</code>) <code>Option</code>을 다룰 때, <code>unwrap</code>은 프로토타이핑이나, 값이 분명히 존재함을 보장하는 경우에 유용합니다. 그러나, <code>expect</code>는 문제가 발생할 경우의 에러 메시지를 지정해줄 수 있기 때문에 더 유용합니다.</p>
<p>문제가 발생할 가능성이 있고, 호출자(caller)가 문제를 해결해야 하는 상황에서는 <code>Result</code>를 사용하세요. 이는 마찬가지로 <code>unwrap</code> 또는 <code>expect</code>을 적용할 수 있습니다. (테스트나 빠른 프로토타이핑을 하는 중이 아니라면 그러지 마세요.)</p>
<p>에러 핸들리에 대한 보다 엄격한 설명은 <a href="https://doc.rust-lang.org/book/ch09-00-error-handling.html">여기</a>를 참조하세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic</a></h1>
<p>가장 간단하게 에러 핸들링을 다루는 방법은 <code>panic</code>입니다. 이는 에러 메시지를 출력하고, 스택을 다시 되감기 시작하며(stack unwinding), 일반적으로는 프로그램을 종료합니다. 자, 아래 에러 조건에서 <code>panic</code>을 호출해봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn drink(beverage: &amp;str) {
    if beverage == &quot;lemonade&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;Some refreshing {} is all I need.&quot;, beverage);
}

fn main() {
    drink(&quot;water&quot;);
    drink(&quot;lemonade&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="option--unwrap"><a class="header" href="#option--unwrap">Option &amp; unwrap</a></h1>
<p>지난 예시에서, 프로그램의 실패를 일부러 유도할 수 있음을 살펴봤습니다. 특정 결과를 받았는데, 원하는 결과가 아닌 경우에는 <code>panic</code>을 통해 에러 핸들링을 할 수 있었습니다. 그렇다면, 애초에 결과 자체를 받지 못했다면 어떻게 처리해야 할까요? </p>
<p><code>std</code> 라이브러리의 <code>Option&lt;T&gt;</code>라고 불리는 <code>enum</code>은 값이 &quot;없을 수도 있는&quot; 경우에 사용됩니다. 이는 두 가지 옵션 중 하나로 나타납니다.</p>
<ul>
<li><code>Some(T)</code> : <code>T</code> 타입의 요소가 발견됨</li>
<li><code>None</code> : 아무 요소도 발견되지 않음</li>
</ul>
<p>이러한 케이스들은 <code>match</code>를 통해 명시적으로 핸들링되거나, <code>unwrap</code>을 통해 암시적으로 다루어질 수 있습니다. 암시적(implicit) 핸들링은 내부 요소 또는 <code>panic</code>을 반환하게 됩니다.</p>
<p><code>expect</code>를 통해 수동으로 <code>panic</code>을 커스터마이징할 수도 있지만, <code>unwrap</code>은 명시적인 핸들링보다 덜 의미있는 결과를 얻을 수도 있다는 점을 주의하세요. 아래 예시에서, 명시적인 핸들링을 통해 보다 정제된 결과를 얻을 수 있으며, 원하는 경우 <code>panic</code> 옵션을 유지할 수도 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 모든 `gift`들은 `match`를 통해 명시적으로 처리됩니다.
fn give_commoner(gift: Option&lt;&amp;str&gt;) {
    // 각각의 경우에 대한 처리를 명시합니다.
    match gift {
        Some(&quot;snake&quot;) =&gt; println!(&quot;Yuck! I'm putting this snake back in the forest.&quot;),
        Some(inner)   =&gt; println!(&quot;{}? How nice.&quot;, inner),
        None          =&gt; println!(&quot;No gift? Oh well.&quot;),
    }
}

// 모든 `gift`들은 `unwrap`을 통해 암시적으로 다루어집니다.
fn give_royal(gift: Option&lt;&amp;str&gt;) {
    // `unwrap`은 `None`값을 받게 되면 `panic`을 반환합니다.
    let inside = gift.unwrap();
    if inside == &quot;snake&quot; { panic!(&quot;AAAaaaaa!!!!&quot;); }

    println!(&quot;I love {}s!!!!!&quot;, inside);
}

fn main() {
    let food  = Some(&quot;cabbage&quot;);
    let snake = Some(&quot;snake&quot;);
    let void  = None;

    give_commoner(food);
    give_commoner(snake);
    give_commoner(void);

    let bird = Some(&quot;robin&quot;);
    let nothing = None;

    give_royal(bird);
    give_royal(nothing);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="unpacking-options-with-"><a class="header" href="#unpacking-options-with-">Unpacking options with ?</a></h1>
<p><code>Option</code>들은 <code>match</code>문을 통해 개봉(unpack)될 수 있습니다. 그러나 이는 <code>?</code> 연산자를 사용하면 훨씬 더 쉬워집니다. 만약 <code>x</code>이 <code>Option</code>이라면, <code>x?</code>는 <code>x</code>가 <code>Some</code>이라면 내부의 값을 반환할 것이고, 그렇지 않다면 실행 중이던 모든 함수가 종료되고 <code>None</code>이 반환됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn next_birthday(current_age: Option&lt;u8&gt;) -&gt; Option&lt;String&gt; {
  // `current_age`가 `None`이라면 `None`을 반환합니다.
  // `current_age`가 `Some`이라면, 내부의 `u8`이 `next_age`에 할당됩니다.
    let next_age: u8 = current_age?;
    Some(format!(&quot;Next year I will be {}&quot;, next_age))
}
</code></pre></pre>
<p>코드의 가독성을 향상시키기 위해 <code>?</code>을 여러번 체이닝할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">struct Person {
    job: Option&lt;Job&gt;,
}

#[derive(Clone, Copy)]
struct Job {
    phone_number: Option&lt;PhoneNumber&gt;,
}

#[derive(Clone, Copy)]
struct PhoneNumber {
    area_code: Option&lt;u8&gt;,
    number: u32,
}

impl Person {
    fn work_phone_area_code(&amp;self) -&gt; Option&lt;u8&gt; {
        // 만약, `?` 연산자가 없다면, 이는 중첩 `match`문을 써야합니다.
        // 그런 경우, 코드가 너무 많이 소모될겁니다.
        self.job?.phone_number?.area_code
    }
}

fn main() {
    let p = Person {
        job: Some(Job {
            phone_number: Some(PhoneNumber {
                area_code: Some(61),
                number: 439222222,
            }),
        }),
    };

    assert_eq!(p.work_phone_area_code(), Some(61));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="combinators-map"><a class="header" href="#combinators-map">Combinators: map</a></h1>
<p><code>match</code>는 <code>Option</code>들을 핸들링 하는데 유효한 메서드입니다. 그러나, 이는 오직 입력만으로 충분한 작업에서는 과한 작업으로 느껴질 수 있습니다. 이러한 경우에, <em>combinator</em>를 사용하여 제어 흐름을 모듈 방식으로 관리할 수 있습니다.</p>
<p><code>Option</code>은 <code>map()</code>이라고 하는 내장 메서드를 갖고 있습니다. 이는 <code>Some -&gt; Some</code>, 그리고 <code>None -&gt; None</code>의 간단한 매핑을 해주는 컴비네이터(combinator)입니다. 여러번의 <code>map()</code>은 유연함을 위해 서로 체이닝 될 수 있습니다.</p>
<p>다음 예시에서, <code>process()</code>는 간단한 형태를 유지한 채로 이전의 모든 함수들을 대신하고 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(dead_code)]

#[derive(Debug)] enum Food { Apple, Carrot, Potato }

#[derive(Debug)] struct Peeled(Food);
#[derive(Debug)] struct Chopped(Food);
#[derive(Debug)] struct Cooked(Food);

// 아무 값도 없다면, `None`을 반환하고,
// 그렇지 않다면, `Peeled(food)`를 반환합니다.
fn peel(food: Option&lt;Food&gt;) -&gt; Option&lt;Peeled&gt; {
    match food {
        Some(food) =&gt; Some(Peeled(food)),
        None       =&gt; None,
    }
}

// 아무 값도 없다면, `None`을 반환하고,
// 그렇지 않다면, `Chopped(food)`를 반환합니다.
fn chop(peeled: Option&lt;Peeled&gt;) -&gt; Option&lt;Chopped&gt; {
    match peeled {
        Some(Peeled(food)) =&gt; Some(Chopped(food)),
        None               =&gt; None,
    }
}

// 여기서, 우리는 `match` 대신에 `map()`을 사용할 것입니다.
fn cook(chopped: Option&lt;Chopped&gt;) -&gt; Option&lt;Cooked&gt; {
    chopped.map(|Chopped(food)| Cooked(food))
}

// `peel`, `chop`, `cook` 함수를 일련적으로 호출합니다.
// `map()`을 체이닝을 통해 여러번 호출함으로써 코드를 간략화했습니다.
fn process(food: Option&lt;Food&gt;) -&gt; Option&lt;Cooked&gt; {
    food.map(|f| Peeled(f))
        .map(|Peeled(f)| Chopped(f))
        .map(|Chopped(f)| Cooked(f))
}

fn eat(food: Option&lt;Cooked&gt;) {
    match food {
        Some(food) =&gt; println!(&quot;Mmm. I love {:?}&quot;, food),
        None       =&gt; println!(&quot;Oh no! It wasn't edible.&quot;),
    }
}

fn main() {
    let apple = Some(Food::Apple);
    let carrot = Some(Food::Carrot);
    let potato = None;

    let cooked_apple = cook(chop(peel(apple)));
    let cooked_carrot = cook(chop(peel(carrot)));

    // `process`는 위의 `cook(chop(peel(...)))`을 완전히 대체합니다.
    // 너무 간결하네요! :)
    let cooked_potato = process(potato);

    eat(cooked_apple);
    eat(cooked_carrot);
    eat(cooked_potato);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="combinators-and_then"><a class="header" href="#combinators-and_then">Combinators: and_then</a></h1>
<p><code>map()</code>는 <code>match</code>문을 간결하게 하기 위해 체이닝을 활용할 수 있었습니다. 그러나 <code>Option&lt;T&gt;</code>를 반환하는 함수에 <code>map()</code>을 사용하면 이는 중첩된 <code>Option&lt;Option&lt;T&gt;&gt;</code>를 갖게됩니다. 여러번의 체이닝 호출은 혼란스러울 수 있습니다. 이런 경우에 또 다른 컴비네이터(<code>combinator</code>)인 <code>and_then()</code>를 사용할 수 있습니다. 이는 다른 언어에서는 <em>flatmap</em>이라고 불리기도 합니다.</p>
<p><code>and_then()</code>은 함수 입력을 래핑된 값으로 호출하고 결과를 반환합니다. 만약 <code>Option</code>이 <code>None</code>이라면, 대신에 <code>None</code>을 반환합니다.</p>
<p>아래 예시에서, <code>cookable_v2()</code>는 <code>Option&lt;Food&gt;</code>를 반환합니다. <code>and_then()</code> 대신에 <code>map()</code>를 사용하게 되면, 반환값이 <code>Option&lt;Option&lt;Food&gt;&gt;</code>가 될 것이며, 이 경우 <code>eat()</code>에 부적합한 타입이 됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">#![allow(dead_code)]

#[derive(Debug)] enum Food { CordonBleu, Steak, Sushi }
#[derive(Debug)] enum Day { Monday, Tuesday, Wednesday }

// Sushi를 만들기위한 재료는 없습니다.
fn have_ingredients(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::Sushi =&gt; None,
        _           =&gt; Some(food),
    }
}

// Cordon Bleu를 제외한 모든 레시피가 있습니다.
fn have_recipe(food: Food) -&gt; Option&lt;Food&gt; {
    match food {
        Food::CordonBleu =&gt; None,
        _                =&gt; Some(food),
    }
}

// 요리를 만드려면, 레시피와 재료가 모두 필요합니다.
// 해당 로직을 `match` 체인으로 나타낼 수 있습니다.
fn cookable_v1(food: Food) -&gt; Option&lt;Food&gt; {
    match have_recipe(food) {
        None       =&gt; None,
        Some(food) =&gt; match have_ingredients(food) {
            None       =&gt; None,
            Some(food) =&gt; Some(food),
        },
    }
}

// 이는 `and_then()`을 통해서 더 간결하게 작성될 수 있습니다.
fn cookable_v2(food: Food) -&gt; Option&lt;Food&gt; {
    have_recipe(food).and_then(have_ingredients)
}

fn eat(food: Food, day: Day) {
    match cookable_v2(food) {
        Some(food) =&gt; println!(&quot;Yay! On {:?} we get to eat {:?}.&quot;, day, food),
        None       =&gt; println!(&quot;Oh no. We don't get to eat on {:?}?&quot;, day),
    }
}

fn main() {
    let (cordon_bleu, steak, sushi) = (Food::CordonBleu, Food::Steak, Food::Sushi);

    eat(cordon_bleu, Day::Monday);
    eat(steak, Day::Tuesday);
    eat(sushi, Day::Wednesday);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="result"><a class="header" href="#result">Result</a></h1>
<p><code>Result</code>는 있을 수 있는 값의 부재(absence) 대신에 있을 수 있는 에러(error)에 대해 설명하는, <code>Option</code>보다 더 풍부한 버전의 타입입니다.</p>
<p>다시 말해, <code>Result&lt;T, E&gt;</code>는 두 결과 중 하나를 가질 수 있습니다.</p>
<ul>
<li><code>Ok(T)</code> : <code>T</code> 요소가 발견됨</li>
<li><code>Err(E)</code> : <code>E</code> 요소에서 발견된 에러</li>
</ul>
<p>관례 상, 예측된 결과는 <code>Ok</code>이며, 예상치 못한 결과는 <code>Err</code>이 됩니다.</p>
<p><code>Option</code>과 유사하게, <code>Result</code>는 이와 관련된 여러 메서드들을 갖고 있습니다. 예를 들어, <code>unwrap()</code>은 요소 <code>T</code>나 <code>panic</code>을 반환합니다. 이를 다루기 위해, <code>Result</code>와 <code>Option</code> 사이에는 서로 겹치는 많은 컴비네이터(combinator)가 존재합니다.</p>
<p>Rust로 작업을 할 때, <code>parse()</code> 와 같이, 종종 <code>Result</code> 타입을 반환하는 메서드를 마주칠 수 있습니다. String을 다른 타입으로 파싱하는 것은 항상 가능한 일이 아니기 때문에, 이에 발생할지도 모르는 에러를 대비하기 위해 <code>parse()</code> 역시 <code>Result</code>를 반환합니다.</p>
<p><code>parse()</code>가 성공했을 때와, 그렇지 않았을 때의 상황을 각각 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; i32 {
    let first_number = first_number_str.parse::&lt;i32&gt;().unwrap();
    let second_number = second_number_str.parse::&lt;i32&gt;().unwrap();
    first_number * second_number
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    println!(&quot;double is {}&quot;, tt);
}
</code></pre></pre>
<p>성공하지 못한 경우에, <code>parse()</code>는 <code>unwrap()</code>에 대해 에러를 남기고 <code>panic</code>으로 넘어갑니다. 여기에 더해, <code>panic</code>은 프로그램을 종료하고 에러 메시지를 출력합니다.</p>
<p>에러 메시지의 퀄리티를 높이기 위해서는, 반환 타입에 대해 더 구체적으로 작성하고, 명시적으로 에러를 다루도록 고려해야 합니다.</p>
<h2 id="using-result-in-main"><a class="header" href="#using-result-in-main">Using <code>Result</code> in <code>main</code></a></h2>
<p>명시적으로 지정된 경우, <code>Result</code> 타입은 마찬가지로 <code>main</code> 함수의 반환 타입이 될 수 있습니다. 지금껏 봐왔던 <code>main</code>는 이런 형태일 겁니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
    println!(&quot;Hello World!&quot;);
}
</code></pre></pre>
<p>그런데 <code>main</code>도 <code>Result</code> 타입의 반환을 가질 수 있습니다. 만약 <code>main</code> 함수 내에서 에러가 발생한다면, 이는 에러 코드를 반환하고 에러를 나타내는 디버깅 메시지를 출력할 것입니다(<code>Debug</code> 트레이트를 이용해서).</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

fn main() -&gt; Result&lt;(), ParseIntError&gt; {
    let number_str = &quot;10&quot;;
    let number = match number_str.parse::&lt;i32&gt;() {
        Ok(number)  =&gt; number,
        Err(e) =&gt; return Err(e),
    };
    println!(&quot;{}&quot;, number);
    Ok(())
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="map-for-result"><a class="header" href="#map-for-result">map for Result</a></h1>
<p>이전 예제의 <code>multiply</code>에서 <code>panic</code>이 발생한다고 해서 더 튼튼한 코드가 작성되지는 않습니다. 일반적으로, 우리는 에러에 대한 올바른 대처를 결정하기 위해 호출자에게 에러를 반환하고자 합니다.</p>
<p>먼저 알아야 할 것은 다루어야 하는 에러 타입이 어떤 종류인지에 대해서입니다. <code>Err</code>타입을 결정하기 위해선 <code>parse()</code>를 살펴봐야 하는데, 이는 <code>i32</code>에 대한 <code>FromStr</code> 트레이트로 구현되어 있습니다. 따라서, <code>Err</code> 타입은 <code>ParseIntError</code>로 지정됩니다.</p>
<p>아래 예시에서, 간단한 <code>match</code>문은 전반적으로 더 번거로운 코드로 이어지게 됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

// 재작성된 반환타입을 통해, 우리는 `unwrap()`없이 패턴 매칭을 합니다.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; {
            match second_number_str.parse::&lt;i32&gt;() {
                Ok(second_number)  =&gt; {
                    Ok(first_number * second_number)
                },
                Err(e) =&gt; Err(e),
            }
        },
        Err(e) =&gt; Err(e),
    }
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    // 이는 유효한 답입니다.
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    // 아래는 좀 더 도움이 되는 에러 메시지를 제공합니다.
    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<p>다행히도, <code>Option</code>의 <code>map</code>, <code>and_then</code>, 그리고 그 외의 다른 컴비네이터(combinator)들은 <code>Result</code>에 대해서도 구현될 수 있습니다. <a href="https://doc.rust-lang.org/std/result/enum.Result.html">여기</a>에서 완전한 목록을 확인할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

// `Option`과 마찬가지로, `map()`과 같은 컴비네이터를 사용할 수 있습니다.
// 아래 함수는 위의 기능과 동일합니다.
// 만약 값이 유효하다면 `n`을 수정하고,
// 그렇지 않다면 에러를 전달합니다.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let twenty = multiply(&quot;10&quot;, &quot;2&quot;);
    print(twenty);

    let tt = multiply(&quot;t&quot;, &quot;2&quot;);
    print(tt);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="aliases-for-result"><a class="header" href="#aliases-for-result">aliases for Result</a></h1>
<p>구체적인 <code>Result</code> 타입을 여러번 재사용하고 싶다면 어떻게 해야할까요? Rust가 우리에게 <strong>Alias</strong> 기능을 제공했던 것을 기억해보세요! 편리하게도, 우리는 문제의 특정 결과에 대한 Alias를 정의할 수 있습니다.</p>
<p>모듈 수준에서 Alias를 만드는 것이 특히 유용할 겁니다. 구체적인 모듈 내에서 발견된 에러들은 대체로 동일한 <code>Err</code> 타입을 가지며, 따라서 하나의 별칭으로 관련된 모든 <code>Result</code>를 간결하게 정의할 수 있습니다. 이는 <code>std</code> 라이브러리가 별도로 <code>io::Result</code>를 제공할 정도로 유용합니다! :)</p>
<p>아래에서 간단한 예시를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

// `ParseIntError`로 `Result`에 대한 제네릭 별칭을 정의합니다.
type AliasedResult&lt;T&gt; = Result&lt;T, ParseIntError&gt;;

// 위의 별칭을 사용해 구체적인 `Result` 타입을 참조합니다.
fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; AliasedResult&lt;i32&gt; {
    first_number_str.parse::&lt;i32&gt;().and_then(|first_number| {
        second_number_str.parse::&lt;i32&gt;().map(|second_number| first_number * second_number)
    })
}

// 별칭 덕분에 코드를 간결하게 작성할 수 있습니다.
fn print(result: AliasedResult&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="early-returns"><a class="header" href="#early-returns">Early returns</a></h1>
<p>이전 예시에서, 우리는 컴비네이터(combinator)를 사용해 에러를 명시적으로 핸들링했습니다. 이를 다루는 또다른 방법은 <code>match</code>문과 *조기 반환(early returns)*의 조합을 사용하는 것입니다.</p>
<p>즉, 우리는 단순히 함수의 실행을 멈추고 발생한 에러를 바로 반환할 수 있습니다. 어떤 사람들에게는, 이런 형태의 코드가 더 읽고 쓰기에 쉽게 느껴질 수 있습니다. 이전 예시들을 &quot;조기 반환&quot;을 통해 다시 작성해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = match first_number_str.parse::&lt;i32&gt;() {
        Ok(first_number)  =&gt; first_number,
        Err(e) =&gt; return Err(e),
    };

    let second_number = match second_number_str.parse::&lt;i32&gt;() {
        Ok(second_number)  =&gt; second_number,
        Err(e) =&gt; return Err(e),
    };

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<p>이 시점에서, 우리는 컴비네이터와 조기 반환을 사용해 오류를 명시적으로 처리하는 방법을 배웠습니다. 다만, 이런 식으로 모든 에러를 명시적으로 핸들링 하는 것은 제법 번거로운 일입니다.</p>
<p>다음 섹션에서, <code>panic</code>을 사용하지 않고 단순히 <code>unwrap</code>을 통해 해결할 수 있는 <code>?</code>에 대해 소개하겠습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="introducing-"><a class="header" href="#introducing-">Introducing ?</a></h1>
<p>때때로 우리는 <code>panic</code>의 가능성 없이 간단히 <code>unwrap</code>을 사용하길 원합니다. 지금까지, <code>unwrap</code>은 지금껏 우리가 원하는 값을 얻기 위해서는 계속해서 <code>{}</code> 괄호와 함께 더 깊은 코드를 작성해야 했습니다. 이는 정확히 <code>?</code>을 사용하는 목적입니다.</p>
<p><code>Err</code>을 발견하면, 취할 수 있는 두가지 유효한 행동이 있습니다.</p>
<ol>
<li><code>panic!</code>은 가능하다면 미리 피하려는 결정입니다.</li>
<li><code>return</code>은 통제될 수 없는 에러를 반환하는 것입니다.</li>
</ol>
<p><code>?</code>는 <code>Err</code>에 <code>panic</code>을 유발하지 않고, <code>return</code>값들을 <code>unwrap</code>하는 것과 거의 정확히 동일합니다. 이전에 컴비네이터를 통해 해결했던 예시를 어떻게 단순화할 수 있는지 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = first_number_str.parse::&lt;i32&gt;()?;
    let second_number = second_number_str.parse::&lt;i32&gt;()?;

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<h2 id="try-매크로"><a class="header" href="#try-매크로"><code>try!</code> 매크로</a></h2>
<p><code>?</code> 이전에, <code>try!</code> 매크로를 통해서도 똑같은 기능을 수행할 수 있습니다. <code>?</code>가 현 시점에서 더 추천되기는 하지만, 여전히 오래된 코드에서는 <code>try!</code>를 볼 수 있을 겁니다. 위와 동일한 예시를 <code>try!</code>로 처리해보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 아래 예시를 에러 없이 컴파일하고 실행하기 위해서는,
// Rust의 `edition`을 `2015`로 수정해주어야 합니다!

use std::num::ParseIntError;

fn multiply(first_number_str: &amp;str, second_number_str: &amp;str) -&gt; Result&lt;i32, ParseIntError&gt; {
    let first_number = try!(first_number_str.parse::&lt;i32&gt;());
    let second_number = try!(second_number_str.parse::&lt;i32&gt;());

    Ok(first_number * second_number)
}

fn print(result: Result&lt;i32, ParseIntError&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;n is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    print(multiply(&quot;10&quot;, &quot;2&quot;));
    print(multiply(&quot;t&quot;, &quot;2&quot;));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="multiple-error-types"><a class="header" href="#multiple-error-types">Multiple error types</a></h1>
<p>이전 예시들은 매번 편리해질 수 있었습니다. <code>Result</code>들은 다른 <code>Result</code>들과 상호작용하고, <code>Option</code>들은 다른 <code>Option</code>들과 상호작용했습니다.</p>
<p>때때로 <code>Option</code>은 <code>Result</code>와 상호작용해야 합니다. 또는, <code>Result&lt;T, Error1&gt;</code>이 <code>Result&lt;T, Error2&gt;</code>와 상호작용할지도 모릅니다. 이러한 경우, 우리는 서로 다른 오류 유형을 더 복합적이고 쉽게 상호작용할 수 있는 형태로 관리하고자 합니다.</p>
<p>아래 코드에서, <code>unwrap</code>의 두 예시들은 다른 에러 타입들을 만들어냅니다. <code>Vec::first</code>는 <code>Option</code>을 반환하는 반면, <code>parse::&lt;i32&gt;</code>는 <code>Result&lt;i32, ParseIntError&gt;</code>를 반환합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; i32 {
    let first = vec.first().unwrap(); // Error 1 생성
    2 * first.parse::&lt;i32&gt;().unwrap() // Error 2 생성
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {}&quot;, double_first(empty));
    // Error 1 : 입력 벡터가 비어있습니다.

    println!(&quot;The first doubled is {}&quot;, double_first(strings));
    // Error 2: 수로 파싱할 수 없는 String이 포함되어 있습니다.
}
</code></pre></pre>
<p>이후의 섹션들을 통해, 이러한 종류의 문제를 다루기 위한 몇가지 전략에 대해 살펴보겠습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="pulling-results-out-of-options"><a class="header" href="#pulling-results-out-of-options">Pulling Results out of Options</a></h1>
<p>복합적인 에러 타입들을 다루기 위한 가장 기본적인 방법은 그들 서로를 끼워넣는 것입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Option&lt;Result&lt;i32, ParseIntError&gt;&gt; {
    vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    })
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));

    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    // Error 1: 입력 벡터가 비어있습니다.

    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
    // Error 2: 수로 파싱할 수 없는 String이 포함되어 있습니다.
}
</code></pre></pre>
<p><code>Option</code>이 <code>None</code>일 때, 에러 처리를 중지하고(<code>?</code> 이용과 같이), 계속해서 진행해야 하는 경우가 있습니다. 일부 컴비네이터는 <code>Result</code>와 <code>Option</code>을 서로 교환하는 데에 유용합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::num::ParseIntError;

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;Option&lt;i32&gt;, ParseIntError&gt; {
    let opt = vec.first().map(|first| {
        first.parse::&lt;i32&gt;().map(|n| 2 * n)
    });

    opt.map_or(Ok(None), |r| r.map(Some))
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    println!(&quot;The first doubled is {:?}&quot;, double_first(numbers));
    println!(&quot;The first doubled is {:?}&quot;, double_first(empty));
    println!(&quot;The first doubled is {:?}&quot;, double_first(strings));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="defining-an-error-type"><a class="header" href="#defining-an-error-type">Defining an error type</a></h1>
<p>때로는 코드를 단순화하여, 하나의 에러 타입으로 여러 종류의 에러들을 모두 처리하는 경우도 있습니다. 이는 커스텀 에러 타입을 통해 이루어집니다.</p>
<p>Rust는 임의의 에러 타입을 정의할 수 있게 해줍니다. 일반적으로, <em>좋은</em> 에러 타입은 다음 특징을 갖습니다.</p>
<ul>
<li>동일한 타입으로 다른 에러를 처리할 수 있습니다.</li>
<li>이용자들에게 좋은 에러 메시지를 제공합니다.</li>
<li>다른 타입과 비교하기에 용이합니다.
<ul>
<li>Good : <code>Err(EmptyVec)</code></li>
<li>Bad : <code>Err(&quot;Please use a vector with at least one element&quot;.to_owned())</code></li>
</ul>
</li>
<li>에러에 대한 정보를 담을 수 있습니다.
<ul>
<li>Good : <code>Err(BadChar(c, position))</code></li>
<li>Bad : <code>Err(&quot;+ cannot be used here&quot;.to_owned())</code></li>
</ul>
</li>
<li>다른 에러들과 잘 합성(compose)될 수 있습니다.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

// 임의의 에러타입을 정의합니다.
// 이는 우리의 에러 핸들링 사례에 따라 커스터마이징될 수 있습니다.
#[derive(Debug, Clone)]
struct DoubleError;

// 에러의 생성은 그것이 어떻게 출력되느냐와는 완전히 별개의 문제입니다.
// 출력 시에 복잡한 논리에 대해 걱정할 필요는 없습니다.
// 에러에 대한 어떤 추가적인 정보도 저장하지 않음을 명심하세요.
// 즉, 타입을 수정하지 않고서는 정보 전달을 위해 에러의 구체적인 사항을 보관할 수 없습니다. 
impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        // 새로운 에러 타입으로 에러를 변경합니다.
        .ok_or(DoubleError)
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                // 여기에서도 새로운 에러 타입으로 변경합니다.
                .map_err(|_| DoubleError)
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="boxing-errors"><a class="header" href="#boxing-errors">Boxing errors</a></h1>
<p>기존 에러를 보존하면서도 간단한 코드를 작성하는 방법은 이들을 <code>Box</code>하는 것입니다. 이 경우의 단점은 기존 에러 타입이 런타임에서만 발견되며, 정적으로 결정될 수 없다는 것입니다.</p>
<p><code>std</code> 라이브러리는 <code>Error</code> 트레이트를 구현하는 어떤 타입이든 <code>From</code>을 통해 <code>Box&lt;Error&gt;</code> 트레이트 객체로 변환하도록 구현된 <code>Box</code> 트레이트를 갖고 있어, 에러들을 포장(box)하는 것을 도와줍니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::error;
use std::fmt;

// 별칭을 `Box&lt;error::Error&gt;`로 변경합니다.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug, Clone)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    vec.first()
        .ok_or_else(|| EmptyVec.into()) // Box로 변환
        .and_then(|s| {
            s.parse::&lt;i32&gt;()
                .map_err(|e| e.into()) // Box로 변환
                .map(|i| 2 * i)
        })
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n) =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="other-uses-of-"><a class="header" href="#other-uses-of-">Other uses of ?</a></h1>
<p>이전 챕터에서는 <code>parse</code> 호출에 대한 즉각적인 반응으로 라이브러리 에러를 Box 처리된 에러로 <code>map</code>하였습니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.and_then(|s| s.parse::&lt;i32&gt;()
    .map_err(|e| e.into())
<span class="boring">}
</span></code></pre></pre>
<p>이는 간단하고 일반적인 작업이기 때문에, 생략될 수 있다면 더 편해질 것 같습니다. 아뿔싸, <code>and_then</code>은 그렇게까지 유연하지 않기 때문에, 그럴 수 없겠네요. 하지만, <code>?</code>를 사용한다면 어떨까요?</p>
<p><code>?</code>는 이전에 <code>unwrap</code> 또는 <code>return Err(err)</code>를 처리해준다고 설명했습니다. 이는 거의 맞는 말이지만, 사실 이는 <code>unwrap</code> 또는 <code>return Err(From::from(err))</code>를 의미합니다. <code>From::from</code>은 다른 타입들 간의 변환 유틸리티이므로, 이는 만약 <code>?</code>를 반환 타입으로 변환될 수 있는 에러에 사용한다면, 자동으로 변환된다는 것을 의미힙니다.</p>
<p>자, 이전 예시를 <code>?</code>를 통해 다시 작성해봅시다. <code>From::from</code>이 우리의 커스텀 에러 타입에 대해 구현된다면 <code>map_err</code>는 필요가 없어집니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::error;
use std::fmt;

// `Box&lt;dyn error::Error&gt;`로 별칭을 변경합니다.
type Result&lt;T&gt; = std::result::Result&lt;T, Box&lt;dyn error::Error&gt;&gt;;

#[derive(Debug)]
struct EmptyVec;

impl fmt::Display for EmptyVec {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;invalid first item to double&quot;)
    }
}

impl error::Error for EmptyVec {}

// 이전과 동일한 구조이지만, `Results`와 `Options`에 따른 체이닝 대신에
// `?`를 사용해 내부 값을 즉각적으로 얻어옵니다.
fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(EmptyVec)?;
    let parsed = first.parse::&lt;i32&gt;()?;
    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; println!(&quot;Error: {}&quot;, e),
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>이제 상당히 깔끔해졌습니다. 기존의 <code>panic</code>과 비교했을 때, <code>?</code>로 <code>unwrap</code> 호출을 대체한 것과 유사하지만, 반환 타입이 <code>Result</code>라는 점에 차이가 있습니다. 따라서, 이는 상위 레벨에서 다시 분해(destructure)되어야 합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="wrapping-errors"><a class="header" href="#wrapping-errors">Wrapping errors</a></h1>
<p>에러를 Box 처리하는 대신에 이를 커스텀 에러 타입으로 감쌀 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::error;
use std::error::Error as _;
use std::num::ParseIntError;
use std::fmt;

type Result&lt;T&gt; = std::result::Result&lt;T, DoubleError&gt;;

#[derive(Debug)]
enum DoubleError {
    EmptyVec,
    // 파싱 에러에 대해서는 파싱 에러에 대한 구현으로 넘기겠습니다.
    // 추가 정보를 제공하려면 타입에 더 많은 데이터를 추가해야 합니다.
    Parse(ParseIntError),
}

impl fmt::Display for DoubleError {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        match *self {
            DoubleError::EmptyVec =&gt;
                write!(f, &quot;please use a vector with at least one element&quot;),
            // 포장된 에러에는 추가적인 정보가 포함되어 있으며,
            // `source()` 메서드를 통해 사용할 수 있습니다.
            DoubleError::Parse(..) =&gt;
                write!(f, &quot;the provided string could not be parsed as int&quot;),
        }
    }
}

impl error::Error for DoubleError {
    fn source(&amp;self) -&gt; Option&lt;&amp;(dyn error::Error + 'static)&gt; {
        match *self {
            DoubleError::EmptyVec =&gt; None,
            // 원인은 기본적인 구현 에러 타입입니다.
            // 특성 객체 `&amp;error:Error`에 암시적으로 캐스팅됩니다.
            // 이는 기본 유형이 이미 `Error` 트레이트를 구현하기 때문입니다.
            DoubleError::Parse(ref e) =&gt; Some(e),
        }
    }
}

// `ParseIntError`에서 `DoubleError`로의 변환을 구현합니다.
// `ParseIntError`가 `DoubleError`로 변환되어야 할 경우에
// 이는 `?`를 통해 자동으로 호출됩니다. 
impl From&lt;ParseIntError&gt; for DoubleError {
    fn from(err: ParseIntError) -&gt; DoubleError {
        DoubleError::Parse(err)
    }
}

fn double_first(vec: Vec&lt;&amp;str&gt;) -&gt; Result&lt;i32&gt; {
    let first = vec.first().ok_or(DoubleError::EmptyVec)?;
    // 여기서는 `DoubleError`를 생성하기 위해서
    // `From`의 `ParseIntError` 구현(위에서 정의)을 암시적으로 사용합니다.
    let parsed = first.parse::&lt;i32&gt;()?;

    Ok(2 * parsed)
}

fn print(result: Result&lt;i32&gt;) {
    match result {
        Ok(n)  =&gt; println!(&quot;The first doubled is {}&quot;, n),
        Err(e) =&gt; {
            println!(&quot;Error: {}&quot;, e);
            if let Some(source) = e.source() {
                println!(&quot;  Caused by: {}&quot;, source);
            }
        },
    }
}

fn main() {
    let numbers = vec![&quot;42&quot;, &quot;93&quot;, &quot;18&quot;];
    let empty = vec![];
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];

    print(double_first(numbers));
    print(double_first(empty));
    print(double_first(strings));
}
</code></pre></pre>
<p>이렇게 하면 에러를 처리하기 위한 보일러플레이트가 약간 더 추가되며, 일부 애플리케이션에는 이것이 필요하지 않을 수 있습니다. 보일러플레이트를 대신 해결해주는 몇몇 라이브러리들이 존재합니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="iterating-over-results"><a class="header" href="#iterating-over-results">Iterating over Results</a></h1>
<p><code>Iter::map</code> 명령은 실패할 수도 있습니다. 예를 들면 :</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>여러 전략들을 통해 이를 다루어보겠습니다.</p>
<h2 id="filter_map으로-실패한-항목들을-무시하기"><a class="header" href="#filter_map으로-실패한-항목들을-무시하기"><code>filter_map()</code>으로 실패한 항목들을 무시하기</a></h2>
<p><code>filter_map</code>은 함수를 호출하고, <code>None</code> 결과는 걸러냅니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Vec&lt;_&gt; = strings
        .into_iter()
        .filter_map(|s| s.parse::&lt;i32&gt;().ok())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<h2 id="collect로-전체-작업들을-실패시키기"><a class="header" href="#collect로-전체-작업들을-실패시키기"><code>collect()</code>로 전체 작업들을 실패시키기</a></h2>
<p><code>Result</code>는 <code>FromIter</code>를 구현하며, 따라서 결과를 가진 벡터(<code>Vec&lt;Result&lt;T, E&gt;&gt;</code>)는 벡터를 가진 결과(<code>Result&lt;Vec&lt;T&gt;, E&gt;</code>)로 변환될 수 있습니다. 한번 <code>Result::Err</code>이 발견되는 순간, 순환은 종료될 것입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let numbers: Result&lt;Vec&lt;_&gt;, _&gt; = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .collect();
    println!(&quot;Results: {:?}&quot;, numbers);
}
</code></pre></pre>
<p>이는 <code>Option</code>을 사용한 것과 동일한 테크닉입니다.</p>
<h2 id="partition으로-모든-유효한-값과-실패failures를-수집하기"><a class="header" href="#partition으로-모든-유효한-값과-실패failures를-수집하기"><code>partition()</code>으로 모든 유효한 값과 실패(failures)를 수집하기</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<p>이 경우, 결과들이 여전히 <code>Result</code>로 감싸진 것을 확인할 수 있습니다. 이를 해결하기 위해서는 약간의 보일러플레이트가 더 요구됩니다. </p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let strings = vec![&quot;tofu&quot;, &quot;93&quot;, &quot;18&quot;];
    let (numbers, errors): (Vec&lt;_&gt;, Vec&lt;_&gt;) = strings
        .into_iter()
        .map(|s| s.parse::&lt;i32&gt;())
        .partition(Result::is_ok);
    let numbers: Vec&lt;_&gt; = numbers.into_iter().map(Result::unwrap).collect();
    let errors: Vec&lt;_&gt; = errors.into_iter().map(Result::unwrap_err).collect();
    println!(&quot;Numbers: {:?}&quot;, numbers);
    println!(&quot;Errors: {:?}&quot;, errors);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="std-library-types"><a class="header" href="#std-library-types">Std library types</a></h1>
<p><code>std</code> 라이브러리는 원시값(primitive)에서 급격하게 확장되는 수많은 커스텀 타입들을 제공합니다. 아래와 같은 것들이 있습니다.</p>
<ul>
<li>가변 <code>String</code> : `&quot;hello world&quot;</li>
<li>가변 벡터 : <code>[1, 2, 3]</code></li>
<li>옵션 타입 : <code>Option&lt;i32&gt;</code></li>
<li>에러 핸들링 타입 : <code>Result&lt;i32, i32&gt;</code></li>
<li>힙 할당 포인터 : <code>Box&lt;i32&gt;</code></li>
</ul>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="box-stack-and-heap"><a class="header" href="#box-stack-and-heap">Box, stack, and heap</a></h1>
<p>Rust의 모든 값들은 기본적으로 스택에 할당됩니다. 값(value)들은 <code>Box&lt;T&gt;</code>를 통해서 박싱될(<em>boxed</em>) 수 있습니다. (이 경우 힙에 할당됩니다.) <code>Box</code>는 힙에 할당된 <code>T</code> 타입의 값을 가리키는 똑똑한 포인터입니다. 박스가 스코프에서 벗어날 때, 해당 박스의 해체자(destructor)가 동작하며, 내부 객체는 파괴되고, 할당되었던 힙의 메모리도 해제(freed)됩니다.</p>
<p>박싱된 값은 <code>*</code> 연산자로 역참조될 수 있습니다. 이를 통해 간접적인 요소를 한겹 제거해냅니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::mem;

#[allow(dead_code)]
#[derive(Debug, Clone, Copy)]
struct Point {
    x: f64,
    y: f64,
}

// 사각형은 좌상단과 우하단의 값으로 구체화될 수 있습니다.
#[allow(dead_code)]
struct Rectangle {
    top_left: Point,
    bottom_right: Point,
}

fn origin() -&gt; Point {
    Point { x: 0.0, y: 0.0 }
}

fn boxed_origin() -&gt; Box&lt;Point&gt; {
    // 힙에 할당된 포인터를 가리킵니다.
    // 그리고 이에 대한 포인터를 반환합니다.
    Box::new(Point { x: 0.0, y: 0.0 })
}

fn main() {
    // 스택에 할당된 변수들입니다.
    // 이 때 모든 타입 지정은 불필요합니다.
    let point: Point = origin();
    let rectangle: Rectangle = Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 }
    };

    // 힙에 할당된 `rectangle`입니다.
    let boxed_rectangle: Box&lt;Rectangle&gt; = Box::new(Rectangle {
        top_left: origin(),
        bottom_right: Point { x: 3.0, y: -4.0 },
    });

    // 함수들의 결과도 박싱될 수 있습니다.
    let boxed_point: Box&lt;Point&gt; = Box::new(origin());

    // 이중으로 박싱합니다.
    let box_in_a_box: Box&lt;Box&lt;Point&gt;&gt; = Box::new(boxed_origin());

    println!(&quot;Point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;point));
    println!(&quot;Rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;rectangle));

    // 박스의 크기 == 포인터 크기
    println!(&quot;Boxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_point));
    println!(&quot;Boxed rectangle occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;boxed_rectangle));
    println!(&quot;Boxed box occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;box_in_a_box));

    // `boxed_point`에 포함된 데이터를 `unboxed_point`에 복사합니다.
    let unboxed_point: Point = *boxed_point;
    println!(&quot;Unboxed point occupies {} bytes on the stack&quot;,
             mem::size_of_val(&amp;unboxed_point));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="vectors"><a class="header" href="#vectors">Vectors</a></h1>
<p>벡터는 가변적인 사이즈를 갖는 Array입니다. Slice와 유사하게, 이들 사이즈는 컴파일 시점에는 알 수 없고, 어느 때나 늘어나고 줄어들 수 있습니다. 벡터는 다음 3개의 파라미터로 표현될 수 있습니다.</p>
<ul>
<li>데이터에 대한 포인터</li>
<li>길이</li>
<li>용량</li>
</ul>
<p>용량(capacity)은 현재 해당 벡터에 예약된 메모리가 얼마나 되는지를 나타냅니다. 벡터는 이 용량 이하로만 길이를 늘릴 수 있습니다. 해당 용량을 초과해야 하는 경우라면, 벡터는 더 큰 용량으로 재할당됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 순환자는 벡터에 의해 수집될 수 있습니다.
    let collected_iterator: Vec&lt;i32&gt; = (0..10).collect();
    println!(&quot;Collected (0..10) into: {:?}&quot;, collected_iterator);

    // `vec!` 매크로는 벡터를 초기화하기 위해 사용됩니다.
    let mut xs = vec![1i32, 2, 3];
    println!(&quot;Initial vector: {:?}&quot;, xs);

    // 벡터의 끝에 새로운 요소를 추가합니다.
    println!(&quot;Push 4 into the vector&quot;);
    xs.push(4);
    println!(&quot;Vector: {:?}&quot;, xs);

    // ERROR : immutable한 벡터는 길이가 늘어날 수 없습니다.
    collected_iterator.push(0);

    // `len` 메서드는 벡터에 현재 저장된 요소의 수를 반환합니다.
    println!(&quot;Vector length: {}&quot;, xs.len());

    // `[]`를 사용하여 인덱싱을 적용할 수 있습니다.
    println!(&quot;Second element: {}&quot;, xs[1]);

    // `pop`은 벡터의 마지막 값을 반환하고, 제거합니다.
    println!(&quot;Pop last element: {:?}&quot;, xs.pop());

    // ERROR : 벡터의 범위를 벗어나는 값에 대한 인덱싱은 에러를 유발합니다.
    println!(&quot;Fourth element: {}&quot;, xs[3]);

    // 벡터는 간단하게 순회될 수 있습니다.
    println!(&quot;Contents of xs:&quot;);
    for x in xs.iter() {
        println!(&quot;&gt; {}&quot;, x);
    }

    // `enumerate()`메서드로 순회 인덱싱과 값을 별도로 구분하여 순회될 수도 있습니다.
    for (i, x) in xs.iter().enumerate() {
        println!(&quot;In position {} we have value {}&quot;, i, x);
    }

    // `iter_mut` 덕분에, mutable한 벡터는
    // 각각의 값에 대한 변경을 허용한 채로
    // 순회될 수도 있습니다!
    for x in xs.iter_mut() {
        *x *= 3;
    }
    println!(&quot;Updated vector: {:?}&quot;, xs);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>Rust에는 두 가지 타입의 String이 있습니다. : <code>String</code>과 <code>&amp;str</code> 입니다.</p>
<p><code>String</code>은 바이트 단위의 벡터에 저장됩니다. (<code>Vec&lt;u8&gt;</code>) 이는 항상 유효한 UTF-8 시퀀스임을 보장합니다. 또한 <code>String</code>은 힙에 할당되며, 길이가 가변적이면서, <a href="https://ko.wikipedia.org/wiki/%EB%84%90_%EC%A2%85%EB%8B%A8_%EB%AC%B8%EC%9E%90%EC%97%B4">Null-terminated</a>가 아닙니다.</p>
<p><code>&amp;str</code>은 항상 유효한 UTF-8 시퀀스를 가리키는 Slice입니다. (<code>&amp;[u8]</code>) 또, 이는 <code>String</code>처럼 보이도록 사용될 수 있습니다. 단순히 <code>&amp;[T]</code>가 <code>Vec&lt;T&gt;</code>에 대한 보기인 것 처럼요.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // (모든 타입 선언은 사실 불필요합니다.)

    // 읽기 전용 메모리에 할당된 str에 대한 참조입니다.
    let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
    println!(&quot;Pangram: {}&quot;, pangram);

    // 단어들을 거꾸로 순회합니다.
    // 새로운 문자열이 할당되지는 않습니다.
    println!(&quot;Words in reverse&quot;);
    for word in pangram.split_whitespace().rev() {
        println!(&quot;&gt; {}&quot;, word);
    }

    // Char들을 벡터로 복사합니다.
    // 정렬 이후 중복값들을 없앱니다.
    let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
    chars.sort();
    chars.dedup();

    // 비어있는 가변적인 `String`을 생성합니다.
    let mut string = String::new();
    for c in chars {
        // 문자열 끝에 char을 추가합니다.
        string.push(c);
        // 문자열 끝에 문자열을 추가합니다.
        string.push_str(&quot;, &quot;);
    }

    // 잘라낸 문자열은 기존 문자열의 slice입니다.
    // 따라서 새로운 할당이 이루어지지는 않습니다.
    let chars_to_trim: &amp;[char] = &amp;[' ', ','];
    let trimmed_str: &amp;str = string.trim_matches(chars_to_trim);
    println!(&quot;Used characters: {}&quot;, trimmed_str);

    // 힙에 문자열을 할당합니다.
    let alice = String::from(&quot;I like dogs&quot;);
    // 새로운 메모리를 할당하고 수정된 문자열을 저장합니다.
    let bob: String = alice.replace(&quot;dog&quot;, &quot;cat&quot;);

    println!(&quot;Alice says: {}&quot;, alice);
    println!(&quot;Bob says: {}&quot;, bob);
}
</code></pre></pre>
<p><code>str</code>과 <code>String</code> 메서드에 대한 더 많은 내용은 각각의 모듈에 대한 문서를 참조하세요.</p>
<h2 id="literals-and-escapes"><a class="header" href="#literals-and-escapes">Literals and escapes</a></h2>
<p>특수문자가 포함된 문자열 리터럴을 작성하는 방법에는 여러가지가 있습니다. 모든 결과가 <code>&amp;str</code>와 유사하기 때문에, 작성하기에 편한 방법을 선택하면 됩니다. 바이트 스트링 리터럴(Byte string literals)을 작성하는 방법에도 여러가지가 존재하며, 그 결과도 모두 <code>&amp;[u8; N]</code>으로 동일합니다.</p>
<p>일반적으로 특수문자들은 백슬래시(<code>\</code>)로 이스케이프됩니다. 이를 통해, 출력될 수 없는 문자열 혹은 입력 방법을 모르는 문자열도 추가할 수 있습니다. 리터럴 백슬래시(백슬래시 그 자체)를 입력하고 싶다면, 이를 또다른 백슬래시로 이스케이핑하면 됩니다. (<code>\\</code>)</p>
<p>문자열 또는 캐릭터 리터럴 내에서 발생하는 따옴표도 이스케이프 처리되어야 합니다. (<code>&quot;\&quot;&quot;</code>, <code>'\''</code>)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    // 16진수를 기반으로 바이트를 이스케이프 처리합니다.
    let byte_escape = &quot;I'm writing \x52\x75\x73\x74!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // 유니코드도 이스케이프 처리해봅시다.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );


    let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here -&gt;\
                        &lt;- can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<p>때때로, 이스케이프 처리해야 하는 문자열이 너무 많거나, 단순히 String을 출력 그 자체로 활용하고 싶을 수 있습니다. 이 경우 Raw 문자열 리터럴(Raw string literal)을 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    println!(&quot;{}&quot;, raw_str);

    // raw 문자열에서 따옴표가 필요한 `#s` 쌍을 추가합니다.
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // 문자열에 &quot;# 이 필요한 경우, `#`을 더 많이 사용합시다.
    // 사용할 수 있는 `#`의 수에는 제한이 없습니다.
    let longer_delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, longer_delimiter);
}
</code></pre></pre>
<p>UTF-8이 아닌 문자열을 원하나요? (<code>str</code>와 <code>String</code>이 항상 유효한 UTF-8임을 기억하세요.) 아니면 대부분이 텍스트인 바이트 배열을 원하나요? 바이트 문자열(Byte string)이 도와줄겁니다!</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::str;

fn main() {
    // 아래 변수는 `&amp;str`이 아님을 기억하세요.
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte Array는 `Display` 트레이트를 갖고 있지 않습니다.
    // 따라서 이를 출력하는 것은 조금 제한적입니다.
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte String을 byte 이스케이프를 가질 수 있습니다.
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);

    // ERROR : 하지만 유니코드는 이스케이프 할 수 없습니다.
    let escaped = b&quot;\u{211D} is not allowed&quot;;

    // Raw 바이트 스트링은 Raw 스트링과 동일하게 동작합니다.
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Byte array를 `str`로 변환하는 것은 실패합니다.
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte 문자열은 UTF-8이 될 수 없습니다.
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ようこそ&quot; in SHIFT-JIS

    // 하지만 여전히 `str`로 변환될 수 없습니다.
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>캐릭터 인코딩 간의 변환은 <a href="https://crates.io/crates/encoding">encoding</a> 크레이트를 참조하세요.</p>
<p>문자열 리터럴과 이스케이프 문자를 작성하는 구체적인 방법들은 <a href="https://doc.rust-lang.org/reference/tokens.html">여기</a>에서 확인할 수 있습니다.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="option"><a class="header" href="#option">Option</a></h1>
<p>종종 <code>panic!</code> 호출 대신 프로그램의 일부에 대한 실패를 잡아내는 것이 더 이상적인 경우도 있습니다. 이런 경우 <code>Option</code> enum을 사용할 수 있습니다.</p>
<p><code>Option&lt;T&gt;</code> enum은 다음의 두가지 변형을 갖습니다.</p>
<ul>
<li><code>None</code> : 실패 또는 값의 부재를 나타냅니다.</li>
<li><code>Some(value)</code> : <code>T</code> 타입을 가진 <code>value</code>을 감싸는 튜플 구조</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">// `panic!`을 사용하지 않는 정수 나눗셈
fn checked_division(dividend: i32, divisor: i32) -&gt; Option&lt;i32&gt; {
    if divisor == 0 {
        // 작업이 실패한 경우 `None` 변형을 반환합니다.
        None
    } else {
        // 결과는 `Some` 변형으로 감싸집니다.
        Some(dividend / divisor)
    }
}

// 아래 함수는 성공하지 못한 나눗셈을 처리합니다.
fn try_division(dividend: i32, divisor: i32) {
    // `Option` 값은 다른 enum들과 동일하게 `match`를 사용할 수 있습니다.
    match checked_division(dividend, divisor) {
        None =&gt; println!(&quot;{} / {} failed!&quot;, dividend, divisor),
        Some(quotient) =&gt; {
            println!(&quot;{} / {} = {}&quot;, dividend, divisor, quotient)
        },
    }
}

fn main() {
    try_division(4, 2);
    try_division(1, 0);

    // 변수에 `None`을 바인딩하기 위해서는 타입이 지정되어야 합니다.
    let none: Option&lt;i32&gt; = None;
    let _equivalent_none = None::&lt;i32&gt;;

    let optional_float = Some(0f32);

    // `unwrap`은 래핑 처리된 값을 추출해냅니다.
    println!(&quot;{:?} unwraps to {:?}&quot;, optional_float, optional_float.unwrap());

    // `None` 변형에 대한 `unwrap`의 사용은 `panic!`을 유발합니다.
    println!(&quot;{:?} unwraps to {:?}&quot;, none, none.unwrap());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="result-1"><a class="header" href="#result-1">Result</a></h1>
<p><code>Option</code> enum은 실패할지도 모르는 함수의 반환값으로서 사용될 수 있습니다. 이 때, <code>None</code>이 작업의 실패를 나타내기 위해 반환됩니다. 그러나, 종종 왜 해당 작업이 실패했는지에 대해 알려주는 것은 중요합니다. 이를 위해선 <code>Result</code> enum을 사용할 수 있습니다.</p>
<p><code>Result&lt;T, E&gt;</code> enum은 다음의 두 변형을 가질 수 있습니다.</p>
<ul>
<li><code>Ok(value)</code>는 작업의 성공을 나타냅니다. 작업 이후 반환되는 값 <code>value</code>을 감쌉니다. (<code>value</code>는 <code>T</code> 타입을 갖습니다.)</li>
<li><code>Err(why)</code>는 작업의 실패를 나타냅니다. 이는 <code>why</code>를 감싸며, 이는 실패의 원인에 대해 설명합니다. (<code>why</code>는 <code>E</code> 타입을 갖습니다.)</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2018">mod checked {
    // 우리가 잡아내고자 하는 수학적인 Error들입니다.
    #[derive(Debug)]
    pub enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    pub type MathResult = Result&lt;f64, MathError&gt;;

    pub fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            // 해당 작업이 실패하면,
            // `Err`로 실패의 원인을 반환합니다.
            Err(MathError::DivisionByZero)
        } else {
            // 해당 작업이 유효하다면,
            // 그 결과를 `Ok`로 감싸서 반환합니다.
            Ok(x / y)
        }
    }

    pub fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    pub fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }
}

// `op(x, y)` === `sqrt(ln(x / y))`
fn op(x: f64, y: f64) -&gt; f64 {
    // 아래는 3단계에 걸친 match 입니다.
    match checked::div(x, y) {
        Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
        Ok(ratio) =&gt; match checked::ln(ratio) {
            Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
            Ok(ln) =&gt; match checked::sqrt(ln) {
                Err(why) =&gt; panic!(&quot;{:?}&quot;, why),
                Ok(sqrt) =&gt; sqrt,
            },
        },
    }
}

fn main() {
    println!(&quot;{}&quot;, op(1.0, 10.0));
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id=""><a class="header" href="#">?</a></h1>
<p><code>match</code>를 통한 체이닝 결과는 상당히 지저분해 보일 수 있습니다. <code>?</code> 연산자는 이 경우 코드를 좀 더 &quot;이쁘게&quot; 보이도록 할 수 있습니다. <code>?</code>은 <code>Result</code>이 반환되는 Expression의 끝에 사용됩니다. <code>match</code> 문과 동일하게, <code>Err(err)</code> 분기는 <code>Err(From::from(err))</code>로 확장되며, <code>Ok(ok)</code> 분기는 <code>ok</code> 문으로 확장됩니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">mod checked {
    #[derive(Debug)]
    enum MathError {
        DivisionByZero,
        NonPositiveLogarithm,
        NegativeSquareRoot,
    }

    type MathResult = Result&lt;f64, MathError&gt;;

    fn div(x: f64, y: f64) -&gt; MathResult {
        if y == 0.0 {
            Err(MathError::DivisionByZero)
        } else {
            Ok(x / y)
        }
    }

    fn sqrt(x: f64) -&gt; MathResult {
        if x &lt; 0.0 {
            Err(MathError::NegativeSquareRoot)
        } else {
            Ok(x.sqrt())
        }
    }

    fn ln(x: f64) -&gt; MathResult {
        if x &lt;= 0.0 {
            Err(MathError::NonPositiveLogarithm)
        } else {
            Ok(x.ln())
        }
    }

    // 중간 함수
    fn op_(x: f64, y: f64) -&gt; MathResult {
        // `div` 함수가 실패한다면,
        // `DivisionByZero`가 반환됩니다.
        let ratio = div(x, y)?;

        // `ln` 함수가 실패한다면,
        // `NonPositiveLogarithm`이 반환됩니다.
        let ln = ln(ratio)?;

        sqrt(ln)
    }

    pub fn op(x: f64, y: f64) {
        match op_(x, y) {
            Err(why) =&gt; panic!(match why {
                MathError::NonPositiveLogarithm
                    =&gt; &quot;logarithm of non-positive number&quot;,
                MathError::DivisionByZero
                    =&gt; &quot;division by zero&quot;,
                MathError::NegativeSquareRoot
                    =&gt; &quot;square root of negative number&quot;,
            }),
            Ok(value) =&gt; println!(&quot;{}&quot;, value),
        }
    }
}

fn main() {
    checked::op(1.0, 10.0);
}
</code></pre></pre>
<p><code>Result</code>에 사용되는 많은 메서드들을 확인하려면 <a href="https://doc.rust-lang.org/std/result/index.html">여기</a>를 확인하세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="panic-1"><a class="header" href="#panic-1">panic!</a></h1>
<p><code>panic!</code> 매크로는 <code>panic</code>를 생성하고 스택을 되감을 수 있습니다. 되감는 도중, 런타임은 모든 객체의 소멸자들을 호출하여 스레드에 의해 <em>소유된(owned)</em> 모든 리소스를 해제하는 작업을 수행합니다.</p>
<p>프로그램이 오직 하나의 스레드로 다루어지는 한, <code>panic!</code>은 프로그램이 패닉 메시지를 보고하고 종료하도록 합니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">// 정수 나눗셈 (/)에 대해 다시 구현해봅시다.
fn division(dividend: i32, divisor: i32) -&gt; i32 {
    if divisor == 0 {
        // `0`으로 나누는 경우 `panic`을 발생시킵니다.
        panic!(&quot;division by zero&quot;);
    } else {
        dividend / divisor
    }
}

// `main` 작업
fn main() {
    // 힙에 할당된 정수
    let _x = Box::new(0i32);

    // 해당 작업은 실패를 유발합니다.
    division(3, 0);

    println!(&quot;This point won't be reached!&quot;);

    // `_x` 는 이 시점에서 파괴되어야 합니다.
}
</code></pre></pre>
<p><code>panic!</code>이 메모리 누수을 일으키고 있지는 않은지 확인해봅시다.</p>
<pre><code>$ rustc panic.rs &amp;&amp; valgrind ./panic
==4401== Memcheck, a memory error detector
==4401== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.
==4401== Using Valgrind-3.10.0.SVN and LibVEX; rerun with -h for copyright info
==4401== Command: ./panic
==4401== 
thread '&lt;main&gt;' panicked at 'division by zero', panic.rs:5
==4401== 
==4401== HEAP SUMMARY:
==4401==     in use at exit: 0 bytes in 0 blocks
==4401==   total heap usage: 18 allocs, 18 frees, 1,648 bytes allocated
==4401== 
==4401== All heap blocks were freed -- no leaks are possible
==4401== 
==4401== For counts of detected and suppressed errors, rerun with: -v
==4401== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p>벡터가 정수 인덱스에 의해 저장되는 반면, 해쉬맵(<code>HashMap</code>)은 값을 <code>key</code>에 기반하여 저장합니다. <code>HashMap</code> 키로는 boolean, 정수, 문자열, 그외에 <code>Eq</code>와 <code>Hash</code> 트레이트를 구현하는 어떤 타입이든 사용할 수 있습니다. 이에 대해선 다음 섹션에서 살펴보겠습니다.</p>
<p>벡터와 유사하게, <code>HashMap</code>은 가변 길이를 갖고 있습니다. 반면 <code>HashMap</code>은 너무 많은 공간을 차지하는 경우 자체적으로 축소될 수 있습니다. 해쉬맵은 <code>HashMap::with_capacity(uint)</code>을 사용하여 최초 용량을 지정한 채로 생성될 수 있습니다. 또는 <code>HashMap::new()</code>를 사용하여 기본 최초 용량으로 해쉬맵을 생성할 수 있습니다. (후자를 추천합니다.)</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::collections::HashMap;

fn call(number: &amp;str) -&gt; &amp;str {
    match number {
        &quot;798-1364&quot; =&gt; &quot;We're sorry, the call cannot be completed as dialed. 
            Please hang up and try again.&quot;,
        &quot;645-7689&quot; =&gt; &quot;Hello, this is Mr. Awesome's Pizza. My name is Fred.
            What can I get for you today?&quot;,
        _ =&gt; &quot;Hi! Who is this again?&quot;
    }
}

fn main() { 
    let mut contacts = HashMap::new();

    contacts.insert(&quot;Daniel&quot;, &quot;798-1364&quot;);
    contacts.insert(&quot;Ashley&quot;, &quot;645-7689&quot;);
    contacts.insert(&quot;Katie&quot;, &quot;435-8291&quot;);
    contacts.insert(&quot;Robert&quot;, &quot;956-1745&quot;);

    // 참조를 받아 `Option&lt;&amp;V&gt;`를 반환합니다.
    match contacts.get(&amp;&quot;Daniel&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Daniel: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Daniel's number.&quot;),
    }

    // `HashMap::insert()`는 만약 삽입된 값이 
    // 새로운 값인 경우 `None`을 반환하고,
    // 그렇지 않은 경우 `Some(value)`를 반환합니다.
    contacts.insert(&quot;Daniel&quot;, &quot;164-6743&quot;);

    match contacts.get(&amp;&quot;Ashley&quot;) {
        Some(&amp;number) =&gt; println!(&quot;Calling Ashley: {}&quot;, call(number)),
        _ =&gt; println!(&quot;Don't have Ashley's number.&quot;),
    }

    contacts.remove(&amp;&quot;Ashley&quot;); 

    // `HashMap::iter()`는 임의의 순서로
    // (&amp;'a key, &amp;'a value) 쌍을 생성하는 반복기를 반환합니다.
    for (contact, &amp;number) in contacts.iter() {
        println!(&quot;Calling {}: {}&quot;, contact, call(number)); 
    }
}
</code></pre></pre>
<p>해시 및 해시 맵(해시 테이블이라고도 합니다)의 작동 방식에 대한 자세한 내용은 <a href="https://en.wikipedia.org/wiki/Hash_table">여기</a>를 참조하세요.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="alternatecustom-key-types"><a class="header" href="#alternatecustom-key-types">Alternate/custom key types</a></h1>
<p><code>Eq</code>와 <code>Hash</code> 트레이트를 구현하는 어떤 타입이든 <code>HashMap</code> 내에서 Key로 사용될 수 있습니다. 여기엔 다음과 같은 것들이 포함됩니다.</p>
<ul>
<li><code>bool</code> (오직 두 개의 값만 존재해서 실용성이 없긴 합니다.)</li>
<li><code>int</code>, <code>uint</code>, 그 외의 여러 <code>int</code> 종류들</li>
<li><code>String</code>과 <code>&amp;str</code> (<code>String</code>을 Key로 사용하는 HashMap과 <code>&amp;str</code>로 <code>.get()</code>를 호출할 수 있습니다.)</li>
</ul>
<p><code>f32</code>와 <code>f64</code>는 해쉬를 구현할 수 없음을 기억하세요. <a href="https://en.wikipedia.org/wiki/Floating_point#Accuracy_problems">부동소수점 에러</a>로 인해, 해쉬맵 키로 사용되는 경우 오류가 발생하기 쉽기 때문입니다.</p>
<p>컬렉션 유형의 경우, 포함된 유형이 각각 <code>Eq</code>와 <code>Hash</code>를 구현하는 경우, 마찬가지로 <code>Eq</code>와 <code>Hash</code>를 구현합니다. 예를 들어, <code>Vec&lt;T&gt;</code>는 <code>T</code>가 <code>Hash</code>를 구현한다면 마찬가지로 <code>Hash</code>를 구현합니다.</p>
<p><code>#[derive(PartialEq, Eq, Hash)]</code>를 사용한다면 커스텀 타입에 대한 <code>Eq</code>와 <code>Hash</code>를 쉽게 구현할 수 있습니다.</p>
<p>컴파일러가 나머지 부분들을 처리합니다. 만약, 좀더 구체적인 사항에 대한 구현을 원한다면, <code>Eq</code> 또는 <code>Hash</code>를 직접 구현할 수 있습니다. 여기서는 <code>Hash</code> 구현에 대한 자세한 내용은 다루지 않겠습니다.</p>
<p><code>HashMap</code>에서 <code>struct</code>를 사용해보기 위해, 매우 간단한 로그온 시스템을 구현해봅시다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">use std::collections::HashMap;

// Eq를 사용하려면 타입에 대한 PartialEq를 파생해야 합니다.
#[derive(PartialEq, Eq, Hash)]
struct Account&lt;'a&gt;{
    username: &amp;'a str,
    password: &amp;'a str,
}

struct AccountInfo&lt;'a&gt;{
    name: &amp;'a str,
    email: &amp;'a str,
}

type Accounts&lt;'a&gt; = HashMap&lt;Account&lt;'a&gt;, AccountInfo&lt;'a&gt;&gt;;

fn try_logon&lt;'a&gt;(accounts: &amp;Accounts&lt;'a&gt;,
        username: &amp;'a str, password: &amp;'a str){
    println!(&quot;Username: {}&quot;, username);
    println!(&quot;Password: {}&quot;, password);
    println!(&quot;Attempting logon...&quot;);

    let logon = Account {
        username,
        password,
    };

    match accounts.get(&amp;logon) {
        Some(account_info) =&gt; {
            println!(&quot;Successful logon!&quot;);
            println!(&quot;Name: {}&quot;, account_info.name);
            println!(&quot;Email: {}&quot;, account_info.email);
        },
        _ =&gt; println!(&quot;Login failed!&quot;),
    }
}

fn main(){
    let mut accounts: Accounts = HashMap::new();

    let account = Account {
        username: &quot;j.everyman&quot;,
        password: &quot;password123&quot;,
    };

    let account_info = AccountInfo {
        name: &quot;John Everyman&quot;,
        email: &quot;j.everyman@email.com&quot;,
    };

    accounts.insert(account, account_info);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;psasword123&quot;);

    try_logon(&amp;accounts, &quot;j.everyman&quot;, &quot;password123&quot;);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="hashset"><a class="header" href="#hashset">HashSet</a></h1>
<p><code>HashSet</code>을 단순히 Key에 관심을 갖는 <code>HashMap</code>으로 간주해도 좋습니다. 실제로 <code>HashSet&lt;T&gt;</code>는 <code>HashMap&lt;T, ()&gt;</code>의 래퍼(wrapper)일 뿐입니다.</p>
<p>&quot;그래서, 그게 무슨 소용인데요?&quot;라고 묻는다면, &quot;Key를 <code>Vec</code>에 보관하면 됩니다.&quot;</p>
<p><code>HashSet</code>의 독특한 특징은 중복된 요소들을 갖지 않음을 보장한다는 것입니다. 이는 모든 Set 컬렉션들이 수행하는 조건입니다. <code>HashSet</code>은 그 중 하나의 구현일 뿐입니다. (<a href="https://doc.rust-lang.org/std/collections/struct.BTreeSet.html">BTreeSet</a>도 확인해보세요.)</p>
<p>만약, <code>HashSet</code>에 이미 존재하는 값을 삽입한다면, 새로운 값이 기존의 값을 대체됩니다. </p>
<p><code>HashSet</code>은 중복값을 절대 허용하지 않거나, 이미 갖고있는 값에 대해 체크해야 할 때 매우 유용합니다.</p>
<p>반면, Set는 여전히 그 이상을 할 수 있습니다.</p>
<p>Set는 4가지 기본 작업을 수행합니다. 다음의 모든 호출들은 반복자(iterator)를 반환합니다.</p>
<ul>
<li><code>union</code>: 두 Set의 합집합을 가져옵니다.</li>
<li><code>difference</code> : 첫번째 Set에는 있으나 두번째 Set에는 없는 모든 요소들을 가져옵니다.</li>
<li><code>intersection</code> : 두 Set의 교집합을 가져옵니다.</li>
<li><code>symmetric_difference</code> : 두 Set의 대칭차(symmetric difference)를 가져옵니다. (union - intersection)</li>
</ul>
<p>아래 예시를 살펴봅시다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::collections::HashSet;

fn main() {
    let mut a: HashSet&lt;i32&gt; = vec![1i32, 2, 3].into_iter().collect();
    let mut b: HashSet&lt;i32&gt; = vec![2i32, 3, 4].into_iter().collect();

    assert!(a.insert(4));
    assert!(a.contains(&amp;4));

    // 만약 이미 값이 존재하는 경우
    // `HashSet::insert()`는 `false`를 반환합니다.
    assert!(b.insert(4), &quot;Value 4 is already in set B!&quot;);

    b.insert(5);

    // 컬렉션의 요소 타입이 `Debug`를 구현하는 경우,
    // 해당 요소의 컬렉션도 `Debug`를 구현합니다.
    // 이는 일반적으로 `[elem1, elem2, ...]`의 형태로 출력됩니다.
    println!(&quot;A: {:?}&quot;, a);
    println!(&quot;B: {:?}&quot;, b);

    // 임의의 순서로 `[1, 2, 3, 4, 5]`를 출력합니다.
    println!(&quot;Union: {:?}&quot;, a.union(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 이는 `[1]`를 출력합니다.
    println!(&quot;Difference: {:?}&quot;, a.difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 임의의 순서로 `[2, 3, 4]`를 출력합니다.
    println!(&quot;Intersection: {:?}&quot;, a.intersection(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());

    // 이는 `[1, 5]`를 출력합니다.
    println!(&quot;Symmetric Difference: {:?}&quot;,
             a.symmetric_difference(&amp;b).collect::&lt;Vec&lt;&amp;i32&gt;&gt;());
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="rc"><a class="header" href="#rc">Rc</a></h1>
<p>다중 소유권(Multiple ownership)이 요구되는 경우, <code>Rc</code>(Reference Counting)이 사용될 수 있습니다. <code>Rc</code>는 참조의 수(<em><code>Rc</code> 내에 포장된 값의 소유자(onwer)의 수</em>)를 추적합니다. </p>
<p><code>Rc</code>의 참조 갯수는 <code>Rc</code>가 복사(clone)될 때마다 1씩 증가하고, 복사된 <code>Rc</code>가 스코프를 벗어날 때마다 1씩 감소합니다. <code>Rc</code>의 참조 갯수가 0이 되면, 이는 아무 소유자도 남아있지 않음을 의미하며, 이 때는 <code>Rc</code>와 내부 값 모두 제거됩니다.</p>
<p><code>Rc</code>의 복사는 절대 <em>깊은 복사</em>를 수행하지 않습니다. 여기서의 복사는 단순히 감싸진 값에 대한 또다른 포인터만을 생성해낼 뿐입니다.</p>
<pre><pre class="playground"><code class="language-rust editable edition2018">use std::rc::Rc;

fn main() {
    let rc_examples = &quot;Rc examples&quot;.to_string();
    {
        println!(&quot;--- rc_a is created ---&quot;);
        
        let rc_a: Rc&lt;String&gt; = Rc::new(rc_examples);
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        {
            println!(&quot;--- rc_a is cloned to rc_b ---&quot;);
            
            let rc_b: Rc&lt;String&gt; = Rc::clone(&amp;rc_a);
            println!(&quot;Reference Count of rc_b: {}&quot;, Rc::strong_count(&amp;rc_b));
            println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
            
            // 내부 값이 동일하다면 두 `Rc`는 동일합니다.
            println!(&quot;rc_a and rc_b are equal: {}&quot;, rc_a.eq(&amp;rc_b));
            
            // 내부 값의 메서드를 곧바로 사용할 수 있습니다.
            println!(&quot;Length of the value inside rc_a: {}&quot;, rc_a.len());
            println!(&quot;Value of rc_b: {}&quot;, rc_b);
            
            println!(&quot;--- rc_b is dropped out of scope ---&quot;);
        }
        
        println!(&quot;Reference Count of rc_a: {}&quot;, Rc::strong_count(&amp;rc_a));
        
        println!(&quot;--- rc_a is dropped out of scope ---&quot;);
    }
    
    // ERROR : `rc_examples`는 이미 `rc_a`로 이동했습니다.
    // `rc_a`가 제거될 때, `rc_examples`도 같이 제거됩니다.
    println!(&quot;rc_examples: {}&quot;, rc_examples);
}
</code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="arc"><a class="header" href="#arc">Arc</a></h1>
<p>스레드 간에도 소유권의 공유가 필요할 때, <code>Arc</code>(Atomic Reference Counted)가 사용될 수 있습니다. 이 구조는 <code>Clone</code> 구현을 통해, 참조 카운트를 증가시키며, 동시에 메모리 힙 내의 값의 위치에 대한 참조 포인터를 생성합니다. 이는 쓰레드 간의 소유권도 공유할 수 있기 때문에, 값에 대한 마지막 참조 포인터가 스코프를 벗어나게 되면, 해당 변수도 제거됩니다.</p>
<pre><pre class="playground"><code class="language-rust edition2018">fn main() {
  use std::sync::Arc;
  use std::thread;

  // 아래 변수 선언은 값을 지정할 위치에 해당합니다.
  let apple = Arc::new(&quot;the same apple&quot;);

  for _ in 0..10 {
      // 이는 메모리 힙 내의 참조에 대한 포인터입니다.
      // 따라서 여기서는 값(value)을 사용할 수 없습니다.
      let apple = Arc::clone(&amp;apple);

      thread::spawn(move || {
          // Arc가 사용된 경우,
          // 스레드는 Arc 변수 포인터의 위치에
          // 할당된 값을 통해 생성될 수 있습니다.
          println!(&quot;{:?}&quot;, apple);
      });
  }
}
</code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
