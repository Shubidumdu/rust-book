# Type anonymity

클로저는 스코프를 폐쇄함으로써 간단하게 변수들을 캡처합니다. 이 방법에도 단점이 있을까요? 당연히 그렇습니다. 클로저를 함수의 매개변수로 사용하는 경우, 제네릭이 어떻게 정의되는지 살펴봅시다.

```rust,editable
#![allow(unused)]
fn main() {
  // `F`는 반드시 제네릭이어야 합니다.
  fn apply<F>(f: F) where
      F: FnOnce() {
      f();
  }
}
```

클로저가 정의될 때, 컴파일러는 캡처된 변수들을 담을 새로운 익명 구조를 내부적으로 생성합니다. 한편, `Fn`, `FnMut` 또는 `FnOnce`와 같이 여러 트레이트 중 하나로 함수에 대한 구현을 수행합니다. 이러한 타입은 호출되기 전까지 캡처된 변수에 할당됩니다.

이러한 새 타입은 알수없는 타입이기 때문에, 함수 내에서의 사용은 제네릭이 요구됩니다. 그러나, 무한한 타입 매개변수 `<T>`는 여전히 애매한 형태이기 때문에, 허용되지 않습니다. 따라서, 트레이트 중 하나(`Fn`, `FnMut`, `FnOnce`)로 그 타입을 지정해주어야 합니다.

```rust,editable
// 아무런 입력/반환이 존재하지 않는 클로저의 경우
// `F`는 반드시 `Fn`을 구현해야 합니다.
fn apply<F>(f: F) where
    F: Fn() {
    f();
}

fn main() {
    let x = 7;

    // 익명타입으로 `x`를 캡처하고
    // 이에 대해 `Fn`으로 구현합니다.
    // 이는 `print`에 저장됩니다.
    let print = || println!("{}", x);

    apply(print);
}

```