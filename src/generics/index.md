# Generics

**제네릭**은 더 다양한 상황에 적용될 수 있도록 타입과 함수를 일반화시키는 개념입니다. 이는 여러 방법으로 코드 중복을 줄일 수 있어 유용하지만, 추가적인 구문 작성을 요구합니다. 말 그대로, 제네릭이 되려면 제네릭 타입이 실제로 유효한 것으로 간주되는 타입을 명시하구 위한 세심한 주의가 필요합니다. 가장 간단하고 일반적인 제네릭의 사용은 타입 매개변수입니다.

타입 매개변수는 `<>` 괄호와 CamelCase로 제네릭을 명시할 수 있습니다. (ex. `<Aaa, Bbb, ...>`). *제네릭 타입 매개변수*는 일반적으로 `<T>`로 나타냅니다. Rust에서의 "제네릭"은 하나 이상의 제네릭 타입 매개변수를 허용하는 모든 항목을 의미합니다. 제네릭 타입 매개변수로 정의되는 어떤 타입이든 제네릭이 되며, 그렇지 않은 것들은 콘크리트(concrete, non-generic)가 됩니다.

예를 들어, `foo`라는 이름을 가진 제네릭함수를 정의하고 모든 타입에 대한 매개변수 `T`를 받도록 하겠습니다.

```rust
fn foo<T>(arg: T) { ... }
```

`T`는 `<T>`를 통해 제네릭 타입 매개변수로서 정의된 것이므로, `(arg: T)`를 사용되는 경우 제네릭이 됩니다. 이는 이미 `T`가 이전에 `struct`로 따로 정의되었더라도 마찬가지입니다.

```rust,editable
// 콘크리트 타입 A
struct A;

// Single은 콘크리트 타입이고, `A`는 바로 위에 정의된 것입니다.
struct Single(A);

// `SingleGen`은 제네릭 타입입니다.
// 타입 매개변수 `T`가 제네릭이기 때문에, 여기엔 위의 `A` 타입을 포함한 무엇이든 될 수 있습니다.
struct SingleGen<T>(T);

fn main() {
    // `Single`은 콘크리트이고, `A` 타입을 인수로 받습니다.
    let _s = Single(A);
    
    // `SingleGen<char>` 타입을 가진 `_char` 변수에 `SingleGen('a')`을 바인딩합니다.
    // 이 시점에서, 모호했던 `SingleGen`에 명시적인 타입 매개변수가 지정됩니다.
    let _char: SingleGen<char> = SingleGen('a');

    // 여전히 `SingleGen`은 내부적으로 지정된 제네릭 타입 매개변수가 있습니다.
    let _t    = SingleGen(A); // 최상단의 `A` 타입
    let _i32  = SingleGen(6); // `i32`
    let _char = SingleGen('a'); // `char`
}
```