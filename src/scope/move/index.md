# Ownership and moves

변수들은 자체 리소스들을 해방(free)하는 역할을 담당해야하기 때문에, **리소스는 오직 하나의 소유자(owner)만 가질 수 있습니다.** 이는, 리소스의 해방이 한번을 초과하며 발생하는 상황을 방지합니다. 모든 변수들이 스스로의 리소스를 소유하지는 않음(ex. references)을 명심하세요.

변수를 선언하거나(`let x = y`), 함수에 인수를 **값으로** 넘길 때(`foo(x)`), 리소스의 소유권은 이전됩니다. 이를 러스트에서는 **이동했다(move)**고 부릅니다.

리소스를 이동시키고 나면, 이전의 리소스 소유자는 더 이상 사용할 수 없습니다. 이는 [허상 포인터(Dangling pointer)](https://ko.wikipedia.org/wiki/%ED%97%88%EC%83%81_%ED%8F%AC%EC%9D%B8%ED%84%B0) 문제를 피하도록 해줍니다.

```rust
// 아래 함수는 힙에 할당된 메모리의 소유권을 갖습니다.
fn destroy_box(c: Box<i32>) {
    println!("Destroying a box that contains {}", c);

    // `c`는 파괴되고 메모리는 해방됩니다.
}

fn main() {
    // 스택(_Stack_)은 메모리를 할당합니다.
    let x = 5u32;

    // `x`를 `y`로 "복사"하는 것은 리소스를 이동시키지 않습니다.
    let y = x;

    // 양쪽 값 모두 독립적으로 사용될 수 있습니다.
    println!("x is {}, and y is {}", x, y);

    // `a`는 힙(_heap_)에 할당된 정수에 대한 포인터입니다.
    let a = Box::new(5i32);

    println!("a contains: {}", a);

    // `a`를 `b`로 "이동"시킵니다.
    let b = a;
    // 이 때 `a`의 포인터 주소(데이터가 아닙니다!)는 `b`로 복사됩니다.
    // 현재 양쪽 모두 힙에 할당된 동일한 데이터를 가리키는 포인터입니다.
    // 하지만, 이제 `b`가 데이터를 "소유"하며, `a`는 권한이 없습니다.
    
    // ERROR : `a`는 더 이상 데이터에 접근할 수 없습니다.
    // `a`는 더이상 힙 메모리를 소유하지 않기 때문입니다.
    println!("a contains: {}", a);

    // 아래 함수는 `b`로부터 힙에 할당된 메모리의 소유권을 넘겨받습니다.
    destroy_box(b);

    // 힙 메모리는 이 시점에서 해방되기 때문에,
    // 아래 작업을 수행하면 해방된 메모리를 역참조합니다.
    // 하지만, 이는 컴파일러에 의해 금지됩니다.
    // ERROR : `b`는 더 이상 데이터에 접근할 수 없습니다.
    // `b`는 더 이상 힙 메모리를 소유하지 않기 때문입니다.
    println!("b contains: {}", b);
}
```