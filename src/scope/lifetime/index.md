# Lifetimes

라이프타임(lifetime)은 컴파일러(구체적으로는, borrow checker)가 유효한 대여(borrow)만을 사용하도록 보장해줍니다. 변수의 라이프타임은 그것이 생성될 때 시작되어, 파괴될 때 끝납니다. 라이프타임과 스코프가 종종 같이 언급되는 경우가 많지만, 둘은 동일하지 않습니다.

예를 들어, 아래 예시는 `&`를 통해 변수를 대여합니다. 대여의 라이프타임은 그것이 선언되는 위치에서 결정됩니다. 그 결과, 해당 대여는 대여자가 파괴되기 전까지 유효합니다. 그러나, 대여의 스코프는 참조가 사용되는 위치에 따라 결정됩니다.

아래 예시를 통해 스코프와 라이프타임이 어떻게 다른지를 확인하세요.

```rust
// 라이프타임은 각 변수의 생성 및 파괴에 따라 결정됩니다.
// `i`는 `main` 스코프에 둘러싸여 있으므로, 그 수명이 가장 깁니다.
// `borrow1`과 `borrow2`는 블럭으로 분리되어 있어
// 각 변수의 지속시간은 서로에게 무관합니다.
fn main() {
    let i = 3; // `i`의 라이프타임 시작     ────────────────┐
    //                                                     │
    { //                                                   │
        let borrow1 = &i; // `borrow1` 라이프타임 시작   ──┐│
        //                                                ││
        println!("borrow1: {}", borrow1); //              ││
    } // `borrow1` 끝   ──────────────────────────────────┘│
    //                                                     │
    //                                                     │
    { //                                                   │
        let borrow2 = &i; // `borrow2` 라이프타임 시작 . ──┐│
        //                                                ││
        println!("borrow2: {}", borrow2); //              ││
    } // `borrow2` 끝    ─────────────────────────────────┘│
    //                                                     │
}   // `i` 라이프타임 끝 ───────────────────────────────────┘
```

라이프타임을 지정하는 별도의 이름이나 타입이 존재하지 않는다는 점을 유의하세요. 이는 추후 우리가 보게 될 내용처럼 라이프타임이 어떻게 사용될 수 있는지를 제한합니다.