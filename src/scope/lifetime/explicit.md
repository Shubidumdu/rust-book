# Explicit annotation

borrow checker는 레퍼런스가 얼마나 오래동안 유효한지를 결정하기 위해 라이프 타임의 명시적인 지정을 사용합니다. Rust는 엘리전(Elision)을 사용하지 않은 경우, 참조의 라이프타임을 결정하기 위해 명시적인 지정을 요구합니다. 라이프타임을 명시적으로 지정하기 위한 문법은 다음과 같이 `'` 문자를 사용합니다.

```rust
foo<'a>
// `foo` 는 `'a` 라이프타임 매개변수를 갖습니다.
```

클로저와 유사하게, 라이브타임의 사용은 제네릭을 요구합니다. 이에 덧붙여, 위의 라이프타임 문법은 `foo`의 라이프타임이 `'a`를 초과할 수 없음을 나타냅니다. 타입의 명시적인 지정은 `&'a T` 형식을 갖습니다. 여기서의 `'a`는 위에서와 동일합니다.

여러 라이프타임을 가져야하는 경우, 문법은 아래와 같습니다.

```rust
foo<'a, 'b>
// `foo` 는 `'a` 와 `'b` 라이프타임 매개변수를 갖습니다.
```

이 경우, `foo`의 라이프타임 `'a`와 `'b`를 초과할 수 없습니다.

명시적인 라이프타임 지정은 아래 예시와 같이 사용될 수 있습니다.

```rust
// `print_refs`는 다른 라이프타임을 갖는 `'a`와 `'b`에 대한 두 참조를 갖습니다.
// 이 두 라이프타임은 적어도 `print_refs` 내에서는 유효합니다. 
fn print_refs<'a, 'b>(x: &'a i32, y: &'b i32) {
    println!("x is {} and y is {}", x, y);
}

// 아래 함수는 아무 인수를 갖지 않지만, `'a` 라이프타임 매개변수를 갖습니다.
fn failed_borrow<'a>() {
    let _x = 12;

    // ERROR : `_x`는 `'a`보다 더 오래 존재할 수 없습니다.
    let y: &'a i32 = &_x;
    // 이 함수 내에서 `'a` 라이프 타임을 명시적 타입 지정으로 사용하는 것은
    // `&_x`가 `y`보다 짧은 라이프타임을 갖기 때문에 불가능 합니다.
    // 한 라이프타임은 그보다 더 긴 라이프타임으로 변환될 수 없습니다.
}

fn main() {
    // 아래에서 대여될 변수들을 생성합니다.
    let (four, nine) = (4, 9);
    
    // 두 변수들의 대여(`&`)가 함수로 넘겨집니다.
    print_refs(&four, &nine);
    // 대여(borrowed)는 빌린 대상(borrower)보다 긴 라이프타임을 가져야합니다.
    // 다시 말해, `four`와 `nine`의 라이프타임은 `print_refs`의 라이프타임보다 길어야 합니다.
    
    failed_borrow();
    // `failed_borrow`는 `'a`가 함수의 라이프타임보다 더 길도록
    // 강제하는 참조가 존재하지 않지만, `'a`가 더 깁니다.
    // 이는 기본적으로 라이프타임이 제한되지 않기 때문입니다.
    // 라이프타임의 기본 값은 `'static`입니다.
}
```