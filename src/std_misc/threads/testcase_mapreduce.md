# Testcase: map-reduce

Rust는 기존에 이러한 시도를 많이 경험하지 않았더라도, 데이터 처리를 매우 쉽게 병렬화할 수 있습니다.

`std` 라이브러리는 즉시 사용할 수 있는 훌륭한 쓰레드 기본 요소들을 제공합니다. 이러한 개념들은 Rust의 소유권(ownership) 및 별칭(alias) 규칙과 결합되어 데이터 [경쟁 상태](https://ko.wikipedia.org/wiki/%EA%B2%BD%EC%9F%81_%EC%83%81%ED%83%9C)에 놓이는 것을 자동으로 방지합니다.

별칭 규칙(하나의 작성가능한 참조 또는 여러 읽기 가능한 참조)들은 자동으로 다른 쓰레드에서 보여지는 상태에 대한 조작을 할 수 없게끔 합니다. (동기화가 필요한 경우, `Mutext`나 `Channel`과 같은 동기화 원시 요소들이 존재합니다.)

아래 예시에서, 우리는 여러 수를 담고 있는 블럭에 있는 모든 숫자들의 합을 구하는 연산을 할 것입니다. 블럭의 각 덩어리를 다른 쓰레드로 분할하여 해당 작업을 수행할 것입니다. 각 쓰레드는 본인 블럭의 자릿수들을 더합니다. 이후 우리는 각 쓰레드에서 생성된 중간 합계를 다시 더할것입니다.

여기서, 쓰레드 경계를 넘어서 참조를 전달함에도 불구하고, Rust는 우리가 오직 읽기 전용 참조만을 전달하고 있음을 이해하세요. 그러므로 여기에서는 데이터 경쟁 상태(Data race)가 발생할 수 없습니다. 왜냐하면, 우리가 쓰레드로 데이터 조각들을 이동시킬 때, Rust는 해당 쓰레드 내에서 빠져나가기 전까지는 해당 데이터가 보존됨을 보장하고, 그에 따라 허상 포인터(Dangling pointer)가 발생하지 않기 때문입니다.

```rust,editable
use std::thread;

// 여기는 `main` 쓰레드입니다.
fn main() {

    // 아래는 우리가 처리할 데이터입니다.
    // 여러 쓰레드의 `map-reduce` 알고리즘으로
    // 모든 자릿수에 대한 합계를 구할 것입니다.
    // 각각의 공백은 구분된 덩어리가 되어, 
    // 다른 쓰레드에서 다루어집니다.

    let data = "86967897737416471853297327050364959
11861322575564723963297542624962850
70856234701860851907960690014725639
38397966707106094172783238747669219
52380795257888236525459303330302837
58495327135744041048897885734297812
69920216438980873548808413720956532
16278424637452589860345374828574668";

    // 생성된 자식 쓰레드들을 보관할 벡터를 만듭니다.
    let mut children = vec![];

    /*************************************************************************
     * "Map" 단계
     *
     * 데이터를 여러 조각으로 나누고, 전처리를 적용합니다.
     ************************************************************************/

    // 데이터를 여러 조각으로 나누고,
    // 각 덩어리는 실제 데이터에 대한 참조(&str)가 됩니다.
    let chunked_data = data.split_whitespace();

    // 데이터 조각들을 순회합니다.
    // `.enumerate()`는 현재 무엇이 순회되는지에 대한 
    // loop index를 추가합니다.
    // "(index, element)" 결과 튜플은
    // 즉각적으로 두 변수로 분해됩니다.
    for (i, data_segment) in chunked_data.enumerate() {
        println!("data segment {} is \"{}\"", i, data_segment);

        // 분리된 쓰레드 내의 각 데이터 세그멘트를 처리합니다.
        //
        // `spawn()`은 새로운 쓰레드에 대한 처리를 반환합니다.
        // 쓰레드는 반환된 값에 접근하기 위해 반드시 보관되어야 합니다.
        // `move || -> u32`는 다음을 의미하는 클로저입니다.
        // * (`||`) : 아무 인수가 없고,
        // * (`move`) : 캡처 변수의 소유권을 가져오며,
        // * (`-> u32`) : u32 정수를 반환합니다.
        // 
        // Rust는 사실 `-> u32`에 대해서는 추론할 수 있기 때문에,
        // 여기서는 생략해도 문제 없습니다.
        children.push(thread::spawn(move || -> u32 {
            // 해당 세그멘트의 중간 합계를 계산합니다.
            let result = data_segment
                        // 세그멘트의 각 문자를 순회합니다.
                        .chars()
                        // 각 문자를 숫자로 변환합니다.
                        .map(|c| c.to_digit(10).expect("should be a digit"))
                        // 각 순회값들을 모두 합합니다.
                        .sum();

            // `println!`은 `stdout`을 막기 때문에, 텍스트 간의 간섭이 일어나진 않습니다.
            println!("processed segment {}, result={}", i, result);

            // Express는 "Expression language"이기 때문에,
            // `return`이 필요하지 않습니다.
            // 각 블럭의 마지막 Expression이
            // 자동으로 반환값이 됩니다.
            result

        }));
    }


    /*************************************************************************
     * "Reduce" 단계
     *
     * 중간 결과들을 모두 합해 최종적인 결과값을 얻습니다.
     ************************************************************************/

    // 각 쓰레드의 중간 합계들을 하나의 결과값으로 모두 더합니다.
    //
    // 여기서는 `::<>`를 사용해 `sum()`의 타입에 대해 지정합니다. 
    //
    // `::<>`를 사용하지 않고, 
    // `let final_result : u32 = ...`과 같이
    // 타입을 지정해줘도 문제 없습니다.
    let final_result = children.into_iter().map(|c| c.join().unwrap()).sum::<u32>();

    println!("Final sum result: {}", final_result);
}
```

